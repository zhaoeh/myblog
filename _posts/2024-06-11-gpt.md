---
layout:     post
title:      Spring App Builder Usage.
subtitle:   Spring App Builder Usage.
categories: [gpt]
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---

# 1. SpringApplicationBuilder用来做什么？
`SpringApplicationBuilder` 是 Spring Boot 中的一个类，用于构建和配置 Spring 应用程序。它提供了比直接使用 `SpringApplication` 更加灵活的配置选项，特别是在需要以编程方式配置应用程序时非常有用。以下是 `SpringApplicationBuilder` 的一些常见用途：

1. **链式配置**：
   `SpringApplicationBuilder` 允许通过链式调用配置多个属性和设置，提供更简洁的配置方式。

   ```java
   new SpringApplicationBuilder()
       .sources(MyApplication.class)
       .profiles("dev")
       .run(args);
   ```

2. **配置多个源**：
   可以同时配置多个主类或者配置类。

   ```java
   new SpringApplicationBuilder()
       .sources(ParentConfig.class, ChildConfig.class)
       .run(args);
   ```

3. **配置属性**：
   可以设置应用程序的属性，如应用名、web环境等。

   ```java
   new SpringApplicationBuilder()
       .sources(MyApplication.class)
       .properties("spring.config.name=myapp")
       .run(args);
   ```

4. **设置环境和参数**：
   可以自定义环境和传递参数。

   ```java
   new SpringApplicationBuilder()
       .sources(MyApplication.class)
       .run("--server.port=8081");
   ```

5. **设置上下文父子关系**：
   在微服务或模块化应用中，可能需要设置多个上下文的父子关系。

   ```java
   ConfigurableApplicationContext parent = 
       new SpringApplicationBuilder(ParentConfig.class).run(args);

   new SpringApplicationBuilder(ChildConfig.class)
       .parent(parent)
       .run(args);
   ```

6. **异步启动**：
   通过调用 `web` 方法，可以异步地启动应用程序。

   ```java
   new SpringApplicationBuilder(MyApplication.class)
       .web(WebApplicationType.NONE) // 可选择 NONE、REACTIVE、SERVLET
       .run(args);
   ```

7. **构建器模式**：
   使用构建器模式来简化复杂的应用配置。

   ```java
   SpringApplicationBuilder builder = new SpringApplicationBuilder()
       .sources(MyApplication.class)
       .profiles("prod")
       .properties("server.port=9090");

   ConfigurableApplicationContext context = builder.run(args);
   ```

总结来说，`SpringApplicationBuilder` 提供了更灵活和更强大的方式来启动和配置 Spring Boot 应用程序，特别是在需要复杂配置和编程控制时非常有用。

# 2. mapper对象中如何获取对应的datasource呢？
在 MyBatis 中，Mapper 对象的实现通常是由 MyBatis 框架生成的，它们在与数据库交互时会使用到一个 `DataSource`。如果你需要在 Mapper 对象中获取到对应的 `DataSource`，可以通过一些间接的方式实现。

以下是几种方法：

### 方法一：通过 `SqlSessionFactory`

`SqlSessionFactory` 是 MyBatis 的核心接口之一，它包含了 `Configuration` 和 `Environment`，其中 `Environment` 包含了 `DataSource`。

1. **获取 `SqlSessionFactory`：**
   可以通过依赖注入的方式将 `SqlSessionFactory` 注入到 Mapper 类中。

   ```java
   @Mapper
   public class MyMapper {
       
       @Autowired
       private SqlSessionFactory sqlSessionFactory;
       
       public DataSource getDataSource() {
           return sqlSessionFactory.getConfiguration().getEnvironment().getDataSource();
       }
   }
   ```

2. **直接使用 `SqlSession`：**
   如果在方法内部使用 `SqlSession`，也可以通过 `SqlSession` 获取 `SqlSessionFactory`。

   ```java
   @Mapper
   public class MyMapper {
       
       @Autowired
       private SqlSession sqlSession;
       
       public DataSource getDataSource() {
           SqlSessionFactory sqlSessionFactory = sqlSession.getConfiguration().getSqlSessionFactory();
           return sqlSessionFactory.getConfiguration().getEnvironment().getDataSource();
       }
   }
   ```

### 方法二：使用 Spring 的 `AbstractRoutingDataSource`

如果使用的是 Spring 的多数据源配置，可以使用 `AbstractRoutingDataSource` 来动态获取当前的 `DataSource`。

1. **配置多数据源：**

   ```java
   @Configuration
   public class DataSourceConfig {

       @Bean
       @Primary
       public DataSource dataSource() {
           Map<Object, Object> targetDataSources = new HashMap<>();
           targetDataSources.put("dataSource1", dataSource1());
           targetDataSources.put("dataSource2", dataSource2());
           
           RoutingDataSource routingDataSource = new RoutingDataSource();
           routingDataSource.setDefaultTargetDataSource(dataSource1());
           routingDataSource.setTargetDataSources(targetDataSources);
           return routingDataSource;
       }

       @Bean
       public DataSource dataSource1() {
           // 配置数据源1
       }

       @Bean
       public DataSource dataSource2() {
           // 配置数据源2
       }
   }

   public class RoutingDataSource extends AbstractRoutingDataSource {
       @Override
       protected Object determineCurrentLookupKey() {
           // 返回当前的 DataSource key，比如通过 ThreadLocal 保存的当前数据源 key
       }
   }
   ```

2. **在 Mapper 中使用：**

   ```java
   @Mapper
   public class MyMapper {
       
       @Autowired
       private DataSource dataSource;
       
       public DataSource getDataSource() {
           return dataSource;
       }
   }
   ```

### 方法三：使用 `TransactionSynchronizationManager`

如果在事务上下文中，可以通过 `TransactionSynchronizationManager` 获取到当前的 `DataSource`。

```java
import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;
import org.springframework.transaction.support.TransactionSynchronizationManager;

public class MyMapper {
   
   public DataSource getCurrentDataSource() {
       if (TransactionSynchronizationManager.isActualTransactionActive()) {
           return (DataSource) TransactionSynchronizationManager.getResource(AbstractRoutingDataSource.class);
       }
       return null;
   }
}
```

总结来说，根据具体的应用场景，可以选择合适的方法来获取 `DataSource`。最常见的方法是在使用 `SqlSessionFactory` 时，通过它来间接获取 `DataSource`。对于多数据源配置，使用 Spring 的 `AbstractRoutingDataSource` 也是一个很好的选择。

# 3. mapper对象中的dataSource怎么debug呢？我展开它的属性没有找到
在 MyBatis 中，Mapper 对象并没有直接持有 `DataSource` 的引用。`DataSource` 是通过 MyBatis 配置在后台进行管理的。如果你需要在调试时查看 Mapper 对象使用的 `DataSource`，可以通过以下几种方法间接获取并调试 `DataSource` 的属性：

### 方法一：通过 `SqlSessionFactory`

1. **在 Mapper 类中注入 `SqlSessionFactory` 并提供一个方法来获取 `DataSource`**：

   ```java
   @Mapper
   public interface MyMapper {
       // MyBatis 会自动实现这个接口
   }

   @Service
   public class MyService {

       @Autowired
       private MyMapper myMapper;

       @Autowired
       private SqlSessionFactory sqlSessionFactory;

       public void debugDataSource() {
           DataSource dataSource = sqlSessionFactory.getConfiguration().getEnvironment().getDataSource();
           // 这里可以设置断点来查看 DataSource 的属性
           System.out.println(dataSource);
       }
   }
   ```

2. **在服务或控制器类中调用这个方法**：

   ```java
   @RestController
   public class MyController {

       @Autowired
       private MyService myService;

       @GetMapping("/debug")
       public String debug() {
           myService.debugDataSource();
           return "Check your console or debugger.";
       }
   }
   ```

### 方法二：使用 Spring 的 `AbstractRoutingDataSource`

如果你使用的是 Spring 的多数据源配置，可以使用 `AbstractRoutingDataSource` 来动态获取当前的 `DataSource` 并进行调试。

1. **配置多数据源**：

   ```java
   @Configuration
   public class DataSourceConfig {

       @Bean
       @Primary
       public DataSource dataSource() {
           Map<Object, Object> targetDataSources = new HashMap<>();
           targetDataSources.put("dataSource1", dataSource1());
           targetDataSources.put("dataSource2", dataSource2());

           RoutingDataSource routingDataSource = new RoutingDataSource();
           routingDataSource.setDefaultTargetDataSource(dataSource1());
           routingDataSource.setTargetDataSources(targetDataSources);
           return routingDataSource;
       }

       @Bean
       public DataSource dataSource1() {
           // 配置数据源1
           return DataSourceBuilder.create().build();
       }

       @Bean
       public DataSource dataSource2() {
           // 配置数据源2
           return DataSourceBuilder.create().build();
       }
   }

   public class RoutingDataSource extends AbstractRoutingDataSource {
       @Override
       protected Object determineCurrentLookupKey() {
           // 返回当前的 DataSource key，比如通过 ThreadLocal 保存的当前数据源 key
           return DataSourceContextHolder.getDataSourceType();
       }
   }
   ```

2. **在 Mapper 中使用 `DataSource`**：

   ```java
   @Mapper
   public interface MyMapper {
       // MyBatis 会自动实现这个接口
   }

   @Service
   public class MyService {

       @Autowired
       private MyMapper myMapper;

       @Autowired
       private DataSource dataSource;

       public void debugDataSource() {
           // 这里可以设置断点来查看 DataSource 的属性
           System.out.println(dataSource);
       }
   }
   ```

### 方法三：通过 `TransactionSynchronizationManager`

如果在事务上下文中，可以通过 `TransactionSynchronizationManager` 获取到当前的 `DataSource`。

1. **在服务或控制器类中调试 `DataSource`**：

   ```java
   @Service
   public class MyService {

       @Autowired
       private MyMapper myMapper;

       @Autowired
       private DataSource dataSource;

       public void debugDataSource() {
           if (TransactionSynchronizationManager.isActualTransactionActive()) {
               DataSource currentDataSource = (DataSource) TransactionSynchronizationManager.getResource(dataSource);
               // 这里可以设置断点来查看 DataSource 的属性
               System.out.println(currentDataSource);
           }
       }
   }
   ```

### 结论

虽然 MyBatis Mapper 本身不直接持有 `DataSource` 的引用，但通过上述方法可以间接获取和调试 `DataSource` 的属性。在调试时，最好在合适的地方设置断点（比如在 `debugDataSource` 方法中），以便在调试器中查看 `DataSource` 的详细信息和属性。

# 4. CannotGetJdbcConnectionException，这个异常在什么情况下抛出的？我使用的是mybatisplus执行sql查询，抛出这个错误，详细的堆栈是怎样的？
`CannotGetJdbcConnectionException` 是 Spring 框架中 `org.springframework.jdbc` 包的一部分，它在无法获取 JDBC 连接时抛出。通常，这个异常表明数据库连接有问题，可能的原因包括：

1. 数据库服务器不可用。
2. 数据库连接参数配置错误（如 URL、用户名、密码）。
3. 数据库连接池已耗尽所有连接。
4. 网络问题导致无法连接到数据库服务器。

使用 MyBatis Plus 执行 SQL 查询时，如果无法获取到数据库连接，Spring 会抛出这个异常。具体的异常堆栈跟踪可以帮助定位问题。

### 详细的堆栈跟踪示例

假设在使用 MyBatis Plus 执行查询时遇到 `CannotGetJdbcConnectionException`，堆栈跟踪可能如下所示：

```java
org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is java.sql.SQLException: Unable to get a connection from pool of a PoolingDataSource containing an XADS instance.
    at org.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:81)
    at org.mybatis.spring.transaction.SpringManagedTransaction.openConnection(SpringManagedTransaction.java:82)
    at org.mybatis.spring.transaction.SpringManagedTransaction.getConnection(SpringManagedTransaction.java:68)
    at org.apache.ibatis.executor.BaseExecutor.getConnection(BaseExecutor.java:338)
    at org.apache.ibatis.executor.SimpleExecutor.prepareStatement(SimpleExecutor.java:84)
    at org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:62)
    at org.apache.ibatis.executor.BaseExecutor.queryFromDatabase(BaseExecutor.java:324)
    at org.apache.ibatis.executor.BaseExecutor.query(BaseExecutor.java:156)
    at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:109)
    at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:83)
    at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:148)
    at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:141)
    at com.baomidou.mybatisplus.core.override.MybatisMapperMethod.executeForMany(MybatisMapperMethod.java:166)
    at com.baomidou.mybatisplus.core.override.MybatisMapperMethod.execute(MybatisMapperMethod.java:78)
    at com.baomidou.mybatisplus.core.override.MybatisMapperProxy.invoke(MybatisMapperProxy.java:61)
    at com.sun.proxy.$Proxy56.selectList(Unknown Source)
    at com.example.MyService.getData(MyService.java:25)
    // ... other application-specific stack frames ...
Caused by: java.sql.SQLException: Unable to get a connection from pool of a PoolingDataSource containing an XADS instance.
    at org.apache.tomcat.jdbc.pool.DataSource.getConnection(DataSource.java:167)
    at org.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:59)
    ... 16 more
Caused by: org.apache.tomcat.jdbc.pool.PoolExhaustedException: [pool-name] Timeout: Pool empty. Unable to fetch a connection in 30 seconds, none available[size:50; busy:50; idle:0; lastwait:30000].
    at org.apache.tomcat.jdbc.pool.ConnectionPool.borrowConnection(ConnectionPool.java:718)
    at org.apache.tomcat.jdbc.pool.ConnectionPool.borrowConnection(ConnectionPool.java:589)
    at org.apache.tomcat.jdbc.pool.DataSourceProxy.getConnection(DataSourceProxy.java:132)
    at org.apache.tomcat.jdbc.pool.DataSource.getConnection(DataSource.java:163)
    ... 17 more
```

### 可能的解决方法

根据堆栈跟踪和异常原因，可以尝试以下几种方法来解决问题：

1. **检查数据库服务器**：
   确保数据库服务器正在运行，并且可以通过网络访问。

2. **验证数据库连接参数**：
   检查数据库连接 URL、用户名、密码等配置是否正确。

3. **调整连接池配置**：
   增加连接池的大小，确保在高负载情况下有足够的连接可用。

   ```yaml
   spring:
     datasource:
       url: jdbc:mysql://localhost:3306/mydb
       username: user
       password: password
       driver-class-name: com.mysql.cj.jdbc.Driver
       hikari:
         maximum-pool-size: 50
         minimum-idle: 10
         idle-timeout: 600000
         max-lifetime: 1800000
   ```

4. **检查网络连接**：
   确保应用服务器和数据库服务器之间的网络连接正常，没有防火墙或其他网络问题导致连接失败。

5. **监控和日志记录**：
   启用数据库连接池的监控和日志记录，查看连接池的使用情况和异常信息。

通过上述方法，可以帮助你定位和解决 `CannotGetJdbcConnectionException` 异常。

# 5. 我的日志下面确实还有一句：Connection is not available, request timed out after 60001ms.
根据日志中的信息，`Connection is not available, request timed out after 60001ms.` 表示在尝试获取数据库连接时，连接池在等待指定时间后仍未能获取到可用连接。这通常意味着连接池已耗尽所有连接或连接池配置存在问题。

### 可能的原因及解决方法

1. **连接池耗尽**：
   数据库连接池中的所有连接都被占用，无法提供新的连接。这可能是由于数据库连接泄漏、连接未正确关闭或系统负载过高。

   **解决方法**：
   - 检查代码中是否有未关闭的数据库连接，确保在所有数据库操作后正确关闭连接。
   - 增加连接池的大小，确保在高负载情况下有足够的连接可用。

     ```yaml
     spring:
       datasource:
         url: jdbc:mysql://localhost:3306/mydb
         username: user
         password: password
         driver-class-name: com.mysql.cj.jdbc.Driver
         hikari:
           maximum-pool-size: 50  # 增加连接池大小
           minimum-idle: 10
           idle-timeout: 600000
           max-lifetime: 1800000
           connection-timeout: 30000  # 设置合理的连接超时时间
     ```

2. **数据库连接泄漏**：
   某些数据库连接未能正确关闭，导致连接池中的连接数不断减少，最终耗尽。

   **解决方法**：
   - 使用连接池的泄漏检测功能，查找和修复连接泄漏。

     ```yaml
     spring:
       datasource:
         hikari:
           leak-detection-threshold: 2000  # 设置泄漏检测阈值（毫秒）
     ```

3. **系统负载过高**：
   系统在高负载情况下，数据库连接池中的连接被大量请求，占满连接池。

   **解决方法**：
   - 优化数据库查询，减少每个查询的执行时间。
   - 增加连接池的大小。
   - 考虑使用分布式数据库或读写分离，以减轻单个数据库的负载。

4. **网络问题**：
   网络延迟或不稳定可能导致连接池中的连接无法及时释放和获取。

   **解决方法**：
   - 检查网络连接，确保网络稳定。
   - 增加连接超时时间。

5. **数据库性能瓶颈**：
   数据库本身存在性能瓶颈，导致连接池中的连接无法及时释放。

   **解决方法**：
   - 优化数据库索引和查询。
   - 增加数据库服务器的资源（如内存、CPU）。

### 调试步骤

1. **启用连接池日志**：
   启用数据库连接池的日志记录，以便监控连接池的使用情况和异常信息。

   ```yaml
   spring:
     datasource:
       hikari:
         pool-name: MyHikariCP
         minimum-idle: 10
         maximum-pool-size: 50
         idle-timeout: 600000
         max-lifetime: 1800000
         connection-timeout: 30000
         leak-detection-threshold: 2000
         connection-test-query: SELECT 1
   ```

2. **检查代码**：
   确保所有的数据库操作都在 finally 块中正确关闭连接。

   ```java
   try (Connection conn = dataSource.getConnection();
        PreparedStatement stmt = conn.prepareStatement(sql)) {
       // 执行数据库操作
   } catch
   ```

# 6. 我的mapper接口上同时标注了@Mapper和@Component注解，有没有可能是这个原因导致的？而且现象是，程序运行几个小时候就会出现获取不到连接的情况
在 MyBatis 中，Mapper 接口通常只需要使用 `@Mapper` 注解，而不需要 `@Component` 注解。`@Mapper` 注解已经包含了将 Mapper 接口注册为 Spring Bean 的功能。因此，使用两个注解一般不会导致问题，但它不是最佳实践。

运行几个小时后出现获取不到连接的情况，通常与数据库连接池的配置和资源管理有关，而不太可能是因为 Mapper 接口上的注解问题导致的。然而，还是可以尝试去掉 `@Component` 注解，只保留 `@Mapper` 注解，以确保配置的清晰性。

### 解决和调试步骤

1. **去掉 `@Component` 注解**：
   只使用 `@Mapper` 注解。

   ```java
   @Mapper
   public interface MyMapper {
       // Mapper 方法
   }
   ```

2. **检查数据库连接池配置**：
   确保连接池配置合理，尤其是 `maximum-pool-size` 和 `connection-timeout` 等参数。

   ```yaml
   spring:
     datasource:
       url: jdbc:mysql://localhost:3306/mydb
       username: user
       password: password
       driver-class-name: com.mysql.cj.jdbc.Driver
       hikari:
         maximum-pool-size: 50
         minimum-idle: 10
         idle-timeout: 600000
         max-lifetime: 1800000
         connection-timeout: 30000
         leak-detection-threshold: 2000  # 设置泄漏检测阈值
   ```

3. **启用连接泄漏检测**：
   通过设置 `leak-detection-threshold` 参数来启用连接泄漏检测，帮助定位未关闭的连接。

4. **日志记录和监控**：
   启用连接池的日志记录和监控，以便在问题发生时能够更快地找到原因。

5. **代码审查和优化**：
   检查代码中是否有未关闭的数据库连接。确保在每个数据库操作完成后都正确关闭连接。

### 代码示例：确保连接关闭

```java
@Service
public class MyService {

    @Autowired
    private MyMapper myMapper;

    @Autowired
    private DataSource dataSource;

    public void someDatabaseOperation() {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT * FROM my_table")) {
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                // 处理结果集
            }
        } catch (SQLException e) {
            // 处理异常
            e.printStackTrace();
        }
        // try-with-resources 自动关闭连接
    }
}
```

### 定时重启连接池

如果问题依然存在，考虑定时重启连接池，清理连接池中的长期闲置连接。

```java
@Bean
public DataSource dataSource() {
    HikariDataSource hikariDataSource = new HikariDataSource();
    hikariDataSource.setJdbcUrl("jdbc:mysql://localhost:3306/mydb");
    hikariDataSource.setUsername("user");
    hikariDataSource.setPassword("password");
    hikariDataSource.setMaximumPoolSize(50);
    hikariDataSource.setMinimumIdle(10);
    hikariDataSource.setIdleTimeout(600000);
    hikariDataSource.setMaxLifetime(1800000);
    hikariDataSource.setConnectionTimeout(30000);
    hikariDataSource.setLeakDetectionThreshold(2000);

    // 添加定时重启任务
    ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();
    executorService.scheduleAtFixedRate(() -> {
        hikariDataSource.close();
        hikariDataSource.setJdbcUrl("jdbc:mysql://localhost:3306/mydb");
        hikariDataSource.setUsername("user");
        hikariDataSource.setPassword("password");
        hikariDataSource.setMaximumPoolSize(50);
        hikariDataSource.setMinimumIdle(10);
        hikariDataSource.setIdleTimeout(600000);
        hikariDataSource.setMaxLifetime(1800000);
        hikariDataSource.setConnectionTimeout(30000);
        hikariDataSource.setLeakDetectionThreshold(2000);
    }, 24, 24, TimeUnit.HOURS); // 每24小时重启一次

    return hikariDataSource;
}
```

通过这些步骤，可以帮助你解决数据库连接池在运行一段时间后出现连接耗尽的问题。重点在于确保所有数据库连接都能及时关闭，并根据系统负载合理配置连接池参数。
