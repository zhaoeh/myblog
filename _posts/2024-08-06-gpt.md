---
layout:     post
title:      I18n 实体字段处理
subtitle:   I18n 实体字段处理
categories: [gpt]
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---

# 1. HandlerInterceptor, HandlerMethodReturnValueHandler, ResponseBodyAdvice，以及全局异常处理器，我有个需求，想统一转换返回给前端的响应实体中的某些字段，当这些字段标注了某个注解，就将对应字段的值转换为国际化对应的值，也就是说，对返回给前端的响应实体字段统一做国际化的处理，也包括全局异常中返回的响应实体，该如何实现呢？
要实现对返回给前端的响应实体中的某些字段进行统一的国际化处理，可以使用以下步骤：

1. **定义注解**：
   首先，需要定义一个注解，用来标注需要进行国际化处理的字段。

   ```java
   import java.lang.annotation.ElementType;
   import java.lang.annotation.Retention;
   import java.lang.annotation.RetentionPolicy;
   import java.lang.annotation.Target;

   @Target(ElementType.FIELD)
   @Retention(RetentionPolicy.RUNTIME)
   public @interface I18nField {
   }
   ```

2. **定义国际化处理工具类**：
   接下来，定义一个工具类，用于国际化转换。

   ```java
   import java.util.Locale;
   import java.util.ResourceBundle;

   public class I18nUtil {

       public static String getMessage(String key, Locale locale) {
           ResourceBundle bundle = ResourceBundle.getBundle("messages", locale);
           return bundle.getString(key);
       }
   }
   ```

3. **实现 `ResponseBodyAdvice` 接口**：
   使用 `ResponseBodyAdvice` 接口可以在响应体返回之前对其进行处理。

   ```java
   import org.springframework.core.MethodParameter;
   import org.springframework.http.MediaType;
   import org.springframework.http.converter.HttpMessageConverter;
   import org.springframework.web.bind.annotation.ControllerAdvice;
   import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;

   import java.lang.reflect.Field;
   import java.util.Locale;

   @ControllerAdvice
   public class I18nResponseBodyAdvice implements ResponseBodyAdvice<Object> {

       @Override
       public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {
           return true;
       }

       @Override
       public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType,
                                     Class<? extends HttpMessageConverter<?>> selectedConverterType,
                                     org.springframework.http.server.ServerHttpRequest request,
                                     org.springframework.http.server.ServerHttpResponse response) {
           if (body == null) {
               return null;
           }
           if (body instanceof ResponseEntity) {
               ResponseEntity<?> responseEntity = (ResponseEntity<?>) body;
               Object responseBody = responseEntity.getBody();
               if (responseBody != null) {
                   processI18nFields(responseBody, getLocaleFromRequest(request));
               }
               return body;
           }
           processI18nFields(body, getLocaleFromRequest(request));
           return body;
       }

       private void processI18nFields(Object body, Locale locale) {
           Field[] fields = body.getClass().getDeclaredFields();
           for (Field field : fields) {
               if (field.isAnnotationPresent(I18nField.class)) {
                   field.setAccessible(true);
                   try {
                       Object value = field.get(body);
                       if (value != null) {
                           String i18nValue = I18nUtil.getMessage(value.toString(), locale);
                           field.set(body, i18nValue);
                       }
                   } catch (IllegalAccessException e) {
                       // handle exception
                   }
               }
           }
       }

       private Locale getLocaleFromRequest(org.springframework.http.server.ServerHttpRequest request) {
           // 从请求中获取语言环境，可以根据具体需求实现
           return Locale.getDefault();
       }
   }
   ```

4. **全局异常处理**：
   对于全局异常处理器，可以使用 `@ControllerAdvice` 和 `@ExceptionHandler` 注解。

   ```java
   import org.springframework.http.HttpStatus;
   import org.springframework.http.ResponseEntity;
   import org.springframework.web.bind.annotation.ControllerAdvice;
   import org.springframework.web.bind.annotation.ExceptionHandler;

   @ControllerAdvice
   public class GlobalExceptionHandler {

       @ExceptionHandler(Exception.class)
       public ResponseEntity<Object> handleException(Exception ex, org.springframework.web.context.request.WebRequest request) {
           // 构造响应实体，可以根据实际需求自定义
           ErrorResponse errorResponse = new ErrorResponse();
           errorResponse.setMessage(ex.getMessage());
           // 假设 ErrorResponse 也需要国际化处理
           processI18nFields(errorResponse, request.getLocale());
           return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
       }

       private void processI18nFields(Object body, Locale locale) {
           // 处理逻辑与上面相同
       }
   }

   class ErrorResponse {
       @I18nField
       private String message;

       // getters and setters
   }
   ```

以上步骤可以实现对返回给前端的响应实体中的某些字段进行国际化处理，包括全局异常中返回的响应实体。通过定义注解、工具类和使用 `ResponseBodyAdvice` 及全局异常处理器，实现对响应实体的统一处理。

# 2. 也就是说，ResponseBodyAdvice 的处理其实没法拦截全局异常的响应是吧？有没有一个扩展接口，能拦截Controller的响应的同时，也一并将全局异常处理器中的响应给统一拦截处理了呢？
你是对的，`ResponseBodyAdvice` 主要用于处理正常的控制器返回值，而不能直接拦截全局异常处理器中的响应。如果要统一拦截和处理控制器响应和全局异常处理器中的响应，可以考虑自定义一个过滤器（Filter）或者拦截器（Interceptor），并在其中进行统一的响应处理。

### 使用过滤器 (Filter)

通过过滤器可以拦截所有的 HTTP 请求和响应，并进行统一处理。

1. **定义过滤器**：

```java
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.annotation.WebFilter;
import java.io.IOException;
import java.io.PrintWriter;

@WebFilter(urlPatterns = "/*")
public class I18nResponseFilter implements Filter {

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        I18nResponseWrapper responseWrapper = new I18nResponseWrapper((HttpServletResponse) response);
        chain.doFilter(request, responseWrapper);

        // 获取响应内容并进行处理
        String content = responseWrapper.getContent();
        String processedContent = processI18nFields(content, request.getLocale());

        // 将处理后的内容写回响应
        response.setContentLength(processedContent.length());
        PrintWriter out = response.getWriter();
        out.write(processedContent);
        out.close();
    }

    @Override
    public void destroy() {
    }

    private String processI18nFields(String content, Locale locale) {
        // 实现你的国际化处理逻辑，可以是 JSON 解析或其他形式
        return content;
    }
}
```

2. **定义响应包装器**：

```java
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;
import java.io.CharArrayWriter;
import java.io.PrintWriter;

public class I18nResponseWrapper extends HttpServletResponseWrapper {
    private CharArrayWriter charWriter;

    public I18nResponseWrapper(HttpServletResponse response) {
        super(response);
        charWriter = new CharArrayWriter();
    }

    @Override
    public PrintWriter getWriter() {
        return new PrintWriter(charWriter);
    }

    public String getContent() {
        return charWriter.toString();
    }
}
```

### 使用拦截器 (Interceptor)

通过拦截器可以在控制器方法执行之前和之后进行处理，同时结合 `HandlerExceptionResolver` 处理异常响应。

1. **定义拦截器**：

```java
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.PrintWriter;
import java.util.Locale;

public class I18nInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
                           ModelAndView modelAndView) throws Exception {
        // 可以在这里进行国际化处理
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 可以在这里进行国际化处理
    }

    private String processI18nFields(String content, Locale locale) {
        // 实现你的国际化处理逻辑，可以是 JSON 解析或其他形式
        return content;
    }
}
```

2. **注册拦截器**：

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Autowired
    private I18nInterceptor i18nInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(i18nInterceptor).addPathPatterns("/**");
    }
}
```

3. **处理异常响应**：

创建一个自定义的 `HandlerExceptionResolver` 来处理异常响应：

```java
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.servlet.HandlerExceptionResolver;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.PrintWriter;
import java.util.Locale;

@Configuration
public class CustomExceptionResolver implements HandlerExceptionResolver, WebMvcConfigurer {

    @Override
    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
        try {
            response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());
            response.setContentType("application/json");
            String errorResponse = "{\"message\": \"" + ex.getMessage() + "\"}";

            // 处理国际化
            String processedErrorResponse = processI18nFields(errorResponse, request.getLocale());
            PrintWriter writer = response.getWriter();
            writer.write(processedErrorResponse);
            writer.flush();
        } catch (Exception handlerException) {
            // handle exception
        }
        return new ModelAndView();
    }

    private String processI18nFields(String content, Locale locale) {
        // 实现你的国际化处理逻辑，可以是 JSON 解析或其他形式
        return content;
    }
}
```

通过上述方法，使用过滤器或者拦截器结合自定义的异常处理器，可以实现对控制器正常响应和异常响应的统一国际化处理。

# 3. 那问题来了，你这个拦截器，也没有拦截全局异常中的响应啊？而且，当请求被全局异常处理器拦截后，mvc的拦截器还会执行吗？也就是全局异常处理先执行，然后再回到拦截器中继续执行吗？
在 Spring MVC 中，当请求被全局异常处理器拦截并处理后，默认情况下拦截器的 `postHandle` 方法不会执行，而是直接进入 `afterCompletion` 方法。这意味着在全局异常处理器中处理的响应内容不会被拦截器拦截和处理。

为了实现对控制器响应和全局异常处理器中的响应进行统一的国际化处理，可以使用 `ResponseBodyAdvice` 配合自定义的异常处理器。具体步骤如下：

1. **定义注解**：

   ```java
   import java.lang.annotation.ElementType;
   import java.lang.annotation.Retention;
   import java.lang.annotation.RetentionPolicy;
   import java.lang.annotation.Target;

   @Target(ElementType.FIELD)
   @Retention(RetentionPolicy.RUNTIME)
   public @interface I18nField {
   }
   ```

2. **定义国际化处理工具类**：

   ```java
   import java.util.Locale;
   import java.util.ResourceBundle;

   public class I18nUtil {

       public static String getMessage(String key, Locale locale) {
           ResourceBundle bundle = ResourceBundle.getBundle("messages", locale);
           return bundle.getString(key);
       }
   }
   ```

3. **实现 `ResponseBodyAdvice` 接口**：

   ```java
   import org.springframework.core.MethodParameter;
   import org.springframework.http.MediaType;
   import org.springframework.http.converter.HttpMessageConverter;
   import org.springframework.web.bind.annotation.ControllerAdvice;
   import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;

   import java.lang.reflect.Field;
   import java.util.Locale;

   @ControllerAdvice
   public class I18nResponseBodyAdvice implements ResponseBodyAdvice<Object> {

       @Override
       public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {
           return true;
       }

       @Override
       public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType,
                                     Class<? extends HttpMessageConverter<?>> selectedConverterType,
                                     org.springframework.http.server.ServerHttpRequest request,
                                     org.springframework.http.server.ServerHttpResponse response) {
           if (body == null) {
               return null;
           }
           if (body instanceof ResponseEntity) {
               ResponseEntity<?> responseEntity = (ResponseEntity<?>) body;
               Object responseBody = responseEntity.getBody();
               if (responseBody != null) {
                   processI18nFields(responseBody, getLocaleFromRequest(request));
               }
               return body;
           }
           processI18nFields(body, getLocaleFromRequest(request));
           return body;
       }

       private void processI18nFields(Object body, Locale locale) {
           Field[] fields = body.getClass().getDeclaredFields();
           for (Field field : fields) {
               if (field.isAnnotationPresent(I18nField.class)) {
                   field.setAccessible(true);
                   try {
                       Object value = field.get(body);
                       if (value != null) {
                           String i18nValue = I18nUtil.getMessage(value.toString(), locale);
                           field.set(body, i18nValue);
                       }
                   } catch (IllegalAccessException e) {
                       // handle exception
                   }
               }
           }
       }

       private Locale getLocaleFromRequest(org.springframework.http.server.ServerHttpRequest request) {
           // 从请求中获取语言环境，可以根据具体需求实现
           return Locale.getDefault();
       }
   }
   ```

4. **全局异常处理**：

   创建一个自定义的 `HandlerExceptionResolver` 来处理异常响应，并在其中进行国际化处理。

   ```java
   import org.springframework.http.HttpStatus;
   import org.springframework.http.ResponseEntity;
   import org.springframework.web.servlet.HandlerExceptionResolver;
   import org.springframework.web.servlet.ModelAndView;
   import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

   import javax.servlet.http.HttpServletRequest;
   import javax.servlet.http.HttpServletResponse;
   import java.io.PrintWriter;
   import java.util.Locale;

   @Configuration
   public class CustomExceptionResolver implements HandlerExceptionResolver, WebMvcConfigurer {

       @Override
       public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
           try {
               response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());
               response.setContentType("application/json");
               String errorResponse = "{\"message\": \"" + ex.getMessage() + "\"}";

               // 处理国际化
               String processedErrorResponse = processI18nFields(errorResponse, request.getLocale());
               PrintWriter writer = response.getWriter();
               writer.write(processedErrorResponse);
               writer.flush();
           } catch (Exception handlerException) {
               // handle exception
           }
           return new ModelAndView();
       }

       private String processI18nFields(String content, Locale locale) {
           // 实现你的国际化处理逻辑，可以是 JSON 解析或其他形式
           return content;
       }
   }
   ```

通过上述步骤，使用 `ResponseBodyAdvice` 可以拦截正常的控制器返回值，而自定义的 `HandlerExceptionResolver` 可以拦截异常处理的返回值，并在其中进行国际化处理。这样就实现了对控制器响应和全局异常处理器响应的统一国际化处理。

# 4. 那为什么不统一再afterCompletion 方法中处理呢？按照你的说法，不论是正常的controller响应值还是全局异常中封装后的响应值，最终都会统一走到afterCompletion 方法吧？
你说得对，实际上可以在 `afterCompletion` 方法中统一处理响应值。这样可以确保无论是正常的控制器响应还是全局异常处理器的响应都可以被统一拦截并处理。以下是一个示例，展示如何在 `afterCompletion` 方法中统一处理国际化响应。

### 使用拦截器统一处理响应

1. **定义拦截器**：

```java
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.PrintWriter;
import java.util.Locale;

@Component
public class I18nInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
                           ModelAndView modelAndView) throws Exception {
        // 在这里不做处理
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        I18nResponseWrapper responseWrapper = new I18nResponseWrapper(response);

        // 获取响应内容并进行处理
        String content = responseWrapper.getContent();
        if (content != null) {
            String processedContent = processI18nFields(content, request.getLocale());

            // 将处理后的内容写回响应
            response.setContentLength(processedContent.length());
            PrintWriter out = response.getWriter();
            out.write(processedContent);
            out.close();
        }
    }

    private String processI18nFields(String content, Locale locale) {
        // 实现你的国际化处理逻辑，可以是 JSON 解析或其他形式
        return content;
    }
}
```

2. **定义响应包装器**：

```java
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;
import java.io.CharArrayWriter;
import java.io.PrintWriter;

public class I18nResponseWrapper extends HttpServletResponseWrapper {
    private CharArrayWriter charWriter;

    public I18nResponseWrapper(HttpServletResponse response) {
        super(response);
        charWriter = new CharArrayWriter();
    }

    @Override
    public PrintWriter getWriter() {
        return new PrintWriter(charWriter);
    }

    public String getContent() {
        return charWriter.toString();
    }
}
```

3. **注册拦截器**：

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Autowired
    private I18nInterceptor i18nInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(i18nInterceptor).addPathPatterns("/**");
    }
}
```

### 处理全局异常响应

为了确保全局异常处理也能被拦截，可以在全局异常处理器中设置响应内容，然后在 `afterCompletion` 中进行处理。


# 5. 一个spring容器中，可以注册多个ResponseBodyAdvice实例吗？而且这个实现中，必须使用@ControllerAdvice注解标注吗？这个注解必须指定basePackages属性吗？不指定会怎么处理呢？
在 Spring 容器中，可以注册多个 `ResponseBodyAdvice` 实例。`@ControllerAdvice` 注解是 `ResponseBodyAdvice` 实现类必须使用的注解，用于标记一个全局的异常处理或数据绑定器等。但是，`@ControllerAdvice` 注解的 `basePackages` 属性是可选的。

### 关于 `@ControllerAdvice` 注解

1. **多个 `ResponseBodyAdvice` 实例**：

   是的，你可以在 Spring 容器中注册多个 `ResponseBodyAdvice` 实例。这些实例将按照顺序进行调用。Spring 会遍历所有的 `ResponseBodyAdvice` 实例，并应用于控制器方法的返回值。

2. **必须使用 `@ControllerAdvice` 注解**：

   `ResponseBodyAdvice` 实现类确实需要使用 `@ControllerAdvice` 注解进行标注，以便 Spring 将其识别为全局响应处理器。

3. **`@ControllerAdvice` 的 `basePackages` 属性**：

   - `basePackages` 属性是可选的。如果不指定 `basePackages`，则该 `ControllerAdvice` 将应用于所有的控制器。
   - 如果指定了 `basePackages`，则该 `ControllerAdvice` 只会应用于指定包中的控制器。

### 示例代码

#### 定义多个 `ResponseBodyAdvice` 实例

1. **定义第一个 `ResponseBodyAdvice` 实例**：

   ```java
   import org.springframework.core.MethodParameter;
   import org.springframework.http.MediaType;
   import org.springframework.http.converter.HttpMessageConverter;
   import org.springframework.web.bind.annotation.ControllerAdvice;
   import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;

   @ControllerAdvice
   public class FirstResponseBodyAdvice implements ResponseBodyAdvice<Object> {

       @Override
       public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {
           return true;
       }

       @Override
       public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType,
                                     Class<? extends HttpMessageConverter<?>> selectedConverterType,
                                     org.springframework.http.server.ServerHttpRequest request,
                                     org.springframework.http.server.ServerHttpResponse response) {
           // 第一组响应处理逻辑
           return body;
       }
   }
   ```

2. **定义第二个 `ResponseBodyAdvice` 实例**：

   ```java
   import org.springframework.core.MethodParameter;
   import org.springframework.http.MediaType;
   import org.springframework.http.converter.HttpMessageConverter;
   import org.springframework.web.bind.annotation.ControllerAdvice;
   import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;

   @ControllerAdvice
   public class SecondResponseBodyAdvice implements ResponseBodyAdvice<Object> {

       @Override
       public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {
           return true;
       }

       @Override
       public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType,
                                     Class<? extends HttpMessageConverter<?>> selectedConverterType,
                                     org.springframework.http.server.ServerHttpRequest request,
                                     org.springframework.http.server.ServerHttpResponse response) {
           // 第二组响应处理逻辑
           return body;
       }
   }
   ```

### 不指定 `basePackages` 属性的处理

如果不指定 `basePackages` 属性，`ControllerAdvice` 将应用于所有控制器。这样的话，这些 `ResponseBodyAdvice` 实现将处理所有控制器方法的返回值。

### 示例：不指定 `basePackages`

```java
import org.springframework.core.MethodParameter;
import org.springframework.http.MediaType;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;

@ControllerAdvice
public class GlobalResponseBodyAdvice implements ResponseBodyAdvice<Object> {

    @Override
    public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {
        return true;
    }

    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType,
                                  Class<? extends HttpMessageConverter<?>> selectedConverterType,
                                  org.springframework.http.server.ServerHttpRequest request,
                                  org.springframework.http.server.ServerHttpResponse response) {
        // 全局响应处理逻辑
        return body;
    }
}
```

### 总结

1. **可以注册多个 `ResponseBodyAdvice` 实例**：可以在 Spring 容器中注册多个 `ResponseBodyAdvice` 实例，它们会按照顺序进行调用。
2. **`@ControllerAdvice` 注解是必须的**：`ResponseBodyAdvice` 实现类需要使用 `@ControllerAdvice` 注解进行标注。
3. **`basePackages` 属性是可选的**：不指定 `basePackages` 属性时，`ControllerAdvice` 会应用于所有控制器；指定时，只会应用于指定包中的控制器。

# 6. 如果有多个ResponseBodyAdvice ，能手动指定彼此的优先级吗？
在 Spring 中，多个 `ResponseBodyAdvice` 实现类的优先级是可以通过实现 `org.springframework.core.Ordered` 接口或者使用 `@Order` 注解来指定的。这样可以控制它们的执行顺序。

### 通过 `Ordered` 接口指定优先级

实现 `Ordered` 接口，并覆盖 `getOrder` 方法来指定优先级。值越小，优先级越高。

```java
import org.springframework.core.Ordered;
import org.springframework.core.MethodParameter;
import org.springframework.http.MediaType;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;

@ControllerAdvice
public class FirstResponseBodyAdvice implements ResponseBodyAdvice<Object>, Ordered {

    @Override
    public int getOrder() {
        return 1; // 优先级高
    }

    @Override
    public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {
        return true;
    }

    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType,
                                  Class<? extends HttpMessageConverter<?>> selectedConverterType,
                                  org.springframework.http.server.ServerHttpRequest request,
                                  org.springframework.http.server.ServerHttpResponse response) {
        // 第一组响应处理逻辑
        return body;
    }
}

@ControllerAdvice
public class SecondResponseBodyAdvice implements ResponseBodyAdvice<Object>, Ordered {

    @Override
    public int getOrder() {
        return 2; // 优先级低
    }

    @Override
    public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {
        return true;
    }

    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType,
                                  Class<? extends HttpMessageConverter<?>> selectedConverterType,
                                  org.springframework.http.server.ServerHttpRequest request,
                                  org.springframework.http.server.ServerHttpResponse response) {
        // 第二组响应处理逻辑
        return body;
    }
}
```

### 通过 `@Order` 注解指定优先级

使用 `@Order` 注解来指定优先级，值越小，优先级越高。

```java
import org.springframework.core.annotation.Order;
import org.springframework.core.MethodParameter;
import org.springframework.http.MediaType;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;

@ControllerAdvice
@Order(1) // 优先级高
public class FirstResponseBodyAdvice implements ResponseBodyAdvice<Object> {

    @Override
    public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {
        return true;
    }

    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType,
                                  Class<? extends HttpMessageConverter<?>> selectedConverterType,
                                  org.springframework.http.server.ServerHttpRequest request,
                                  org.springframework.http.server.ServerHttpResponse response) {
        // 第一组响应处理逻辑
        return body;
    }
}

@ControllerAdvice
@Order(2) // 优先级低
public class SecondResponseBodyAdvice implements ResponseBodyAdvice<Object> {

    @Override
    public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {
        return true;
    }

    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType,
                                  Class<? extends HttpMessageConverter<?>> selectedConverterType,
                                  org.springframework.http.server.ServerHttpRequest request,
                                  org.springframework.http.server.ServerHttpResponse response) {
        // 第二组响应处理逻辑
        return body;
    }
}
```

### 总结

通过实现 `Ordered` 接口或者使用 `@Order` 注解，可以手动指定多个 `ResponseBodyAdvice` 实现类的优先级，从而控制它们的执行顺序。值越小，优先级越高，越先执行。

# 7. 如果不手动指定@Order，默认的优先级是怎么样子的？
如果不手动指定 `@Order` 注解或实现 `Ordered` 接口，Spring 对于 `ResponseBodyAdvice` 实现类的默认处理顺序是无序的，具体的执行顺序无法保证。这意味着多个没有指定优先级的 `ResponseBodyAdvice` 实现类之间的执行顺序可能会根据加载顺序等因素有所不同。

### 默认优先级的处理

1. **无序执行**：如果没有手动指定优先级，Spring 不会按照任何特定的顺序执行多个 `ResponseBodyAdvice` 实现类。它们的执行顺序是无序的，无法预测。

2. **推荐使用 `@Order` 或 `Ordered`**：为了确保你的 `ResponseBodyAdvice` 实现类按预期的顺序执行，最好显式地使用 `@Order` 注解或实现 `Ordered` 接口来指定优先级。

### 示例代码：未指定优先级

```java
import org.springframework.core.MethodParameter;
import org.springframework.http.MediaType;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;

@ControllerAdvice
public class FirstResponseBodyAdvice implements ResponseBodyAdvice<Object> {

    @Override
    public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {
        return true;
    }

    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType,
                                  Class<? extends HttpMessageConverter<?>> selectedConverterType,
                                  org.springframework.http.server.ServerHttpRequest request,
                                  org.springframework.http.server.ServerHttpResponse response) {
        // 第一组响应处理逻辑
        return body;
    }
}

@ControllerAdvice
public class SecondResponseBodyAdvice implements ResponseBodyAdvice<Object> {

    @Override
    public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {
        return true;
    }

    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType,
                                  Class<? extends HttpMessageConverter<?>> selectedConverterType,
                                  org.springframework.http.server.ServerHttpRequest request,
                                  org.springframework.http.server.ServerHttpResponse response) {
        // 第二组响应处理逻辑
        return body;
    }
}
```

### 总结

在未指定 `@Order` 注解或实现 `Ordered` 接口的情况下，`ResponseBodyAdvice` 实现类的执行顺序是无序的。为了避免不可预测的行为，并确保按预期的顺序执行，建议显式地为每个 `ResponseBodyAdvice` 实现类指定优先级。

# 8. 直接使用反射解析body的所有字段，我发现这种没法实现嵌套解析，比如我的Body里面可能存在其他属性也是个对象之类的，它底层嵌套的对象中的属性也需要做国际化转换呢？
如果你需要处理复杂嵌套结构的对象，并且希望对所有层级的字段进行国际化转换，直接使用反射可能会比较复杂和难以维护。在这种情况下，通常可以考虑使用递归方式来处理对象的嵌套结构。以下是一种可能的解决方案：

### 递归处理对象的嵌套结构

1. **定义处理方法**：

   创建一个递归方法，可以处理对象及其所有嵌套属性。

   ```java
   import java.lang.reflect.Field;
   import java.lang.reflect.Method;
   import java.util.Locale;

   public class I18nUtils {

       public static void processObject(Object object, Locale locale) {
           if (object == null) {
               return;
           }

           // 获取对象的所有字段（包括父类）
           Field[] fields = object.getClass().getDeclaredFields();
           for (Field field : fields) {
               try {
                   // 设置字段可访问
                   field.setAccessible(true);

                   // 获取字段值
                   Object value = field.get(object);

                   // 如果字段值是对象，则递归处理
                   if (value != null && !isPrimitiveOrWrapperType(value.getClass())) {
                       processObject(value, locale); // 递归处理
                   }

                   // 如果字段值需要国际化转换，则进行转换
                   if (field.isAnnotationPresent(I18n.class)) {
                       String i18nValue = getI18nValue(value, locale);
                       field.set(object, i18nValue);
                   }
               } catch (IllegalAccessException e) {
                   // 处理异常
                   e.printStackTrace();
               }
           }
       }

       private static boolean isPrimitiveOrWrapperType(Class<?> clazz) {
           return clazz.isPrimitive() ||
                  clazz.equals(Boolean.class) ||
                  clazz.equals(Byte.class) ||
                  clazz.equals(Character.class) ||
                  clazz.equals(Short.class) ||
                  clazz.equals(Integer.class) ||
                  clazz.equals(Long.class) ||
                  clazz.equals(Float.class) ||
                  clazz.equals(Double.class) ||
                  clazz.equals(String.class) ||
                  clazz.equals(Enum.class);
       }

       private static String getI18nValue(Object value, Locale locale) {
           // 实现你的国际化逻辑
           return value.toString(); // 这里仅示意，实际需要根据具体业务逻辑处理
       }
   }
   ```

2. **添加国际化注解 `@I18n`**：

   在需要进行国际化转换的字段上，添加 `@I18n` 注解。

   ```java
   import java.lang.annotation.ElementType;
   import java.lang.annotation.Retention;
   import java.lang.annotation.RetentionPolicy;
   import java.lang.annotation.Target;

   @Target(ElementType.FIELD)
   @Retention(RetentionPolicy.RUNTIME)
   public @interface I18n {
   }
   ```

3. **使用示例**：

   在需要处理的对象中，调用 `I18nUtils.processObject` 方法进行处理。

   ```java
   public class Main {

       public static void main(String[] args) {
           // 示例对象
           User user = new User("John", new Address("123 Street", "City"));

           // 处理对象及其嵌套属性的国际化转换
           I18nUtils.processObject(user, Locale.US);

           // 打印结果
           System.out.println(user.getName()); // 输出国际化后的姓名
           System.out.println(user.getAddress().getCity()); // 输出国际化后的城市
       }
   }

   class User {
       @I18n
       private String name;
       private Address address;

       public User(String name, Address address) {
           this.name = name;
           this.address = address;
       }

       public String getName() {
           return name;
       }

       public Address getAddress() {
           return address;
       }
   }

   class Address {
       @I18n
       private String street;
       @I18n
       private String city;

       public Address(String street, String city) {
           this.street = street;
           this.city = city;
       }

       public String getStreet() {
           return street;
       }

       public String getCity() {
           return city;
       }
   }
   ```

### 注意事项

- **递归处理**：确保递归方法能够处理对象的所有嵌套属性。
- **字段可访问性**：在处理字段值前，确保设置字段可访问。
- **异常处理**：适当处理反射过程中可能抛出的异常，如 `IllegalAccessException`。
- **国际化逻辑**：根据实际需求实现正确的国际化逻辑，例如从资源文件中获取对应的国际化值。

通过这种方式，你可以比较灵活地处理复杂对象的国际化需求，包括嵌套对象的属性。

# 9. 当某个字段是数组或者是List时，我觉得应该单独处理这种情况
当字段是数组或者 `List` 时，需要单独处理这些集合类型中的每个元素。下面的代码演示了如何递归处理对象，包括对数组和 `List` 的支持。

### 递归处理包含集合类型的对象

1. **定义处理方法**：

   创建一个递归方法，处理对象及其所有嵌套属性，包括数组和 `List`。

   ```java
   import java.lang.reflect.Field;
   import java.lang.reflect.ParameterizedType;
   import java.lang.reflect.Type;
   import java.util.List;
   import java.util.Locale;

   public class I18nUtils {

       public static void processObject(Object object, Locale locale) {
           if (object == null) {
               return;
           }

           // 获取对象的所有字段（包括父类）
           Field[] fields = object.getClass().getDeclaredFields();
           for (Field field : fields) {
               try {
                   // 设置字段可访问
                   field.setAccessible(true);

                   // 获取字段值
                   Object value = field.get(object);

                   // 如果字段值是对象或集合类型，则递归处理
                   if (value != null) {
                       if (value.getClass().isArray()) {
                           // 处理数组
                           processArray(value, locale);
                       } else if (value instanceof List) {
                           // 处理 List
                           processList((List<?>) value, locale);
                       } else if (!isPrimitiveOrWrapperType(value.getClass())) {
                           // 处理嵌套对象
                           processObject(value, locale);
                       }
                   }

                   // 如果字段值需要国际化转换，则进行转换
                   if (field.isAnnotationPresent(I18n.class)) {
                       String i18nValue = getI18nValue(value, locale);
                       field.set(object, i18nValue);
                   }
               } catch (IllegalAccessException e) {
                   // 处理异常
                   e.printStackTrace();
               }
           }
       }

       private static void processArray(Object array, Locale locale) {
           int length = java.lang.reflect.Array.getLength(array);
           for (int i = 0; i < length; i++) {
               Object element = java.lang.reflect.Array.get(array, i);
               if (element != null && !isPrimitiveOrWrapperType(element.getClass())) {
                   processObject(element, locale); // 递归处理数组元素
               }
           }
       }

       private static void processList(List<?> list, Locale locale) {
           for (Object element : list) {
               if (element != null && !isPrimitiveOrWrapperType(element.getClass())) {
                   processObject(element, locale); // 递归处理 List 元素
               }
           }
       }

       private static boolean isPrimitiveOrWrapperType(Class<?> clazz) {
           return clazz.isPrimitive() ||
                  clazz.equals(Boolean.class) ||
                  clazz.equals(Byte.class) ||
                  clazz.equals(Character.class) ||
                  clazz.equals(Short.class) ||
                  clazz.equals(Integer.class) ||
                  clazz.equals(Long.class) ||
                  clazz.equals(Float.class) ||
                  clazz.equals(Double.class) ||
                  clazz.equals(String.class) ||
                  clazz.equals(Enum.class);
       }

       private static String getI18nValue(Object value, Locale locale) {
           // 实现你的国际化逻辑
           return value.toString(); // 这里仅示意，实际需要根据具体业务逻辑处理
       }
   }
   ```

2. **使用示例**：

   在需要处理的对象中，调用 `I18nUtils.processObject` 方法进行处理。

   ```java
   import java.util.Arrays;
   import java.util.List;

   public class Main {

       public static void main(String[] args) {
           // 示例对象
           Address address1 = new Address("123 Street", "City1");
           Address address2 = new Address("456 Avenue", "City2");
           User user = new User("John", Arrays.asList(address1, address2), new Address[] { address1, address2 });

           // 处理对象及其嵌套属性的国际化转换
           I18nUtils.processObject(user, Locale.US);

           // 打印结果
           System.out.println(user.getName()); // 输出国际化后的姓名
           for (Address address : user.getAddresses()) {
               System.out.println(address.getCity()); // 输出国际化后的城市
           }
           for (Address address : user.getAddressArray()) {
               System.out.println(address.getCity()); // 输出国际化后的城市
           }
       }
   }

   class User {
       @I18n
       private String name;
       private List<Address> addresses;
       private Address[] addressArray;

       public User(String name, List<Address> addresses, Address[] addressArray) {
           this.name = name;
           this.addresses = addresses;
           this.addressArray = addressArray;
       }

       public String getName() {
           return name;
       }

       public List<Address> getAddresses() {
           return addresses;
       }

       public Address[] getAddressArray() {
           return addressArray;
       }
   }

   class Address {
       @I18n
       private String street;
       @I18n
       private String city;

       public Address(String street, String city) {
           this.street = street;
           this.city = city;
       }

       public String getStreet() {
           return street;
       }

       public String getCity() {
           return city;
       }
   }
   ```

### 注意事项

- **递归处理集合类型**：在处理数组和 `List` 时，确保递归处理每个元素。
- **避免循环引用**：在处理递归嵌套对象时，注意避免循环引用导致的无限递归。
- **国际化逻辑**：根据实际需求实现正确的国际化逻辑，例如从资源文件中获取对应的国际化值。

通过这种方式，你可以灵活地处理复杂对象的国际化需求，包括数组和 `List` 类型的嵌套对象。

# 10. Spring中是否可以对全局异常处理器中的响应进行统一拦截处理的方式呢？我想统一修改全局异常处理器的响应值
在 Spring 中，你可以通过编写一个自定义的 `ResponseBodyAdvice` 来统一拦截和处理全局异常处理器的响应值。`ResponseBodyAdvice` 允许你在响应体写出之前修改响应数据，包括来自全局异常处理器的响应。

### 实现步骤

1. **创建全局异常处理器**：定义一个全局异常处理器，处理所有异常并返回统一的响应实体。

2. **实现 `ResponseBodyAdvice`**：创建一个 `ResponseBodyAdvice` 实现类，用于拦截和修改响应数据。

3. **配置 `ControllerAdvice`**：将 `ResponseBodyAdvice` 类标注为 `@ControllerAdvice` 以全局应用它。

### 示例代码

1. **全局异常处理器**：

   ```java
   import org.springframework.http.HttpStatus;
   import org.springframework.http.ResponseEntity;
   import org.springframework.web.bind.annotation.ControllerAdvice;
   import org.springframework.web.bind.annotation.ExceptionHandler;
   import org.springframework.web.bind.annotation.RestControllerAdvice;

   @RestControllerAdvice
   public class GlobalExceptionHandler {

       @ExceptionHandler(Exception.class)
       public ResponseEntity<ErrorResponse> handleException(Exception ex) {
           ErrorResponse errorResponse = new ErrorResponse("ERROR", ex.getMessage());
           return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
       }

       static class ErrorResponse {
           private String status;
           private String message;

           public ErrorResponse(String status, String message) {
               this.status = status;
               this.message = message;
           }

           // Getters and setters
           public String getStatus() {
               return status;
           }

           public void setStatus(String status) {
               this.status = status;
           }

           public String getMessage() {
               return message;
           }

           public void setMessage(String message) {
               this.message = message;
           }
       }
   }
   ```

2. **实现 `ResponseBodyAdvice`**：

   ```java
   import org.springframework.core.MethodParameter;
   import org.springframework.http.MediaType;
   import org.springframework.http.converter.HttpMessageConverter;
   import org.springframework.web.bind.annotation.ControllerAdvice;
   import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;

   @ControllerAdvice
   public class CustomResponseBodyAdvice implements ResponseBodyAdvice<Object> {

       @Override
       public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {
           return true; // 处理所有的响应
       }

       @Override
       public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType,
                                     Class<? extends HttpMessageConverter<?>> selectedConverterType,
                                     org.springframework.http.server.ServerHttpRequest request,
                                     org.springframework.http.server.ServerHttpResponse response) {
           if (body instanceof GlobalExceptionHandler.ErrorResponse) {
               GlobalExceptionHandler.ErrorResponse errorResponse = (GlobalExceptionHandler.ErrorResponse) body;
               // 对错误响应进行统一处理
               errorResponse.setMessage("统一处理后的消息: " + errorResponse.getMessage());
               return errorResponse;
           }

           // 对其他响应进行处理
           // 示例：对返回的实体进行国际化处理
           if (body != null) {
               I18nUtils.processObject(body, Locale.getDefault());
           }

           return body;
       }
   }
   ```

3. **国际化工具类 `I18nUtils`**（与之前的实现相同，此处略）：

   ```java
   // 同上，I18nUtils 实现递归处理对象，包括数组和 List 类型
   ```

### 总结

通过以上步骤，你可以实现对全局异常处理器的响应值进行统一拦截和处理。`ResponseBodyAdvice` 的 `beforeBodyWrite` 方法将拦截所有响应体，包括由全局异常处理器返回的响应，从而实现统一的修改和处理。

# 11. ResponseBodyAdvice也能拦截全局异常处理器中的响应吗？
是的，`ResponseBodyAdvice` 可以拦截全局异常处理器中的响应。`ResponseBodyAdvice` 会在所有返回体被写出之前被调用，这包括由全局异常处理器返回的响应。因此，可以利用 `ResponseBodyAdvice` 统一处理所有响应体。

以下是一个完整的示例，包括全局异常处理器和 `ResponseBodyAdvice` 的实现。

### 示例代码

1. **全局异常处理器**：

   ```java
   import org.springframework.http.HttpStatus;
   import org.springframework.http.ResponseEntity;
   import org.springframework.web.bind.annotation.ControllerAdvice;
   import org.springframework.web.bind.annotation.ExceptionHandler;
   import org.springframework.web.bind.annotation.RestControllerAdvice;

   @RestControllerAdvice
   public class GlobalExceptionHandler {

       @ExceptionHandler(Exception.class)
       public ResponseEntity<ErrorResponse> handleException(Exception ex) {
           ErrorResponse errorResponse = new ErrorResponse("ERROR", ex.getMessage());
           return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
       }

       static class ErrorResponse {
           private String status;
           private String message;

           public ErrorResponse(String status, String message) {
               this.status = status;
               this.message = message;
           }

           // Getters and setters
           public String getStatus() {
               return status;
           }

           public void setStatus(String status) {
               this.status = status;
           }

           public String getMessage() {
               return message;
           }

           public void setMessage(String message) {
               this.message = message;
           }
       }
   }
   ```

2. **实现 `ResponseBodyAdvice`**：

   ```java
   import org.springframework.core.MethodParameter;
   import org.springframework.http.MediaType;
   import org.springframework.http.converter.HttpMessageConverter;
   import org.springframework.web.bind.annotation.ControllerAdvice;
   import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;

   @ControllerAdvice
   public class CustomResponseBodyAdvice implements ResponseBodyAdvice<Object> {

       @Override
       public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {
           return true; // 处理所有的响应
       }

       @Override
       public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType,
                                     Class<? extends HttpMessageConverter<?>> selectedConverterType,
                                     org.springframework.http.server.ServerHttpRequest request,
                                     org.springframework.http.server.ServerHttpResponse response) {
           if (body instanceof GlobalExceptionHandler.ErrorResponse) {
               GlobalExceptionHandler.ErrorResponse errorResponse = (GlobalExceptionHandler.ErrorResponse) body;
               // 对错误响应进行统一处理
               errorResponse.setMessage("统一处理后的消息: " + errorResponse.getMessage());
               return errorResponse;
           }

           // 对其他响应进行处理
           // 示例：对返回的实体进行国际化处理
           if (body != null) {
               I18nUtils.processObject(body, Locale.getDefault());
           }

           return body;
       }
   }
   ```

3. **国际化工具类 `I18nUtils`**（与之前的实现相同，此处略）：

   ```java
   // I18nUtils 实现递归处理对象，包括数组和 List 类型
   ```

### 总结

通过 `ResponseBodyAdvice`，你可以统一拦截和处理所有响应体，包括正常的控制器响应和全局异常处理器的响应。这样可以确保所有的响应体都经过一致的处理逻辑，例如国际化转换或统一的错误消息格式化。

# 12. @RestControllerAdvice和@ControllerAdvice的区别是啥？这两者的执行原理是AOP吗？底层原理是啥呢？
`@RestControllerAdvice` 和 `@ControllerAdvice` 都是 Spring 框架中用于全局处理控制器异常、数据绑定和响应体的注解，但它们有一些区别。

### `@ControllerAdvice`

- **作用范围**：适用于所有使用 `@Controller` 注解的控制器。
- **返回类型**：默认情况下，方法返回的视图名称和模型对象被解析为视图名称和模型数据，而不是直接写入 HTTP 响应体。
- **典型用途**：用于传统的 MVC 应用程序，其中控制器方法返回视图名称和模型数据。

### `@RestControllerAdvice`

- **作用范围**：适用于所有使用 `@RestController` 注解的控制器。
- **返回类型**：方法返回的对象会直接作为 HTTP 响应体写入，而不是视图名称或模型数据。
- **典型用途**：用于 RESTful Web 服务，其中控制器方法返回 JSON 或 XML 格式的数据。

### 示例代码

**使用 `@ControllerAdvice`**：

```java
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    public String handleException(Exception ex, Model model) {
        model.addAttribute("error", ex.getMessage());
        return "error"; // 返回视图名称
    }
}
```

**使用 `@RestControllerAdvice`**：

```java
@RestControllerAdvice
public class GlobalRestExceptionHandler {

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleException(Exception ex) {
        ErrorResponse errorResponse = new ErrorResponse("ERROR", ex.getMessage());
        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR); // 返回 JSON 响应
    }

    static class ErrorResponse {
        private String status;
        private String message;

        public ErrorResponse(String status, String message) {
            this.status = status;
            this.message = message;
        }

        // Getters and setters
    }
}
```

### AOP 和底层原理

- **AOP 作用**：`@ControllerAdvice` 和 `@RestControllerAdvice` 的执行原理确实基于 AOP（面向切面编程）。Spring 使用 AOP 在控制器执行之前、之后和抛出异常时插入额外的逻辑。
- **底层实现**：
  - Spring 在启动时会扫描带有 `@ControllerAdvice` 和 `@RestControllerAdvice` 注解的类，并将它们注册为全局异常处理器、全局数据绑定器和全局数据格式化器。
  - 当请求进入 Spring MVC 时，DispatcherServlet 会调用适当的处理器方法。
  - 如果在处理请求时抛出异常，Spring 会检查是否有任何异常处理器（例如 `@ControllerAdvice` 或 `@RestControllerAdvice` 中定义的处理器）与异常类型匹配，并调用相应的处理器方法。
  - `@ExceptionHandler` 方法中的逻辑在异常处理时被调用，并处理异常，生成响应。

### 总结

- `@ControllerAdvice` 和 `@RestControllerAdvice` 主要用于全局异常处理、数据绑定和数据格式化。
- `@ControllerAdvice` 适用于传统的 MVC 应用，返回视图名称和模型数据。
- `@RestControllerAdvice` 适用于 RESTful Web 服务，返回 JSON 或 XML 格式的数据。
- 两者的执行原理基于 AOP，Spring 使用 AOP 在控制器执行之前、之后和抛出异常时插入额外的逻辑。

# 13. 它们在dispatcherServlet中，被触发调用的源码是什么？
在 Spring MVC 中，`@ControllerAdvice` 和 `@RestControllerAdvice` 的功能通过多个组件的协同工作来实现。这些组件在 `DispatcherServlet` 中被触发调用。以下是一些关键点和相关的源码位置。

### 异常处理

全局异常处理器的实现通过 `HandlerExceptionResolver` 接口来完成，Spring 提供了一些默认的实现，例如 `ExceptionHandlerExceptionResolver`，它负责调用 `@ExceptionHandler` 方法。

在 `DispatcherServlet` 中，当请求处理过程中发生异常时，`DispatcherServlet` 会调用 `processHandlerException` 方法：

```java
protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
    ModelAndView exMv = null;

    // Check registered HandlerExceptionResolvers...
    for (HandlerExceptionResolver handlerExceptionResolver : this.handlerExceptionResolvers) {
        exMv = handlerExceptionResolver.resolveException(request, response, handler, ex);
        if (exMv != null) {
            break;
        }
    }

    // If no exception resolver matched, rethrow the exception
    if (exMv == null) {
        throw ex;
    }

    return exMv;
}
```

### ResponseBodyAdvice 处理

`ResponseBodyAdvice` 的处理是通过 `RequestMappingHandlerAdapter` 实现的。`RequestMappingHandlerAdapter` 是处理请求的主要适配器，它在处理请求的过程中，会调用 `invokeHandlerMethod` 方法，该方法最终会调用 `ServletInvocableHandlerMethod` 的 `invokeAndHandle` 方法：

```java
protected void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {
    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);
    setResponseStatus(webRequest);

    if (returnValue == null) {
        if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) {
            disableContentCachingIfNecessary(webRequest);
            return;
        }
    } else if (!"".equals(returnValue)) {
        mavContainer.setRequestHandled(false);
    }

    if (mavContainer.isRequestHandled()) {
        // No ModelAndView rendering, only a single response
        return;
    }

    this.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);
}
```

在处理返回值时，会调用 `HandlerMethodReturnValueHandlerComposite` 中的 `handleReturnValue` 方法，该方法会依次调用所有注册的 `HandlerMethodReturnValueHandler` 实现，其中 `RequestResponseBodyMethodProcessor` 是一个重要的实现，它会处理 `@ResponseBody` 和 `ResponseBodyAdvice`。

### 相关源码

- **`DispatcherServlet`**：处理整个请求的核心类，管理请求的调度、异常处理等。
  - 源码位置：`org.springframework.web.servlet.DispatcherServlet`

- **`HandlerExceptionResolver`**：用于处理异常的接口。
  - 源码位置：`org.springframework.web.servlet.HandlerExceptionResolver`

- **`ExceptionHandlerExceptionResolver`**：处理 `@ExceptionHandler` 方法的解析器。
  - 源码位置：`org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver`

- **`RequestMappingHandlerAdapter`**：处理请求的主要适配器。
  - 源码位置：`org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter`

- **`HandlerMethodReturnValueHandlerComposite`**：处理返回值的组合处理器。
  - 源码位置：`org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite`

- **`RequestResponseBodyMethodProcessor`**：处理 `@ResponseBody` 注解和 `ResponseBodyAdvice` 的处理器。
  - 源码位置：`org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor`

通过这些组件的协同工作，Spring 实现了对控制器响应和异常的统一处理，并允许通过 `@ControllerAdvice` 和 `@RestControllerAdvice` 进行全局配置和处理。

# 14. 跟不下去源码，请从DispatcherServlet开始，逐步分析一下呢？
好的，我们从 `DispatcherServlet` 开始，逐步分析 Spring MVC 中的响应处理和异常处理的源码路径。

### 1. DispatcherServlet

`DispatcherServlet` 是 Spring MVC 的前端控制器，它负责将请求分发到相应的处理器方法。我们先看 `DispatcherServlet` 的核心方法 `doDispatch`：

```java
protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
    HttpServletRequest processedRequest = request;
    HandlerExecutionChain mappedHandler = null;
    boolean multipartRequestParsed = false;

    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

    try {
        ModelAndView mv = null;
        Exception dispatchException = null;

        try {
            processedRequest = checkMultipart(request);
            multipartRequestParsed = (processedRequest != request);

            // Determine handler for the current request.
            mappedHandler = getHandler(processedRequest);
            if (mappedHandler == null || mappedHandler.getHandler() == null) {
                noHandlerFound(processedRequest, response);
                return;
            }

            // Apply preHandle methods of registered interceptors.
            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

            // Process last-modified header, if supported by the handler.
            String method = request.getMethod();
            boolean isGet = "GET".equals(method);
            if (isGet || "HEAD".equals(method)) {
                long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
                if (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {
                    return;
                }
            }

            if (!mappedHandler.applyPreHandle(processedRequest, response)) {
                return;
            }

            // Actually invoke the handler.
            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

            if (asyncManager.isConcurrentHandlingStarted()) {
                return;
            }

            applyDefaultViewName(processedRequest, mv);
            mappedHandler.applyPostHandle(processedRequest, response, mv);
        }
        catch (Exception ex) {
            dispatchException = ex;
        }
        catch (Throwable err) {
            dispatchException = new NestedServletException("Handler dispatch failed", err);
        }

        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
    }
    catch (Exception ex) {
        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
    }
    catch (Throwable err) {
        triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException("Handler processing failed", err));
    }
    finally {
        if (asyncManager.isConcurrentHandlingStarted()) {
            mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
        }
        else {
            if (multipartRequestParsed) {
                cleanupMultipart(processedRequest);
            }
        }
    }
}
```

### 2. 处理结果的 `processDispatchResult` 方法

这个方法负责处理请求处理结果，包括正常返回和异常处理：

```java
private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
        @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception)
        throws Exception {

    boolean errorView = false;

    if (exception != null) {
        if (exception instanceof ModelAndViewDefiningException) {
            logger.debug("ModelAndViewDefiningException encountered", exception);
            mv = ((ModelAndViewDefiningException) exception).getModelAndView();
        }
        else {
            Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);
            mv = processHandlerException(request, response, handler, exception);
            errorView = (mv != null);
        }
    }

    // Do we need view name translation?
    if (mv != null && !mv.wasCleared()) {
        render(mv, request, response);
        if (errorView) {
            WebUtils.clearErrorRequestAttributes(request);
        }
    }
    else {
        if (logger.isDebugEnabled()) {
            logger.debug("Null ModelAndView returned to DispatcherServlet with name '" +
                    getServletName() + "': assuming HandlerAdapter completed request handling");
        }
    }

    if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
        // Concurrent handling started during a forward
        return;
    }

    if (mappedHandler != null) {
        mappedHandler.triggerAfterCompletion(request, response, null);
    }
}
```

### 3. 处理异常的 `processHandlerException` 方法

`processHandlerException` 会调用所有注册的 `HandlerExceptionResolver`，例如 `ExceptionHandlerExceptionResolver`，以处理异常：

```java
@Nullable
protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,
        @Nullable Object handler, Exception ex) throws Exception {

    ModelAndView exMv = null;
    for (HandlerExceptionResolver handlerExceptionResolver : this.handlerExceptionResolvers) {
        exMv = handlerExceptionResolver.resolveException(request, response, handler, ex);
        if (exMv != null) {
            break;
        }
    }

    if (exMv != null) {
        if (exMv.isEmpty()) {
            request.setAttribute(EXCEPTION_ATTRIBUTE, ex);
            return null;
        }
        if (!exMv.hasView()) {
            exMv.setViewName(getDefaultViewName(request));
        }
        if (logger.isDebugEnabled()) {
            logger.debug("Resolved [" + ex + "] to ModelAndView [" + exMv + "] for handler [" + handler + "]");
        }
        WebUtils.exposeErrorRequestAttributes(request, ex, getServletName());
    }

    return exMv;
}
```

### 4. 处理返回值的 `RequestMappingHandlerAdapter`

在 `RequestMappingHandlerAdapter` 中处理返回值时会调用 `invokeHandlerMethod` 方法：

```java
@Override
protected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {
    ServletWebRequest webRequest = new ServletWebRequest(request, response);
    WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);
    ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);

    ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);
    if (this.argumentResolvers != null) {
        invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
    }
    if (this.returnValueHandlers != null) {
        invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
    }
    invocableMethod.setDataBinderFactory(binderFactory);
    invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);

    ModelAndViewContainer mavContainer = new ModelAndViewContainer();
    mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));
    modelFactory.initModel(webRequest, mavContainer, invocableMethod);
    mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);

    AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);
    asyncWebRequest.setTimeout(this.asyncRequestTimeout);
    WebAsyncUtils.getAsyncManager(request).setAsyncWebRequest(asyncWebRequest);

    if (asyncWebRequest.isAsyncStarted()) {
        WebAsyncUtils.getAsyncManager(request).startDeferredResultProcessing((DeferredResult<?>) asyncWebRequest);
        return null;
    }

    invocableMethod.invokeAndHandle(webRequest, mavContainer);

    if (asyncWebRequest.isAsyncStarted()) {
        return null;
    }

    return getModelAndView(mavContainer, modelFactory, webRequest);
}
```

### 5. 处理返回值的 `ServletInvocableHandlerMethod`

`ServletInvocableHandlerMethod` 是具体调用控制器方法并处理返回值的类。在 `invokeAndHandle` 方法中，会调用所有注册的 `HandlerMethodReturnValueHandler` 来处理返回值：

```java
public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs)
        throws Exception {

    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);
    setResponseStatus(webRequest);

    if (returnValue == null) {
        if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) {
            disableContentCachingIfNecessary(webRequest);
            return;
        }
    } else if (!"".equals(returnValue)) {
        mavContainer.setRequestHandled(false);
    }

    if (mavContainer.isRequestHandled()) {
        return;
    }

    try {
        this.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);
    } catch (Exception ex) {
        if (logger.isTraceEnabled()) {
            logger.trace(getReturnValueType(returnValue), ex);
        }
        throw ex;
    }
}
```

### 6. 处理返回值的 `HandlerMethodReturnValueHandlerComposite`

`HandlerMethodReturnValueHandlerComposite` 是 `HandlerMethodReturnValueHandler` 的组合实现，它会依次调用所有注册的 `HandlerMethodReturnValueHandler` 实现：

```java
@Override
public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer,
        NativeWebRequest webRequest) throws Exception {

    for (HandlerMethodReturnValueHandler handler : this.returnValueHandlers) {
        if (handler.supportsReturnType(returnType)) {
            handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);
            return;
        }
    }

    throw new IllegalArgumentException("Unsupported return value type: " + returnType.getParameterType().getName());
}
```

其中一个重要的实现是 `RequestResponseBodyMethodProcessor

# 15. 当发生异常，处理异常后，返回的内容也会被RequestResponseBodyMethodProcessor拦截处理？
是的，当发生异常时，异常处理器处理后的返回内容也会被 `RequestResponseBodyMethodProcessor` 拦截处理。我们来看具体流程。

### 异常处理后的返回内容处理流程

1. **异常处理器处理异常**：

   当控制器抛出异常时，`DispatcherServlet` 会调用异常处理器 `HandlerExceptionResolver` 来处理异常，如 `ExceptionHandlerExceptionResolver`。这些异常处理器会根据异常类型和处理逻辑生成一个 `ModelAndView` 对象。

   ```java
   @Nullable
   protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,
           @Nullable Object handler, Exception ex) throws Exception {

       ModelAndView exMv = null;
       for (HandlerExceptionResolver handlerExceptionResolver : this.handlerExceptionResolvers) {
           exMv = handlerExceptionResolver.resolveException(request, response, handler, ex);
           if (exMv != null) {
               break;
           }
       }

       if (exMv != null) {
           if (exMv.isEmpty()) {
               request.setAttribute(EXCEPTION_ATTRIBUTE, ex);
               return null;
           }
           if (!exMv.hasView()) {
               exMv.setViewName(getDefaultViewName(request));
           }
           if (logger.isDebugEnabled()) {
               logger.debug("Resolved [" + ex + "] to ModelAndView [" + exMv + "] for handler [" + handler + "]");
           }
           WebUtils.exposeErrorRequestAttributes(request, ex, getServletName());
       }

       return exMv;
   }
   ```

2. **渲染视图**：

   异常处理器返回的 `ModelAndView` 对象会被 `DispatcherServlet` 渲染为最终的 HTTP 响应。这时候，Spring MVC 会调用 `RequestMappingHandlerAdapter` 中的 `invokeHandlerMethod` 方法，它会进一步调用 `ServletInvocableHandlerMethod` 的 `invokeAndHandle` 方法。

3. **`ServletInvocableHandlerMethod` 的 `invokeAndHandle` 方法**：

   `invokeAndHandle` 方法中会调用所有注册的 `HandlerMethodReturnValueHandler` 来处理返回值，包括异常处理器返回的值。

   ```java
   public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs)
           throws Exception {

       Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);
       setResponseStatus(webRequest);

       if (returnValue == null) {
           if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) {
               disableContentCachingIfNecessary(webRequest);
               return;
           }
       } else if (!"".equals(returnValue)) {
           mavContainer.setRequestHandled(false);
       }

       if (mavContainer.isRequestHandled()) {
           return;
       }

       try {
           this.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);
       } catch (Exception ex) {
           if (logger.isTraceEnabled()) {
               logger.trace(getReturnValueType(returnValue), ex);
           }
           throw ex;
       }
   }
   ```

4. **调用 `RequestResponseBodyMethodProcessor`**：

   `RequestResponseBodyMethodProcessor` 是 `HandlerMethodReturnValueHandler` 的实现之一。它会处理带有 `@ResponseBody` 注解的返回值，以及异常处理器返回的值。它会将返回的对象转换为 JSON 或 XML 等格式，并写入 HTTP 响应中。

   ```java
   public class RequestResponseBodyMethodProcessor extends AbstractMessageConverterMethodProcessor {

       @Override
       public boolean supportsReturnType(MethodParameter returnType) {
           return (AnnotationUtils.findAnnotation(returnType.getContainingClass(), ResponseBody.class) != null ||
                   returnType.hasMethodAnnotation(ResponseBody.class));
       }

       @Override
       public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,
               ModelAndViewContainer mavContainer, NativeWebRequest webRequest)
               throws IOException, HttpMediaTypeNotAcceptableException {

           mavContainer.setRequestHandled(true);
           writeWithMessageConverters(returnValue, returnType, webRequest);
       }
   }
   ```

### 统一处理返回内容

如果希望统一处理所有返回内容（包括正常响应和异常响应），可以使用 `ResponseBodyAdvice` 接口来实现。`ResponseBodyAdvice` 可以拦截和修改所有带有 `@ResponseBody` 注解的响应内容。

#### 示例代码

```java
@RestControllerAdvice
public class GlobalResponseBodyAdvice implements ResponseBodyAdvice<Object> {

    @Override
    public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {
        // 可以根据需求在此处添加条件，决定是否拦截响应
        return true;
    }

    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType,
                                  Class<? extends HttpMessageConverter<?>> selectedConverterType,
                                  ServerHttpRequest request, ServerHttpResponse response) {
        // 在此处统一处理响应内容
        if (body instanceof ErrorResponse) {
            // 处理异常响应
            return handleErrorResponse((ErrorResponse) body);
        } else {
            // 处理正常响应
            return handleNormalResponse(body);
        }
    }

    private Object handleErrorResponse(ErrorResponse body) {
        // 处理异常响应逻辑
        return body;
    }

    private Object handleNormalResponse(Object body) {
        // 处理正常响应逻辑
        return body;
    }
}
```

使用 `ResponseBodyAdvice` 可以统一处理所有返回内容，包括全局异常处理器的返回值。这样，不管是正常返回还是异常返回，都会经过统一的处理逻辑。

# 16. getMethodArgumentValues和findProvidedArgument方法分别做什么？
`getMethodArgumentValues` 和 `findProvidedArgument` 方法在 Spring MVC 中主要用于解析和提供处理器方法参数。它们分别承担了从请求中解析参数和找到预先提供的参数的职责。以下是对这两个方法的详细解释。

### `getMethodArgumentValues`

`getMethodArgumentValues` 方法的作用是解析处理器方法（如控制器方法）的参数。这个方法会依次调用注册的 `HandlerMethodArgumentResolver` 实现，从 HTTP 请求中提取参数值并进行解析。`HandlerMethodArgumentResolver` 是一个接口，它的实现类负责解析不同类型的参数，例如请求参数、路径变量、请求体等。

#### 代码示例

以下是 `AbstractInvocableHandlerMethod` 类中的 `getMethodArgumentValues` 方法：

```java
protected Object[] getMethodArgumentValues(NativeWebRequest request, ModelAndViewContainer mavContainer,
                                           Object... providedArgs) throws Exception {

    MethodParameter[] parameters = getMethodParameters();
    if (ObjectUtils.isEmpty(parameters)) {
        return EMPTY_ARGS;
    }
    Object[] args = new Object[parameters.length];
    for (int i = 0; i < parameters.length; i++) {
        MethodParameter parameter = parameters[i];
        parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);
        GenericTypeResolver.resolveParameterType(parameter, getBean().getClass());
        args[i] = resolveProvidedArgument(parameter, request, providedArgs);
        if (args[i] != null) {
            continue;
        }
        if (!this.resolvers.supportsParameter(parameter)) {
            throw new IllegalStateException(formatArgumentError(parameter, "No suitable resolver for argument"));
        }
        try {
            args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);
        } catch (Exception ex) {
            if (logger.isDebugEnabled()) {
                logger.debug(formatArgumentError(parameter, "Failed to resolve argument"), ex);
            }
            throw ex;
        }
    }
    return args;
}
```

### `findProvidedArgument`

`findProvidedArgument` 方法的作用是从提供的参数数组中查找和返回匹配的参数。这些提供的参数通常在调用控制器方法时显式传入，例如在测试中或手动调用处理器方法时。

#### 代码示例

以下是 `InvocableHandlerMethod` 类中的 `findProvidedArgument` 方法：

```java
@Nullable
private Object findProvidedArgument(MethodParameter parameter, @Nullable Object[] providedArgs) {
    if (providedArgs == null) {
        return null;
    }
    for (Object providedArg : providedArgs) {
        if (parameter.getParameterType().isInstance(providedArg)) {
            return providedArg;
        }
    }
    return null;
}
```

### 详细解析

#### `getMethodArgumentValues` 方法解析：

1. **获取方法参数**：首先获取处理器方法的所有参数。
2. **初始化参数值数组**：创建一个数组来存储解析后的参数值。
3. **遍历每个参数**：
   - 初始化参数名发现器。
   - 解析参数类型。
   - 尝试从提供的参数中解析当前参数（调用 `findProvidedArgument` 方法）。
   - 如果找到了提供的参数，跳过继续解析。
   - 检查是否有支持该参数类型的解析器。
   - 使用支持该参数类型的解析器来解析参数值，并处理异常。

#### `findProvidedArgument` 方法解析：

1. **检查提供的参数数组是否为 null**：如果为 null，返回 null。
2. **遍历提供的参数数组**：检查每个提供的参数是否与方法参数类型匹配。
3. **返回匹配的参数值**：如果找到匹配的参数值，返回该值；如果没有找到，返回 null。

### 总结

- `getMethodArgumentValues` 负责从请求中解析处理器方法的所有参数值，依赖于 `HandlerMethodArgumentResolver` 来处理不同类型的参数。
- `findProvidedArgument` 负责从提供的参数数组中查找和返回与方法参数类型匹配的参数值。

通过这两个方法，Spring MVC 能够灵活地解析和提供处理器方法所需的参数，确保控制器方法能够正确接收和处理客户端请求的数据。

# 17. @ControllerAdvice标注的类，如果在jar包中或者另外一个module中，当前的微服务启动并不能扫描到它，我通过自动配置类的@Bean方式手动注册了它的对象，这时spring容器启动的时候会不会向容器中注册两个实例化对象呢？因为毕竟@Bean标注后会创建一个对象，@ControllerAdvice标注本身也是让spring容器负责实例化一个对象
在 Spring 容器中，默认情况下，如果你通过 `@Bean` 方法手动注册一个 `@ControllerAdvice` 标注的类，并且该类本身被 Spring 扫描到，确实会有创建两个实例化对象的风险。为了避免这种情况，你可以采取以下措施来确保只有一个实例被注册：

1. **确保 Spring 容器不会自动扫描到 `@ControllerAdvice` 标注的类**：

   - 使用 `@ComponentScan` 注解时，明确排除掉这个类。
   - 将该类放在一个不会被 Spring 扫描的包路径中。

2. **使用条件装配（Conditional Configuration）**：

   - 使用 `@Conditional` 注解，基于一定的条件决定是否装配该 `@ControllerAdvice` 类。

### 解决方案 1：明确排除扫描路径

假设你的 `@ControllerAdvice` 类在 `com.example.advice` 包下，你可以通过 `@ComponentScan` 的 `excludeFilters` 属性排除该包路径：

```java
@ComponentScan(basePackages = "com.example",
               excludeFilters = @ComponentScan.Filter(type = FilterType.REGEX, pattern = "com.example.advice.*"))
public class AppConfig {
    // other configurations
}
```

### 解决方案 2：使用条件装配

你可以创建一个自定义条件来控制 `@Bean` 的装配。例如：

```java
import org.springframework.context.annotation.Conditional;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Bean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;

@Configuration
public class AdviceConfiguration {

    @Bean
    @ConditionalOnMissingBean(MyControllerAdvice.class)
    public MyControllerAdvice myControllerAdvice() {
        return new MyControllerAdvice();
    }
}
```

`@ConditionalOnMissingBean` 注解确保只有当容器中不存在 `MyControllerAdvice` 的实例时，才会创建一个新的实例。

### 示例代码

以下是一个完整的示例，展示了如何避免重复注册 `@ControllerAdvice` 类：

#### `MyControllerAdvice.java`

```java
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.http.ResponseEntity;

@ControllerAdvice
public class MyControllerAdvice {

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleException(Exception ex) {
        return ResponseEntity.status(500).body("Internal Server Error: " + ex.getMessage());
    }
}
```

#### `AdviceConfiguration.java`

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;

@Configuration
public class AdviceConfiguration {

    @Bean
    @ConditionalOnMissingBean(MyControllerAdvice.class)
    public MyControllerAdvice myControllerAdvice() {
        return new MyControllerAdvice();
    }
}
```

#### `AppConfig.java`

```java
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan(basePackages = "com.example",
               excludeFilters = @ComponentScan.Filter(type = FilterType.REGEX, pattern = "com.example.advice.*"))
public class AppConfig {
    // other configurations
}
```

### 总结

通过这种方式，可以确保 `MyControllerAdvice` 类不会被 Spring 自动扫描到，同时通过 `@ConditionalOnMissingBean` 注解确保不会重复创建该类的实例，从而避免了实例重复注册的问题。

# 18. 不不，我的意思是，我现在有一个自定义的MyControllerAdvice ，这个类在另外一个module中，它上面也标注了@ControllerAdvice注解。现在我通过自动配置类@Bean的方式手动创建了MyControllerAdvice 的实例对象交给了spring容器进行管理。这个时候spring容器中会注册两个MyControllerAdvice 实例对象么？
在 Spring 容器中，如果你手动通过 `@Bean` 注册了一个 `@ControllerAdvice` 标注的类的实例，并且该类被 Spring 自动扫描到，会存在注册两个实例的风险。这是因为 `@Bean` 方法会创建一个实例，而 `@ControllerAdvice` 标注会让 Spring 自动扫描并创建一个实例。

为了避免这种情况，你可以采取以下方法之一来确保 Spring 容器中只注册一个实例：

1. **使用 `@ConditionalOnMissingBean` 注解**：这种方式会确保只有在容器中没有现有的 `MyControllerAdvice` 实例时，才会通过 `@Bean` 方法创建一个新的实例。

2. **排除自动扫描**：将包含 `@ControllerAdvice` 的包从自动扫描中排除，以确保该类不会被自动扫描到。

### 使用 `@ConditionalOnMissingBean`

这种方式会确保容器中只有一个 `MyControllerAdvice` 实例。你可以在自动配置类中这样配置：

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;

@Configuration
public class MyAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean(MyControllerAdvice.class)
    public MyControllerAdvice myControllerAdvice() {
        return new MyControllerAdvice();
    }
}
```

### 排除自动扫描

如果你明确知道哪个包会被扫描到，可以排除包含 `MyControllerAdvice` 的包：

```java
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.FilterType;

@Configuration
@ComponentScan(basePackages = "com.example",
               excludeFilters = @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, value = MyControllerAdvice.class))
public class AppConfig {
    // other configurations
}
```

### 示例代码

假设你的 `MyControllerAdvice` 类在 `com.example.advice` 包下，你可以通过 `@ConditionalOnMissingBean` 和 `excludeFilters` 两种方式来确保容器中只有一个 `MyControllerAdvice` 实例。

#### `MyControllerAdvice.java`

```java
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.http.ResponseEntity;

@ControllerAdvice
public class MyControllerAdvice {

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleException(Exception ex) {
        return ResponseEntity.status(500).body("Internal Server Error: " + ex.getMessage());
    }
}
```

#### `MyAutoConfiguration.java`

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;

@Configuration
public class MyAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean(MyControllerAdvice.class)
    public MyControllerAdvice myControllerAdvice() {
        return new MyControllerAdvice();
    }
}
```

#### `AppConfig.java`

```java
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.FilterType;

@Configuration
@ComponentScan(basePackages = "com.example",
               excludeFilters = @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, value = MyControllerAdvice.class))
public class AppConfig {
    // other configurations
}
```

### 总结

通过使用 `@ConditionalOnMissingBean` 或排除自动扫描，可以确保 Spring 容器中只注册一个 `MyControllerAdvice` 实例，避免重复注册的风险。这样做可以确保你的自定义 `MyControllerAdvice` 既可以通过自动配置类进行管理，又不会在容器中产生重复实例。

# 19. 你似乎没有理解我的意思，换一个问法，spring容器创建MyControllerAdvice 的实例对象时，是根据类上面标注的@ControllerAdvice注解进行创建的吗？只要类上面标注有@ControllerAdvice注解，就通过反射创建它的对象吗？原理是否和@Component注解原理一样呢？
是的，Spring 容器创建 `MyControllerAdvice` 实例对象时，是根据类上面标注的 `@ControllerAdvice` 注解进行创建的。`@ControllerAdvice` 是一个特殊的 `@Component`，它会被 Spring 扫描到，并且其作用类似于 `@Component`，但它的功能是用于全局的异常处理、数据绑定、模型属性的处理等。

### `@ControllerAdvice` 和 `@Component` 的原理

`@ControllerAdvice` 是一个组合注解，其底层原理和 `@Component` 类似。`@Component` 是一个通用的注解，用于标识 Spring 管理的组件，而 `@ControllerAdvice` 是一个特化的组件，专门用于定义全局的异常处理、数据绑定、以及模型属性的处理。

### 创建过程

1. **组件扫描**：Spring 容器在启动时，会根据配置的包路径扫描带有 `@Component` 及其特化注解（例如 `@ControllerAdvice`）的类。
   
2. **实例化**：对于扫描到的类，Spring 容器会通过反射机制实例化这些类的对象，并将其注册到 Spring 容器中。

3. **管理生命周期**：Spring 容器管理这些对象的生命周期，包括依赖注入、初始化、销毁等。

### 源码解析

当 Spring 容器启动时，`@ControllerAdvice` 类会被 `ComponentScan` 机制扫描到，随后会被注册到容器中。具体流程可以参考 `AnnotationConfigApplicationContext` 的实现。

#### 组件扫描过程

```java
public class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry {
    // ...
    @Override
    public void refresh() throws BeansException, IllegalStateException {
        this.registerBeanDefinition();
        super.refresh();
    }
    
    private void registerBeanDefinition() {
        AnnotatedBeanDefinitionReader reader = new AnnotatedBeanDefinitionReader(this);
        ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this);
        scanner.scan(basePackages);
    }
    // ...
}
```

#### 解析 `@ControllerAdvice`

Spring 的组件扫描器（例如 `ClassPathBeanDefinitionScanner`）会扫描类路径中的所有类文件，对于带有 `@Component` 及其派生注解的类，会解析它们并注册为 `BeanDefinition`。

```java
public class ClassPathBeanDefinitionScanner extends ClassPathScanningCandidateComponentProvider {
    @Override
    protected Set<BeanDefinition> findCandidateComponents(String basePackage) {
        Set<BeanDefinition> candidates = new LinkedHashSet<>();
        try {
            String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
                    resolveBasePackage(basePackage) + '/' + this.resourcePattern;
            Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath);
            for (Resource resource : resources) {
                if (resource.isReadable()) {
                    MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource);
                    if (isCandidateComponent(metadataReader)) {
                        ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
                        sbd.setResource(resource);
                        sbd.setSource(resource);
                        if (isCandidateComponent(sbd)) {
                            candidates.add(sbd);
                        }
                    }
                }
            }
        } catch (IOException ex) {
            throw new BeanDefinitionStoreException("I/O failure during classpath scanning", ex);
        }
        return candidates;
    }
}
```

#### 实例化和管理

对于扫描到的 `@ControllerAdvice` 类，会通过反射机制实例化并注册到 Spring 容器中。其管理生命周期的原理与 `@Component` 类似。

### 结论

- `@ControllerAdvice` 注解的类会被 Spring 容器扫描到，并通过反射机制实例化。
- 其底层原理与 `@Component` 相同，都是由 Spring 的组件扫描机制处理的。
- Spring 容器会在启动时扫描、实例化、并管理这些带有 `@ControllerAdvice` 注解的类。

因此，如果你手动通过 `@Bean` 方法注册了一个 `@ControllerAdvice` 类，而这个类本身也被 Spring 自动扫描到，就可能会导致注册两个实例的情况。避免这种情况的方法是确保不要重复注册同一个类，可以通过上面提到的排除扫描或者条件装配来实现。

# 20. ok，也就是只要spring容器能够扫描到@ControllerAdvice标注的类，就会自动通过反射创建它的实例化对象；那么现在，当我通过@Bean的方式手动注册目标类，它上面的@ControllerAdvice注解还会被spring容器解析吗？
当你通过 `@Bean` 的方式手动注册一个 `@ControllerAdvice` 标注的类时，`@ControllerAdvice` 注解不会被 Spring 容器再次解析。这是因为 `@Bean` 方法明确地告诉 Spring 容器要创建并管理该类的实例，Spring 容器不会重复解析该类的注解。

以下是对这个过程的详细解释：

1. **自动扫描**：Spring 容器在启动时会扫描包路径中带有 `@ControllerAdvice` 注解的类，并自动创建其实例。

2. **手动注册**：当你在配置类中通过 `@Bean` 方法手动注册某个类的实例时，Spring 容器会按照 `@Bean` 方法的定义创建并管理该实例。

### 示例代码

假设 `MyControllerAdvice` 类在 `com.example.advice` 包下，并且被 `@ControllerAdvice` 注解标注：

```java
package com.example.advice;

import org.springframework.web.bind.annotation.ControllerAdvice;

@ControllerAdvice
public class MyControllerAdvice {
    // ... 
}
```

### 自动配置类中手动注册

在自动配置类中，通过 `@Bean` 手动注册 `MyControllerAdvice`：

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MyAutoConfiguration {

    @Bean
    public MyControllerAdvice myControllerAdvice() {
        return new MyControllerAdvice();
    }
}
```

### 结果

- 如果 `MyControllerAdvice` 类被 Spring 容器扫描到，并且没有通过 `@Bean` 手动注册，Spring 容器会自动创建并管理一个 `MyControllerAdvice` 的实例。
- 如果你在自动配置类中通过 `@Bean` 手动注册了 `MyControllerAdvice`，Spring 容器会按照 `@Bean` 方法的定义创建并管理该实例，并且不会重复解析 `@ControllerAdvice` 注解。

### 测试验证

为了验证这一点，你可以在 `MyControllerAdvice` 的构造方法中添加一个日志输出：

```java
package com.example.advice;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.ControllerAdvice;

@ControllerAdvice
public class MyControllerAdvice {

    private static final Logger logger = LoggerFactory.getLogger(MyControllerAdvice.class);

    public MyControllerAdvice() {
        logger.info("MyControllerAdvice instance created");
    }
}
```

运行应用程序并观察日志输出，你会发现只有一个 `MyControllerAdvice` 实例被创建。

### 结论

当你通过 `@Bean` 手动注册一个 `@ControllerAdvice` 标注的类时，Spring 容器会按照 `@Bean` 方法创建并管理该实例，而不会再次解析 `@ControllerAdvice` 注解。因此，通过 `@Bean` 手动注册可以避免重复实例化的问题，同时确保 `@ControllerAdvice` 的功能得以实现。

# 21. 经过我的验证，ResponseBodyAdvice 确实可以同时拦截全局异常处理后的响应
非常感谢您的验证反馈！`ResponseBodyAdvice` 确实可以拦截全局异常处理后的响应。这是因为 `ResponseBodyAdvice` 会拦截所有使用 `@ResponseBody` 或返回 `ResponseEntity` 类型的响应，包括全局异常处理器返回的响应。

### 为什么 `ResponseBodyAdvice` 能够拦截全局异常处理后的响应

当 Spring 处理请求时，如果在执行控制器方法的过程中抛出异常，Spring 会跳转到异常处理流程：

1. **异常处理器**：首先，全局异常处理器（标注了 `@ControllerAdvice` 并包含 `@ExceptionHandler` 方法）会捕获异常，并生成响应对象。
2. **ResponseBodyAdvice**：生成的响应对象会通过 `ResponseBodyAdvice` 进行进一步处理。

### 示例代码

以下是一个 `ResponseBodyAdvice` 的实现示例，可以拦截所有返回的响应，包括全局异常处理器的响应：

#### 实现 `ResponseBodyAdvice`

```java
import org.springframework.core.MethodParameter;
import org.springframework.http.MediaType;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.server.ServerHttpRequest;
import org.springframework.http.server.ServerHttpResponse;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;

@ControllerAdvice
public class CustomResponseBodyAdvice implements ResponseBodyAdvice<Object> {

    @Override
    public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {
        return true; // 适用于所有响应
    }

    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType,
                                  Class<? extends HttpMessageConverter<?>> selectedConverterType,
                                  ServerHttpRequest request, ServerHttpResponse response) {
        // 在此处理响应对象，例如进行国际化转换
        if (body instanceof ErrorResponse) {
            // 针对异常响应的处理
            ErrorResponse errorResponse = (ErrorResponse) body;
            // 进行国际化转换或其他处理
        } else {
            // 针对正常响应的处理
        }
        return body; // 返回处理后的响应对象
    }
}
```

#### 全局异常处理器

```java
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.http.ResponseEntity;

@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleException(Exception ex) {
        ErrorResponse errorResponse = new ErrorResponse("Internal Server Error", ex.getMessage());
        return ResponseEntity.status(500).body(errorResponse);
    }
}
```

#### 错误响应对象

```java
public class ErrorResponse {
    private String error;
    private String message;

    public ErrorResponse(String error, String message) {
        this.error = error;
        this.message = message;
    }

    // getters and setters
}
```

### 测试验证

通过上述配置，无论是正常控制器方法返回的响应，还是全局异常处理器返回的响应，都会经过 `CustomResponseBodyAdvice` 的 `beforeBodyWrite` 方法进行处理。

### 结论

`ResponseBodyAdvice` 可以统一拦截和处理控制器方法和全局异常处理器的响应。这使得在整个应用中实现统一的响应处理逻辑（例如国际化转换）变得更加方便和一致。通过这种方式，你可以确保所有返回的响应都符合预期的格式和内容。

# 22. 众所周知，ResponseBodyAdvice实际上会被spring进行代理，生成一个代理对象。我现在想使用@Aspect对spring管理的ResponseBodyAdvice代理对象，再进行一次代理，目的是在执行它的beforeBodyWrite方法之前或者之后拦截处理我自己加入的逻辑，请问spring中允许我对ResponseBodyAdvice进行再度代理吗？
在 Spring 中，对已经由 Spring 管理的 `ResponseBodyAdvice` 进行再次代理是可能的，但这涉及到几个关键点和一些潜在的复杂性。以下是如何实现这一目标的步骤和考虑因素：

### 实现步骤

1. **定义 Aspect**：使用 Spring AOP 创建一个切面（Aspect），用来拦截 `ResponseBodyAdvice` 的 `beforeBodyWrite` 方法。

2. **配置 AOP**：确保 Spring AOP 的支持已配置，并且切面能够拦截到 `ResponseBodyAdvice` 的方法。

3. **确保代理链**：由于 `ResponseBodyAdvice` 已经由 Spring 进行代理，你的切面需要确保能够正确地应用到这个代理对象上。

### 示例代码

#### 定义切面（Aspect）

创建一个切面来拦截 `ResponseBodyAdvice` 的 `beforeBodyWrite` 方法：

```java
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class ResponseBodyAdviceAspect {

    @AfterReturning(pointcut = "execution(* org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice.beforeBodyWrite(..))", returning = "result")
    public void aroundBeforeBodyWrite(JoinPoint joinPoint, Object result) {
        // 在 beforeBodyWrite 方法执行后进行处理
        System.out.println("ResponseBodyAdvice beforeBodyWrite executed");
        // 你可以在这里处理逻辑
    }
}
```

#### 配置 AOP

确保你的 Spring 配置中启用了 AOP：

```java
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

@Configuration
@EnableAspectJAutoProxy
public class AppConfig {
    // 配置相关 Bean
}
```

### 注意事项

1. **代理链的顺序**：Spring AOP 生成的代理对象本身可能已经是一个 JDK 动态代理或 CGLIB 代理。如果你的切面（Aspect）需要再对这个代理进行处理，确保你理解代理链的顺序和影响。

2. **切点表达式**：确保你的切点表达式能够准确地匹配 `ResponseBodyAdvice` 的方法。如果你使用的是 JDK 动态代理，可能需要使用接口方法的切点表达式；如果是 CGLIB 代理，可能需要针对具体的实现类。

3. **性能考虑**：增加额外的代理层可能会对性能产生影响。在生产环境中，确保进行适当的性能测试。

### 结论

在 Spring 中对 `ResponseBodyAdvice` 进行再度代理是可行的。通过定义切面并配置 AOP，你可以在 `ResponseBodyAdvice` 的 `beforeBodyWrite` 方法执行之前或之后添加自定义逻辑。确保你的切点表达式准确匹配目标方法，并考虑代理链和性能影响。

# 23. 通过自定义注解的方式实现呢？
