---
layout:     post
title:      java中的位运算
subtitle:   合理的场景中使用位运算可以解决业务难题
categories: [零散知识点]
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---

# 1.什么是位运算？
## 1.1 什么是十进制计算？
1+1=2，这是一个运算公式，它表示一种逻辑计算，即两个1相加，在数学上等于2.

## 1.2 计算机怎么存储数据？
我们通过键盘录入的所有信息，最终存储到计算机的内存中，是按照二进制的结构进行存储的。      
简单理解就是：任何数据，最终存储的形态都是二进制数字。      
那不同的信息，怎么区分呢？      
一个信息，对应一串二进制数字，这一串二进制数字的位置、顺序、每个位置的值（0还是1），决定了一个信息的唯一性。    

上面的数据存储模型，实际上是计算机存储任何数据的底层模型。    
即：计算机存储任何数据，都是按照二进制存储的，每一个二进制占一个内存bit位。每一个bit位的取值，要么是0，要么是1。     
最终这一组010101存储的模式，用来反映人类可以理解的语言信息。     

可以将计算机的每一个bit位想象成一个抽屉，这个抽屉里只能放0，或者放1。一排抽屉根据其放置的0,1数据和顺序，来表示其对应的逻辑数据。   

## 1.3 位运算
理解了计算机存储数据的底层模型，都是0101的二进制位表示法。那么这里的位运算就比较容易理解了，位，就是二进制存储0或者1的那个内存位置，俗称bit位（比特位，占一个字节）。   
所谓位运算，其实就是在对二进制存储模型中的每一个bit位，做相应的运算。    
本质都是一个bit位和另外一个bit位之间的计算逻辑。    

# 2.常见的位运算
把计算机存储的二进制模式，想象成一排抽屉：   
| 抽屉 | 抽屉 | 抽屉 | 抽屉 | 抽屉 | 抽屉 | ...
计算机中，所有存储信息，本质都是一排抽屉。    

每个抽屉：   
只能放 0 或 1   

放不下别的   

比如数字 5：   
5 = 101（二进制）

| 1 | 0 | 1 |

因此，先默认形成一个二进制常识：计算机只看0和1.   

## 2.1 << n   
<< n 的本质：把所有抽屉里的东西，整体向左挪 n 个位置，右边补 0。     
不是“算”，是**搬家**。   

假设你有：
```text
原来的数：3
二进制：  11
```
想象成：
```text
| 1 | 1 | 0 |
```

3 << 1表示：所有的东西向左挪1格   
```text
| 1 | 1 | 0 |
```
这在二进制里是 `110`，
换成十进制是 **6**。

3 << 2 呢？   
```text
| 1 | 1 | 0 | 0 |
```
十进制：12   

**用一句话记住**   
> **`<<` = 把二进制往左推，右边用 0 填**

## 2.2 那 `|`（或运算）是在干嘛？
**本质一句话**

> **或运算：两个抽屉，只要有一个是 1，结果就是 1**

规则极其简单：

| 左 | 右 | 结果 |
| - | - | -- |
| 0 | 0 | 0  |
| 0 | 1 | 1  |
| 1 | 0 | 1  |
| 1 | 1 | 1  |

---

## 用“贴标签”理解

```text
A: 100000
B: 000101
```

`A | B`：

```text
结果: 100101
```

👉 **谁有 1，就保留**

---

## 2.3 `&`（与运算）在干嘛？
**一句话**

> **与运算 = 盖遮罩，只留下你想要的位**

规则：

| 左 | 右 | 结果 |
| - | - | -- |
| 0 | 0 | 0  |
| 0 | 1 | 0  |
| 1 | 0 | 0  |
| 1 | 1 | 1  |

👉 **只有 1 和 1 才留下**

---
