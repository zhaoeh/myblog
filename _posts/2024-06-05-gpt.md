---
layout:     post
title:      Parent POM, Dependency Inheritance
subtitle:   Parent POM, Dependency Inheritance
categories: [gpt]
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---

# 1. pom中的parent有什么用？子module集成了parent后，会自动集成parent的所有依赖吗？如何排除不想要的依赖呢？
在 Maven 项目的 `pom.xml` 文件中，`<parent>` 元素用于指定一个父 POM。这种层次结构可以简化和集中化依赖管理、插件管理以及构建配置。以下是一些关键点：

### 父 POM 的作用
1. **继承依赖管理**：
   子模块会继承父 POM 中定义的依赖管理（dependencyManagement）。这意味着子模块可以使用父 POM 中定义的版本，而不需要在子模块的 `pom.xml` 中显式指定版本。

2. **插件管理**：
   父 POM 可以定义构建插件和插件管理（pluginManagement），子模块可以继承和使用这些插件。

3. **统一版本控制**：
   父 POM 可以定义统一的依赖版本和插件版本，确保所有子模块使用相同的版本，避免版本冲突。

4. **共享配置**：
   父 POM 可以定义一些共同的构建配置和属性，子模块可以直接继承和使用这些配置。

### 子模块继承依赖管理
子模块会继承父 POM 中通过 `dependencyManagement` 元素定义的依赖版本管理。需要注意的是，`dependencyManagement` 只定义版本信息，子模块需要显式地声明使用哪些依赖：

```xml
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <version>2.5.4</version>
        </dependency>
    </dependencies>
</dependencyManagement>
```

子模块 `pom.xml` 中的依赖声明：

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
</dependencies>
```

由于父 POM 中已经定义了版本，子模块无需再指定版本信息。

### 排除不需要的依赖
如果子模块不需要某些依赖，可以在子模块的 `pom.xml` 中使用 `exclusions` 元素来排除这些依赖。例如：

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
        <exclusions>
            <exclusion>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-tomcat</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
</dependencies>
```

以上示例中，`spring-boot-starter-web` 依赖中默认包含了 `spring-boot-starter-tomcat`，通过 `exclusions` 可以将其排除。

### 示例
一个完整的父 POM 示例：

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>parent-project</artifactId>
    <version>1.0.0</version>
    <packaging>pom</packaging>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-web</artifactId>
                <version>2.5.4</version>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <build>
        <pluginManagement>
            <plugins>
                <plugin>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-maven-plugin</artifactId>
                    <version>2.5.4</version>
                </plugin>
            </plugins>
        </pluginManagement>
    </build>
</project>
```

子模块的 `pom.xml` 示例：

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.example</groupId>
        <artifactId>parent-project</artifactId>
        <version>1.0.0</version>
    </parent>
    <artifactId>child-project</artifactId>
    <version>1.0.0</version>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <exclusions>
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-tomcat</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
    </dependencies>
</project>
```

通过以上配置，子模块可以继承父 POM 中的依赖管理和插件管理，并且可以通过 `exclusions` 来排除不需要的依赖。

# 2. 我现在是父pom中定义了一个依赖a，但是子module不需要这个aa
如果父 POM 中定义了一个依赖，而子模块不需要这个依赖，可以通过在子模块中排除该依赖来实现。这里有两种方法来处理这种情况：

### 方法一：在父 POM 中定义依赖管理，不直接添加依赖

在父 POM 中使用 `dependencyManagement` 只定义版本管理，而不直接添加依赖。这样子模块可以选择是否需要这个依赖。

#### 父 POM 示例：

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>parent-project</artifactId>
    <version>1.0.0</version>
    <packaging>pom</packaging>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>com.example</groupId>
                <artifactId>dependency-a</artifactId>
                <version>1.0.0</version>
            </dependency>
        </dependencies>
    </dependencyManagement>
</project>
```

#### 子模块示例：

如果子模块需要 `dependency-a`，则在子模块中显式声明：

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.example</groupId>
        <artifactId>parent-project</artifactId>
        <version>1.0.0</version>
    </parent>
    <artifactId>child-project</artifactId>
    <version>1.0.0</version>

    <dependencies>
        <dependency>
            <groupId>com.example</groupId>
            <artifactId>dependency-a</artifactId>
        </dependency>
    </dependencies>
</project>
```

如果子模块不需要 `dependency-a`，则不添加此依赖。

### 方法二：在子模块中排除继承的依赖

如果父 POM 直接添加了依赖，而子模块不需要，可以在子模块中通过 `exclusion` 元素来排除该依赖。

#### 父 POM 示例：

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>parent-project</artifactId>
    <version>1.0.0</version>
    <packaging>pom</packaging>

    <dependencies>
        <dependency>
            <groupId>com.example</groupId>
            <artifactId>dependency-a</artifactId>
            <version>1.0.0</version>
        </dependency>
    </dependencies>
</project>
```

#### 子模块示例：

通过 `dependencyManagement` 和 `exclusion` 元素来排除不需要的依赖：

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.example</groupId>
        <artifactId>parent-project</artifactId>
        <version>1.0.0</version>
    </parent>
    <artifactId>child-project</artifactId>
    <version>1.0.0</version>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>com.example</groupId>
                <artifactId>dependency-a</artifactId>
                <exclusions>
                    <exclusion>
                        <groupId>com.example</groupId>
                        <artifactId>dependency-a</artifactId>
                    </exclusion>
                </exclusions>
            </dependency>
        </dependencies>
    </dependencyManagement>
</project>
```

通过这种方法，子模块可以排除继承的依赖，而不影响父 POM 中的其他配置。这两种方法都可以有效地解决子模块不需要父 POM 中某些依赖的问题。

# 3. aop拦截某个注解A，现在注解A被编写在另外一个组合注解B中，作为B注解上的一个注解，这时候aop可以直接拦截注解A吗？
在 Spring AOP 中，可以拦截特定的注解，但是当该注解被作为元注解（即组合注解的一部分）时，默认的 AOP 拦截机制可能无法直接识别和拦截这个元注解。

为了实现拦截组合注解中包含的特定注解，可以使用以下几种方法：

### 方法一：自定义注解拦截器
编写一个自定义注解拦截器，通过反射来检查目标方法或类上是否存在组合注解，并检查组合注解中是否包含目标注解。

### 方法二：使用 AspectJ
使用 AspectJ 语言风格的切点表达式，可以更加灵活地匹配和拦截元注解。

### 具体实现方法

#### 方法一：自定义注解拦截器
1. 定义注解 `A` 和组合注解 `B`：

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface A {
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface B {
    A value() default @A;
}
```

2. 定义一个 Aspect，使用反射检查注解：

```java
@Aspect
@Component
public class CustomAnnotationAspect {

    @Pointcut("@annotation(com.example.A)")
    public void annotationPointcut() {
    }

    @Around("annotationPointcut()")
    public Object aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable {
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();

        // 检查方法上是否有注解 A
        if (method.isAnnotationPresent(A.class)) {
            return joinPoint.proceed();
        }

        // 检查方法上是否有注解 B 且 B 中包含注解 A
        if (method.isAnnotationPresent(B.class)) {
            B bAnnotation = method.getAnnotation(B.class);
            if (bAnnotation.value().annotationType().equals(A.class)) {
                return joinPoint.proceed();
            }
        }

        return joinPoint.proceed();
    }
}
```

#### 方法二：使用 AspectJ 语言风格
1. 定义注解 `A` 和组合注解 `B`：

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface A {
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface B {
    A value() default @A;
}
```

2. 使用 AspectJ 语言风格定义切点：

```java
@Aspect
@Component
public class CustomAnnotationAspect {

    @Pointcut("execution(@com.example.B * *(..)) || execution(@com.example.A * *(..))")
    public void annotationPointcut() {
    }

    @Around("annotationPointcut()")
    public Object aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable {
        return joinPoint.proceed();
    }
}
```

### 示例
假设有一个服务类使用了组合注解 `B`：

```java
@Service
public class MyService {

    @B
    public void myMethod() {
        System.out.println("Executing myMethod");
    }
}
```

当调用 `myMethod` 时，`CustomAnnotationAspect` 中的 `aroundAdvice` 方法会被触发。

通过这些方法，可以拦截组合注解中包含的特定注解，确保 AOP 切面正确地应用到包含目标注解的组合注解上。

# 4. the name or value arrtibute of @ConditionalOnProperty must be specified，这个错误是什么意思？
这个错误消息 `the name or value attribute of @ConditionalOnProperty must be specified` 表示在使用 `@ConditionalOnProperty` 注解时，必须指定 `name` 或 `value` 属性中的至少一个。这两个属性用于定义需要检查的属性名称。

`@ConditionalOnProperty` 注解用于基于 Spring Environment 中的某个属性是否存在或者是否具有特定值来决定是否创建一个 Spring Bean。这个注解通常用于条件化配置。

### `@ConditionalOnProperty` 注解

- `name` 或 `value`：需要检查的属性名称。
- `prefix`：属性名称的前缀。
- `havingValue`：期望属性的值，默认为空。如果属性值等于这个值，则条件匹配。
- `matchIfMissing`：如果属性不存在，是否应该匹配。默认为 `false`。

### 示例

#### 正确使用示例
以下是一个正确使用 `@ConditionalOnProperty` 注解的示例：

```java
@Configuration
public class MyConfiguration {

    @Bean
    @ConditionalOnProperty(name = "my.feature.enabled", havingValue = "true", matchIfMissing = true)
    public MyService myService() {
        return new MyService();
    }
}
```

在上面的示例中，`@ConditionalOnProperty` 检查属性 `my.feature.enabled` 是否存在并且其值是否为 `true`，或者属性不存在（因为 `matchIfMissing` 为 `true`）。

#### 常见错误示例
以下是一个会导致该错误的示例：

```java
@Configuration
public class MyConfiguration {

    @Bean
    @ConditionalOnProperty(havingValue = "true")
    public MyService myService() {
        return new MyService();
    }
}
```

在这个示例中，`name` 或 `value` 属性未被指定，因此会导致错误。

### 解决方法
确保在使用 `@ConditionalOnProperty` 注解时，始终指定 `name` 或 `value` 属性。例如：

```java
@Configuration
public class MyConfiguration {

    @Bean
    @ConditionalOnProperty(name = "my.feature.enabled", havingValue = "true", matchIfMissing = true)
    public MyService myService() {
        return new MyService();
    }
}
```

或者使用 `value` 属性：

```java
@Configuration
public class MyConfiguration {

    @Bean
    @ConditionalOnProperty(value = "my.feature.enabled", havingValue = "true", matchIfMissing = true)
    public MyService myService() {
        return new MyService();
    }
}
```

通过确保正确指定 `name` 或 `value` 属性，可以解决这个错误并使 `@ConditionalOnProperty` 注解正常工作。

# 5. RequestMappingInfo中的patternsCondition是什么意思？
`RequestMappingInfo` 是 Spring Framework 中用于描述请求映射的一个类，它包含了有关处理器方法的各种请求条件（例如 URL 模式、HTTP 方法、参数、头信息、生产和消费的媒体类型等）。

其中，`patternsCondition` 是 `RequestMappingInfo` 中的一个属性，它表示该请求映射所匹配的 URL 模式。`patternsCondition` 是 `PatternsRequestCondition` 类型的对象，用于保存和处理与请求路径模式相关的条件。

### `PatternsRequestCondition`
`PatternsRequestCondition` 是一个包含 URL 模式的条件类，它决定了哪些请求路径能够匹配某个处理器方法。这个类提供了 URL 模式匹配的逻辑，包括模糊匹配和精确匹配。

### 主要方法
以下是一些 `PatternsRequestCondition` 类的主要方法：

- `getPatterns()`: 返回该条件下所有的 URL 模式。
- `getMatchingCondition(HttpServletRequest request)`: 返回与给定请求匹配的条件，如果没有匹配则返回 null。
- `combine(PatternsRequestCondition other)`: 将当前条件与另一个条件组合。
- `compareTo(PatternsRequestCondition other, HttpServletRequest request)`: 比较两个条件的优先级。

### 示例
假设我们有一个控制器方法，使用 `@RequestMapping` 注解来映射请求路径：

```java
@RestController
public class MyController {

    @RequestMapping("/hello")
    public String hello() {
        return "Hello, World!";
    }
}
```

在这个例子中，`/hello` 就是这个映射的 URL 模式，它会被包含在 `RequestMappingInfo` 的 `patternsCondition` 中。

### 访问 `patternsCondition`
当你需要在程序中访问和处理 `patternsCondition` 时，你可以通过以下方式获取 `RequestMappingInfo` 并访问其 `patternsCondition` 属性：

```java
import org.springframework.web.servlet.mvc.method.RequestMappingInfo;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;
import org.springframework.beans.factory.annotation.Autowired;

public class MyClass {

    @Autowired
    private RequestMappingHandlerMapping requestMappingHandlerMapping;

    public void printRequestMappings() {
        Map<RequestMappingInfo, HandlerMethod> map = requestMappingHandlerMapping.getHandlerMethods();
        for (Map.Entry<RequestMappingInfo, HandlerMethod> entry : map.entrySet()) {
            RequestMappingInfo info = entry.getKey();
            HandlerMethod method = entry.getValue();
            
            Set<String> patterns = info.getPatternsCondition().getPatterns();
            System.out.println("Patterns: " + patterns);
            System.out.println("Handler Method: " + method);
        }
    }
}
```

### 总结
`patternsCondition` 是 `RequestMappingInfo` 的一个属性，用于存储和处理与请求路径模式相关的条件。在 Spring MVC 中，它帮助确定哪些请求路径能够映射到哪个处理器方法，从而实现请求的正确路由和处理。

# 6. 我获取到getPatternsCondition是null是什么原因呢？
获取到 `getPatternsCondition()` 返回 `null` 的原因可能有以下几种：

1. **Spring 版本**：在 Spring 5.x 中，`patternsCondition` 属性被重命名为 `pathPatternsCondition`，并且引入了 `PathPatternsRequestCondition` 用于替代旧的 `PatternsRequestCondition`。如果你使用的是 Spring 5.x 及以上版本，需要使用 `getPathPatternsCondition()` 方法。

2. **配置错误**：在某些配置中，可能没有正确配置请求映射条件，从而导致 `patternsCondition` 为 `null`。

3. **方法签名问题**：在某些情况下，如果方法签名不正确，Spring 可能无法正确解析请求映射条件。

### 检查 Spring 版本
首先，确认你的 Spring 版本：

- 如果是 Spring 5.x 及以上版本，使用 `getPathPatternsCondition()` 方法。
- 如果是 Spring 4.x 或更低版本，继续使用 `getPatternsCondition()` 方法。

### 示例代码
以下是如何根据不同 Spring 版本获取请求模式的示例代码：

#### Spring 5.x 及以上版本
```java
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.servlet.mvc.method.RequestMappingInfo;
import org.springframework.web.method.HandlerMethod;

import java.util.Map;
import java.util.Set;

public class MyClass {

    @Autowired
    private RequestMappingHandlerMapping requestMappingHandlerMapping;

    public void printRequestMappings() {
        Map<RequestMappingInfo, HandlerMethod> map = requestMappingHandlerMapping.getHandlerMethods();
        for (Map.Entry<RequestMappingInfo, HandlerMethod> entry : map.entrySet()) {
            RequestMappingInfo info = entry.getKey();
            HandlerMethod method = entry.getValue();

            // For Spring 5.x and above
            if (info.getPathPatternsCondition() != null) {
                Set<String> patterns = info.getPathPatternsCondition().getPatternValues();
                System.out.println("Patterns: " + patterns);
            } else if (info.getPatternsCondition() != null) {
                // Fallback to old method for compatibility
                Set<String> patterns = info.getPatternsCondition().getPatterns();
                System.out.println("Patterns: " + patterns);
            }

            System.out.println("Handler Method: " + method);
        }
    }
}
```

#### Spring 4.x 或更低版本
```java
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.servlet.mvc.method.RequestMappingInfo;
import org.springframework.web.method.HandlerMethod;

import java.util.Map;
import java.util.Set;

public class MyClass {

    @Autowired
    private RequestMappingHandlerMapping requestMappingHandlerMapping;

    public void printRequestMappings() {
        Map<RequestMappingInfo, HandlerMethod> map = requestMappingHandlerMapping.getHandlerMethods();
        for (Map.Entry<RequestMappingInfo, HandlerMethod> entry : map.entrySet()) {
            RequestMappingInfo info = entry.getKey();
            HandlerMethod method = entry.getValue();

            // For Spring 4.x and below
            if (info.getPatternsCondition() != null) {
                Set<String> patterns = info.getPatternsCondition().getPatterns();
                System.out.println("Patterns: " + patterns);
            }

            System.out.println("Handler Method: " + method);
        }
    }
}
```

### 检查配置
确保你的 Spring 配置中正确设置了请求映射。例如，在控制器类中正确使用了 `@RequestMapping` 注解。

```java
@RestController
public class MyController {

    @RequestMapping("/hello")
    public String hello() {
        return "Hello, World!";
    }
}
```

### 确认方法签名
确保你的方法签名正确，并且控制器类正确加载到 Spring 上下文中。可以通过以下方式进行验证：

```java
@RestController
public class MyController {

    @RequestMapping("/hello")
    public String hello() {
        return "Hello, World!";
    }
}
```

通过以上检查和调整，可以有效解决 `getPatternsCondition()` 返回 `null` 的问题。

# 7. PathPatternsCondition有值，但是PatternsCondition没有值
在 Spring 5.3 及以上版本中，引入了 `PathPatterns` 以替代传统的 `AntPathMatcher`，为请求路径模式匹配提供更高效的解决方案。这两个机制是互斥的，当你启用了 `PathPatterns` 时，`PatternsCondition` 将不会被设置，而是使用 `PathPatternsCondition`。

### 解决方案

如果 `PathPatternsCondition` 有值，而 `PatternsCondition` 没有值，这意味着你当前项目配置使用了新的路径匹配模式。你可以直接使用 `PathPatternsCondition` 来获取 URL 模式。

以下是一个示例代码，展示如何处理 `PathPatternsCondition` 和 `PatternsCondition`：

```java
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.servlet.mvc.method.RequestMappingInfo;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.mvc.condition.PathPatternsRequestCondition;

import java.util.Map;
import java.util.Set;

public class MyClass {

    @Autowired
    private RequestMappingHandlerMapping requestMappingHandlerMapping;

    public void printRequestMappings() {
        Map<RequestMappingInfo, HandlerMethod> map = requestMappingHandlerMapping.getHandlerMethods();
        for (Map.Entry<RequestMappingInfo, HandlerMethod> entry : map.entrySet()) {
            RequestMappingInfo info = entry.getKey();
            HandlerMethod method = entry.getValue();

            // Check for PathPatternsCondition first (new mechanism)
            PathPatternsRequestCondition pathPatternsCondition = info.getPathPatternsCondition();
            if (pathPatternsCondition != null) {
                Set<String> patterns = pathPatternsCondition.getPatternValues();
                System.out.println("Patterns: " + patterns);
            } else if (info.getPatternsCondition() != null) {
                // Fallback to old PatternsCondition (old mechanism)
                Set<String> patterns = info.getPatternsCondition().getPatterns();
                System.out.println("Patterns: " + patterns);
            }

            System.out.println("Handler Method: " + method);
        }
    }
}
```

### 配置 Spring Boot 使用新的路径匹配模式

如果你需要配置 Spring Boot 使用新的路径匹配模式，可以在 `application.properties` 或 `application.yml` 文件中设置：

```properties
spring.mvc.pathmatch.matching-strategy=path-pattern-parser
```

或者在 `application.yml` 中：

```yaml
spring:
  mvc:
    pathmatch:
      matching-strategy: path-pattern-parser
```

### 检查 `PathPatternsRequestCondition`

`PathPatternsRequestCondition` 提供了新路径匹配机制的相关信息。你可以通过以下方法访问和使用这些信息：

```java
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.servlet.mvc.method.RequestMappingInfo;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.mvc.condition.PathPatternsRequestCondition;

import java.util.Map;
import java.util.Set;

public class MyClass {

    @Autowired
    private RequestMappingHandlerMapping requestMappingHandlerMapping;

    public void printRequestMappings() {
        Map<RequestMappingInfo, HandlerMethod> map = requestMappingHandlerMapping.getHandlerMethods();
        for (Map.Entry<RequestMappingInfo, HandlerMethod> entry : map.entrySet()) {
            RequestMappingInfo info = entry.getKey();
            HandlerMethod method = entry.getValue();

            PathPatternsRequestCondition pathPatternsCondition = info.getPathPatternsCondition();
            if (pathPatternsCondition != null) {
                Set<String> patterns = pathPatternsCondition.getPatternValues();
                System.out.println("Patterns: " + patterns);
            } else if (info.getPatternsCondition() != null) {
                Set<String> patterns = info.getPatternsCondition().getPatterns();
                System.out.println("Patterns: " + patterns);
            }

            System.out.println("Handler Method: " + method);
        }
    }
}
```

通过这种方式，你可以正确地处理和获取请求映射信息，无论项目中使用的是旧的 `PatternsCondition` 还是新的 `PathPatternsCondition`。

# 8. 那老的配置是什么？
在 Spring 5.3 之前的版本中，路径匹配机制依赖于 `AntPathMatcher`，并且使用的是 `PatternsCondition` 来保存和处理 URL 模式。这种情况下，你会使用 `getPatternsCondition()` 来获取 URL 模式。

### 示例代码

如果你使用的是 Spring 5.3 之前的版本，以下代码示例展示了如何获取 `PatternsCondition`：

```java
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.servlet.mvc.method.RequestMappingInfo;
import org.springframework.web.method.HandlerMethod;

import java.util.Map;
import java.util.Set;

public class MyClass {

    @Autowired
    private RequestMappingHandlerMapping requestMappingHandlerMapping;

    public void printRequestMappings() {
        Map<RequestMappingInfo, HandlerMethod> map = requestMappingHandlerMapping.getHandlerMethods();
        for (Map.Entry<RequestMappingInfo, HandlerMethod> entry : map.entrySet()) {
            RequestMappingInfo info = entry.getKey();
            HandlerMethod method = entry.getValue();

            if (info.getPatternsCondition() != null) {
                Set<String> patterns = info.getPatternsCondition().getPatterns();
                System.out.println("Patterns: " + patterns);
            }

            System.out.println("Handler Method: " + method);
        }
    }
}
```

### 配置 Spring Boot 使用旧的路径匹配机制

如果你需要在 Spring 5.3 及以上版本中继续使用旧的路径匹配机制，可以在 `application.properties` 或 `application.yml` 文件中配置 `spring.mvc.pathmatch.matching-strategy` 为 `ant-path-matcher`：

```properties
spring.mvc.pathmatch.matching-strategy=ant-path-matcher
```

或者在 `application.yml` 中：

```yaml
spring:
  mvc:
    pathmatch:
      matching-strategy: ant-path-matcher
```

### 检查 `PatternsCondition`

如果你使用的是旧的路径匹配机制 (`AntPathMatcher`)，可以通过以下方法获取 `PatternsCondition`：

```java
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.servlet.mvc.method.RequestMappingInfo;
import org.springframework.web.method.HandlerMethod;

import java.util.Map;
import java.util.Set;

public class MyClass {

    @Autowired
    private RequestMappingHandlerMapping requestMappingHandlerMapping;

    public void printRequestMappings() {
        Map<RequestMappingInfo, HandlerMethod> map = requestMappingHandlerMapping.getHandlerMethods();
        for (Map.Entry<RequestMappingInfo, HandlerMethod> entry : map.entrySet()) {
            RequestMappingInfo info = entry.getKey();
            HandlerMethod method = entry.getValue();

            if (info.getPatternsCondition() != null) {
                Set<String> patterns = info.getPatternsCondition().getPatterns();
                System.out.println("Patterns: " + patterns);
            }

            System.out.println("Handler Method: " + method);
        }
    }
}
```

### 总结

在 Spring 5.3 之前的版本中，路径匹配机制依赖于 `AntPathMatcher`，并使用 `PatternsCondition` 来处理 URL 模式。你可以通过 `getPatternsCondition()` 方法来获取请求路径模式。如果你在使用 Spring 5.3 及以上版本并希望继续使用旧的路径匹配机制，可以通过配置 `spring.mvc.pathmatch.matching-strategy=ant-path-matcher` 来实现。
