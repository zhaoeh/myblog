---
layout:     post
title:      java日志脱敏
subtitle:   java中如何处理脱敏？
categories: [gpt]
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---

# 1. mybatis中sql语句打印log时，sql的参数中包含敏感字段，该如何处理呢？
处理含有敏感字段的 SQL 参数打印到日志中时，你可以采取以下几种方法来保护敏感信息：

1. **使用占位符：** 在 SQL 语句中使用占位符 `?` 来代替具体的参数值。这样在日志中打印的 SQL 语句中，参数值会被隐藏。这种方式也能有效防止 SQL 注入攻击。

   ```java
   String sql = "SELECT * FROM users WHERE username = ? AND password = ?";
   ```

2. **自定义日志输出格式：** 可以通过自定义 MyBatis 的日志输出格式来处理敏感信息，例如，在配置文件中设置合适的日志格式或者通过自定义日志实现类来处理。

3. **过滤敏感信息：** 在日志输出之前，对含有敏感信息的参数进行处理，例如用特定的字符代替敏感信息，或者在日志输出前移除敏感字段。

4. **使用日志脱敏工具：** 有一些专门用于日志中敏感信息脱敏的工具，可以自动检测并脱敏敏感字段，避免敏感信息泄露。

这些方法可以根据你的需求和实际情况来选择和使用。


# 2. 我这个是mybatis自带的sql语句和参数打印日志
MyBatis 的 SQL 语句和参数打印日志可以通过配置来控制是否打印参数信息，从而避免敏感信息在日志中暴露。具体可以参考以下步骤：

1. **在日志配置文件中关闭参数打印：** 可以在 MyBatis 的日志配置文件（如 `log4j.xml`、`logback.xml` 等）中，通过配置来关闭参数打印。这样就可以避免敏感信息被打印到日志中。

   例如，在 Log4j 中关闭参数打印的配置如下：

   ```xml
   <logger name="org.apache.ibatis" level="DEBUG">
       <appender-ref ref="console"/>
   </logger>
   ```

   这里将 MyBatis 的日志级别设置为 DEBUG，可以打印 SQL 语句但不打印参数信息。你可以根据需要将日志级别调整为适合的级别。

2. **使用自定义日志处理器：** 如果需要更精细地控制日志输出，可以实现自定义的日志处理器。你可以继承 MyBatis 的日志处理器，然后在新的处理器中控制参数信息的打印。

   下面是一个简单的示例，假设你使用 Log4j，可以自定义一个继承自 Log4j 的日志处理器，然后在其中控制参数信息的打印：

   ```java
   import org.apache.ibatis.logging.Log;
   import org.apache.ibatis.logging.LogFactory;
   import org.apache.ibatis.logging.log4j.Log4jImpl;

   public class CustomLog4jImpl extends Log4jImpl {
       private static final Log logger = LogFactory.getLog(CustomLog4jImpl.class);

       @Override
       public void debug(String message) {
           // 控制是否打印参数信息
           if (!message.startsWith("Parameters: ")) {
               logger.debug(message);
           }
       }
   }
   ```

   然后在 MyBatis 的配置文件中，指定使用这个自定义的日志处理器：

   ```xml
   <settings>
       <setting name="logImpl" value="com.example.CustomLog4jImpl"/>
   </settings>
   ```

   这样就可以在自定义的日志处理器中控制参数信息的打印，可以根据实际需求灵活调整。

通过以上方法，你可以根据具体情况选择关闭参数打印或者自定义处理器来控制参数信息的打印，从而保护敏感信息不被暴露在日志中。

# 3. 如果我只想修改某一个sql执行时候不打印日志，其他的sql执行时日志还是正常打印，这个该如何处理？
针对只想修改某个特定的 SQL 执行时不打印日志，而其他 SQL 执行时正常打印日志的情况，可以通过 MyBatis 的自定义日志处理器来实现。你可以在自定义日志处理器中针对特定的 SQL 进行处理，不打印日志。

以下是一个示例，假设你使用 Log4j，需要自定义一个继承自 Log4j 的日志处理器，然后在其中控制特定 SQL 不打印日志：

```java
import org.apache.ibatis.logging.Log;
import org.apache.ibatis.logging.LogFactory;
import org.apache.ibatis.logging.log4j.Log4jImpl;
import org.apache.ibatis.mapping.MappedStatement;

public class CustomLog4jImpl extends Log4jImpl {
    private static final Log logger = LogFactory.getLog(CustomLog4jImpl.class);

    @Override
    public void debug(String message) {
        // 控制特定 SQL 不打印日志
        if (!skipLogging(message)) {
            logger.debug(message);
        }
    }

    private boolean skipLogging(String message) {
        // 在这里判断是否是特定 SQL 的日志消息
        // 这里假设要跳过的 SQL 为 SELECT * FROM users WHERE id = 1
        return message.contains("SELECT * FROM users WHERE id = 1");
    }
}
```

然后在 MyBatis 的配置文件中，指定使用这个自定义的日志处理器：

```xml


```xml


```xml


```xml


```xml


```xml


```xml


```xml


```xml


```xml


```xml


```xml


```xml


```xml


```xml


```xml


```xml
```

在 MyBatis 的配置文件中，指定使用这个自定义的日志处理器：

```xml


```xml


```xml
```

在 MyBatis 的配置文件中，指定使用这个自定义的日志处理器：

```xml


```xml
```

在 MyBatis 的配置文件中，指定使用这个自定义的日志处理器：

```xml
```

这样就可以实现只有特定 SQL 执行时不打印日志，其他 SQL 执行时正常打印日志的效果。

# 4. 关闭mybatis在执行某一个sql语句时不输出sql日志参数
如果你想要关闭 MyBatis 在执行某一个特定的 SQL 语句时不输出 SQL 日志参数，可以使用 MyBatis 的拦截器（Interceptor）来实现。具体步骤如下：

1. 创建一个实现了 MyBatis 拦截器接口的自定义拦截器类，重写 `intercept` 方法，在这个方法中可以判断要执行的 SQL 语句是否是需要关闭日志的 SQL，如果是，则不输出参数日志；否则，正常输出参数日志。

2. 在 MyBatis 的配置文件中配置自定义拦截器，将其应用到要关闭日志的 SQL 语句上。

以下是一个简单的示例代码：

```java
import org.apache.ibatis.executor.Executor;
import org.apache.ibatis.mapping.MappedStatement;
import org.apache.ibatis.plugin.*;

import java.util.Properties;

@Intercepts({
        @Signature(type = Executor.class, method = "update", args = {MappedStatement.class, Object.class})
})
public class MyCustomInterceptor implements Interceptor {

    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        // 获取要执行的 SQL 语句
        MappedStatement mappedStatement = (MappedStatement) invocation.getArgs()[0];
        String sqlId = mappedStatement.getId();

        // 判断是否是要关闭日志的 SQL 语句
        if ("your.namespace.yourSqlId".equals(sqlId)) {
            // 不输出参数日志
            return invocation.proceed();
        }

        // 输出参数日志
        System.out.println("Executing SQL: " + mappedStatement.getBoundSql(invocation.getArgs()[1]).getSql());

        return invocation.proceed();
    }

    @Override
    public Object plugin(Object target) {
        return Plugin.wrap(target, this);
    }

    @Override
    public void setProperties(Properties properties) {
        // 可以在这里配置一些属性
    }
}
```

在上面的代码中：

- `@Intercepts` 注解标注了拦截器要拦截的方法，这里拦截了 Executor 的 update 方法，用于处理更新操作的 SQL。
- `intercept` 方法中，通过获取 SQL 的 ID 来判断是否是要关闭日志的 SQL，如果是，则直接调用 `invocation.proceed()` 继续执行 SQL；否则，输出参数日志并执行 SQL。
- 在 MyBatis 的配置文件中配置该自定义拦截器：

```xml


```xml


```xml
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">


```xml
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
```

在 MyBatis 的配置文件中，将自定义拦截器配置到 `<plugins>` 中：

```xml


```xml


```xml
```

```xml


```xml
```

```xml


```xml
```

```xml


```xml
```

```xml
```

在 MyBatis 的配置文件中，将自定义拦截器配置到 `<plugins>` 中：

```xml


```xml
```

```xml
<mappers>
    <!-- 配置 MyBatis 的 Mapper 接口 -->
</mappers>

```

这样就可以在配置中指定了特定的 SQL 语句不输出日志参数。注意替换示例代码中的 `your.namespace.yourSqlId` 为实际的 SQL 命名空间和 SQL ID。

# 5. 关闭mybatis在执行某个特定sql时的日志打印？
你可以通过配置 MyBatis 的日志级别来控制是否打印某个特定 SQL 的日志。在 MyBatis 的配置文件中，可以设置日志的级别为 DEBUG、INFO、WARN、ERROR 或 TRACE，你可以根据需要选择合适的级别。

如果你只想关闭某个特定 SQL 的日志打印，可以考虑以下方法：

1. **使用日志过滤器：** 在配置日志的地方，有些日志框架支持通过配置日志过滤器来过滤某些特定的日志消息。你可以查阅你所使用的日志框架的文档，了解如何配置日志过滤器，并针对特定的 SQL 进行过滤。

2. **自定义日志打印处理：** 可以编写一个自定义的日志打印处理器，在处理器中判断日志的内容，当日志内容匹配某个特定的 SQL 时，不进行打印操作。这种方法需要对日志框架的扩展性有一定的了解。

3. **动态调整日志级别：** 在需要执行特定 SQL 的时候，临时将日志级别调整为高级别（如 ERROR），执行完后再调整回原来的级别。这种方法可以在代码中实现，但需要考虑线程安全和性能开销。

你可以选择适合你项目需求和技术栈的方法来关闭特定 SQL 的日志打印。

# 6. 第2点如何实现呢？
要实现自定义日志打印处理器来过滤特定 SQL 的日志打印，你可以按照以下步骤进行：

1. **创建自定义日志处理器类：** 首先，你需要创建一个实现了日志框架对应接口或抽象类的自定义类，用于处理日志打印的逻辑。例如，如果你使用的是 SLF4J，可以创建一个实现 `org.slf4j.Logger` 接口的类。

2. **编写日志过滤逻辑：** 在自定义日志处理器类中，编写过滤逻辑，判断日志消息中是否包含特定的 SQL，如果包含则不进行打印操作，否则调用日志框架的打印方法进行打印。

3. **配置日志框架使用自定义处理器：** 在你的项目中，配置日志框架使用你所编写的自定义日志处理器类，替代默认的日志处理器。这通常需要在日志框架的配置文件中进行配置。

这里是一个简单的示例，假设你使用的是 SLF4J 日志框架：

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class CustomLogger implements Logger {
    private Logger logger;

    public CustomLogger(String name) {
        this.logger = LoggerFactory.getLogger(name);
    }

    @Override
    public void debug(String msg) {
        if (!shouldIgnore(msg)) {
            logger.debug(msg);
        }
    }

    // 实现其他日志级别的方法，如info、warn、error等

    private boolean shouldIgnore(String msg) {
        // 判断是否包含特定SQL的逻辑，如果包含返回true，否则返回false
        return msg.contains("特定SQL");
    }

    // 实现Logger接口中的其他方法
}
```

然后，在你的项目中，使用这个自定义的日志处理器类替代默认的日志处理器。具体如何配置取决于你所使用的日志框架，一般在日志框架的配置文件中进行配置，指定使用你自定义的类。

# 7. springboot默认使用的是什么日志框架呢？
Spring Boot 默认使用的是 SLF4J（Simple Logging Facade for Java）作为日志门面（Facade），而不是具体的日志实现框架。SLF4J 提供了一个简单的日志抽象层，允许应用程序在运行时绑定到不同的日志实现，如 Logback、Log4j2、Java Util Logging（JUL）等。

在 Spring Boot 应用中，默认情况下，如果没有添加其他的日志框架依赖，它会自动使用 Logback 作为日志实现，因为 Spring Boot 的起步依赖中包含了 Logback 的依赖。

如果你想要在 Spring Boot 应用中使用其他的日志实现框架，可以通过 Maven 或 Gradle 将对应的依赖添加到项目中，并排除掉默认的日志实现依赖。例如，如果你想要使用 Log4j2，可以在 `pom.xml`（Maven）或 `build.gradle`（Gradle）中进行配置。


# 8. 我现在想自定义springboot的日志实现
要自定义 Spring Boot 的日志实现，你可以按照以下步骤进行：

1. **添加日志实现框架依赖：** 首先，根据你想要使用的日志实现框架（如 Log4j2、Logback 等），在 Maven 或 Gradle 中添加对应的依赖。同时，需要排除 Spring Boot 默认的日志实现依赖，以避免冲突。

2. **配置日志：** 针对你选择的日志实现框架，配置相应的日志文件、日志级别、输出格式等信息。这些配置通常可以在配置文件（如 log4j2.xml、logback.xml）中完成。

3. **排除 Spring Boot 默认日志依赖：** 在 Maven 或 Gradle 中排除 Spring Boot 默认的日志实现依赖，以确保使用你自定义的日志实现。

下面是一个示例，假设你想要使用 Log4j2 作为 Spring Boot 的日志实现：

在 Maven 的 `pom.xml` 中添加 Log4j2 的依赖，并排除默认的 Logback 依赖：

```xml


```xml
<!-- 添加 Log4j2 依赖 -->


```xml
<!-- 添加 Log4j2 依赖 -->


```xml
<!-- 添加 Log4j2 依赖 -->


```xml
<!-- 添加 Log4j2 依赖 -->


```xml


然后，在 `src/main/resources` 目录下创建 Log4j2 的配置文件 `log4j2.xml`，并配置你的日志输出策略、格式等信息。示例配置如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>


```xml
<?xml version="1.0" encoding="UTF-8"?>


```xml
<?xml version="1.0" encoding="UTF-8"?>
```

在这个配置文件中，你可以根据需要配置日志输出的格式、日志级别、日志文件路径等信息。

最后，在 Spring Boot 的启动类中（通常是带有 `@SpringBootApplication` 注解的类），可以添加 `@PropertySource` 注解来指定 Log4j2 配置文件的位置。示例代码如下：

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.PropertySource;

@SpringBootApplication
@PropertySource("classpath:log4j2.xml") // 指定Log4j2配置文件的位置
public class MyApplication {

    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

通过以上步骤，你就可以自定义 Spring Boot 的日志实现为 Log4j2，并根据需要配置日志输出的方式和格式。

# 9. 如何自定义日志打印格式，统一过滤掉敏感字符的日志打印呢？
要自定义日志打印格式并统一过滤掉敏感字符，你可以使用日志框架提供的功能来实现。以下是一种常见的方法，以 Logback 为例：

1. **创建自定义日志打印格式器：** 首先，你可以创建一个实现了 Logback 的 `LayoutBase` 接口或者继承自 `LayoutBase` 的自定义类，用于定义日志的输出格式。

   ```java
   import ch.qos.logback.classic.PatternLayout;
   import ch.qos.logback.classic.spi.ILoggingEvent;

   public class CustomPatternLayout extends PatternLayout {
       @Override
       public String doLayout(ILoggingEvent event) {
           String originalLog = super.doLayout(event);
           // 在这里对日志进行处理，过滤敏感字符等操作
           String filteredLog = filterSensitiveInfo(originalLog);
           return filteredLog;
       }

       private String filterSensitiveInfo(String originalLog) {
           // 这里可以编写过滤敏感信息的逻辑，比如替换敏感字符为 *
           // 示例：假设敏感字符是 "password"
           return originalLog.replaceAll("password", "********");
       }
   }
   ```

2. **配置 Logback 使用自定义格式器：** 在 Logback 的配置文件（如 `logback.xml`）中配置使用你自定义的日志打印格式器。

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <configuration>
       <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
           <encoder>
               <!-- 使用自定义格式器 -->
               <layout class="com.example.CustomPatternLayout">
                   <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
               </layout>
           </encoder>
       </appender>

       <root level="info">
           <appender-ref ref="STDOUT" />
       </root>
   </configuration>
   ```

在上面的配置中，`com.example.CustomPatternLayout` 是你自定义的日志打印格式器类，通过 `<layout>` 标签指定使用这个自定义格式器，并在其中配置具体的日志格式（`

pattern`）。在 `filterSensitiveInfo` 方法中，你可以根据实际需求编写逻辑来过滤敏感信息，比如将密码字段替换为 `********`。

将这些代码集成到你的项目中，并根据需要修改敏感信息过滤的逻辑，就可以实现自定义日志打印格式并统一过滤掉敏感字符的功能了。

# 10. 在springboot中该如何实现呢？
在 Spring Boot 中实现自定义日志打印格式并统一过滤敏感字符，可以按照以下步骤进行：

1. **创建自定义日志打印格式器：** 首先，创建一个自定义的日志打印格式器类，用于定义日志的输出格式和过滤敏感字符。

   ```java
   import org.springframework.boot.logging.LogLevel;
   import org.springframework.boot.logging.LoggingSystem;
   import org.springframework.stereotype.Component;

   @Component
   public class CustomLogFormat {
       public void configureLogging() {
           LoggingSystem loggingSystem = LoggingSystem.get(getClass().getClassLoader());
           loggingSystem.setLogLevel("com.example", LogLevel.INFO);
           loggingSystem.beforeInitialize();
           loggingSystem.beforeInitialize();
           loggingSystem.beforeInitialize();
           loggingSystem.beforeInitialize();
           loggingSystem.beforeInitialize();
           loggingSystem.beforeInitialize();
           loggingSystem.beforeInitialize();
           loggingSystem.beforeInitialize();
           loggingSystem.beforeInitialize();
           loggingSystem.beforeInitialize();
           loggingSystem.beforeInitialize();
           loggingSystem.beforeInitialize();
       }
   }
   ```

2. **配置日志格式和过滤规则：** 在 `application.properties` 或 `application.yml` 中配置日志格式和过滤规则。

   ```yaml
   logging:
     level:
       com:
         example: INFO
   ```

3. **启用自定义日志配置：** 在 Spring Boot 应用的启动类中，通过 `@EnableConfigurationProperties` 注解引入自定义日志配置类，并调用其方法启用自定义日志配置。

   ```java
   import org.springframework.boot.SpringApplication;
   import org.springframework.boot.autoconfigure.SpringBootApplication;
   import org.springframework.boot.context.properties.EnableConfigurationProperties;

   @SpringBootApplication
   @EnableConfigurationProperties(CustomLogFormat.class)
   public class MyApplication {

       public static void main(String[] args) {
           SpringApplication.run(MyApplication.class, args);
       }
   }
   ```

通过以上步骤，你就可以实现在 Spring Boot 中自定义日志打印格式并统一过滤敏感字符了。在自定义日志打印格式器类中，你可以根据实际需求编写过滤敏感字符的逻辑，例如将密码字段替换为 `********` 或者将敏感信息移除。

# 11. 没看明白
让我们一步步来：

1. **创建自定义日志打印格式器：**

   创建一个类，例如 `CustomLogFormat`，用于配置自定义的日志格式和过滤规则。

   ```java
   import org.springframework.boot.context.properties.ConfigurationProperties;
   import org.springframework.context.annotation.Configuration;

   @Configuration
   @ConfigurationProperties(prefix = "logging")
   public class CustomLogFormat {
       private String level;
       private String pattern;

       public String getLevel() {
           return level;
       }

       public void setLevel(String level) {
           this.level = level;
       }

       public String getPattern() {
           return pattern;
       }

       public void setPattern(String pattern) {
           this.pattern = pattern;
       }
   }
   ```

2. **配置日志格式和过滤规则：**

   在 `application.properties` 或 `application.yml` 中添加日志格式和过滤规则的配置。

   ```yaml
   logging.level.com.example=INFO
   logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n
   ```

3. **启用自定义日志配置：**

   在 Spring Boot 应用的启动类中，通过 `@EnableConfigurationProperties` 注解引入自定义日志配置类，并在 `main` 方法中调用其方法启用自定义日志配置。

   ```java
   import org.springframework.boot.SpringApplication;
   import org.springframework.boot.autoconfigure.SpringBootApplication;
   import org.springframework.boot.context.properties.EnableConfigurationProperties;

   @SpringBootApplication
   @EnableConfigurationProperties(CustomLogFormat.class)
   public class MyApplication {

       public static void main(String[] args) {
           SpringApplication.run(MyApplication.class, args);
       }
   }
   ```

这样，Spring Boot 就会使用你定义的日志格式和过滤规则进行日志打印。在配置中，`logging.level.com.example=INFO` 表示将 `com.example` 包下的日志级别设为 INFO，而 `logging.pattern.console` 则定义了控制台输出的日志格式。

如果需要对日志中的敏感信息进行过滤，可以在 `CustomLogFormat` 类中添加逻辑，在日志输出前对日志内容进行处理，例如将敏感信息替换为 `********`。

# 12. 说一个很全面的具体实现吧？
好的，我们来实现一个具体的、全面的自定义日志打印格式和过滤敏感信息的示例。

首先，我们需要引入 Logback 作为日志实现，因为 Spring Boot 默认使用 Logback。接着，我们将创建一个自定义的日志配置类和一个自定义的日志格式化器来实现我们的需求。

1. **添加 Logback 依赖：**

在 Maven 项目中，需要在 `pom.xml` 文件中添加 Logback 依赖，并排除 Spring Boot 默认的日志依赖。

```xml
<!-- 引入 Logback 依赖 -->


由于我们无法实时编辑文件，请将以下代码片段添加到你的 `pom.xml` 文件中：

```xml


```xml


```xml


```xml
```

2. **创建自定义日志配置类：**

创建一个名为 `CustomLogFormat` 的 Java 类，用于配置自定义的日志格式和过滤规则。

```java
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConfigurationProperties(prefix = "custom.logging")
public class CustomLogFormat {
    private String level;
    private String pattern;
    private String sensitiveDataRegex;

    public String getLevel() {
        return level;
    }

    public void setLevel(String level) {
        this.level = level;
    }

    public String getPattern() {
        return pattern;
    }

    public void setPattern(String pattern) {
        this.pattern = pattern;
    }

    public String getSensitiveDataRegex() {
        return sensitiveDataRegex;
    }

    public void setSensitiveDataRegex(String sensitiveDataRegex) {
        this.sensitiveDataRegex = sensitiveDataRegex;
    }
}
```

3. **配置日志格式和过滤规则：**

在 `application.properties` 或 `application.yml` 中添加自定义日志配置。

```yaml
custom.logging.level=INFO
custom.logging.pattern=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n
custom.logging.sensitiveDataRegex=(?i)password|token|secret
```

在上面的配置中，我们定义了日志级别为 INFO，日志格式为 `%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n`，敏感信息的正则表达式为 `(?i)password|token|secret`，这个正则表达式用于匹配需要过滤的敏感信息。

4. **创建自定义日志格式化器：**

创建一个名为 `CustomLogFormatter` 的 Java 类，用于自定义日志的输出格式和过滤敏感信息。

```java
import ch.qos.logback.classic.PatternLayout;
import ch.qos.logback.classic.spi.ILoggingEvent;

public class CustomLogFormatter extends PatternLayout {
    private String sensitiveDataRegex;

    public void setSensitiveDataRegex(String sensitiveDataRegex) {
        this.sensitiveDataRegex = sensitiveDataRegex;
    }

    @Override
    public String doLayout(ILoggingEvent event) {
        String originalLog = super.doLayout(event);
        return filterSensitiveData(originalLog);
    }

    private String filterSensitiveData(String log) {
        if (sensitiveDataRegex != null && !sensitiveDataRegex.isEmpty()) {
            return log.replaceAll(sensitiveDataRegex, "********");
        }
        return log;
    }
}
```

5. **配置 Logback 使用自定义格式化器：**

在 `logback-spring.xml` 中配置 Logback 使用我们自定义的日志格式化器。

```xml


```xml
<?xml version="1.0" encoding="UTF-8"?>


```xml
<?xml version="1.0" encoding="UTF-8"?>
```

在这个配置文件中，我们配置了一个名为 `CUSTOM_CONSOLE` 的控制台输出 appender，使用了我们自定义的日志格式化器 `CustomLogFormatter`，并且指定了敏感信息的正则表达式为 `${custom.logging.sensitiveDataRegex}`。

6. **启用自定义日志配置：**

在 Spring Boot 应用的启动类中，通过 `@EnableConfigurationProperties` 注解引入自定义日志配置类，并在 `main` 方法中调用其方法启用自定义日志配置。

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;

@SpringBootApplication
@EnableConfigurationProperties(CustomLogFormat.class)
public class MyApplication {

    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

通过以上步骤，我们完成了一个全面的自定义日志打印格式和过滤敏感信息的实现。在这个示例中，我们使用了 Logback 作为日志实现，并且通过自定义配置类、自定义日志格式化器、Logback 的配置文件来实现了我们的需求。

# 13. mybatis中的setLogImpl和日志框架之间是什么关系呢？
在 MyBatis 中，`setLogImpl` 方法用于设置日志实现（Log Implementation），它和日志框架之间存在一定的关系。

1. **`setLogImpl` 方法：**

   `setLogImpl` 是 MyBatis 中的一个方法，用于设置日志实现的具体实例。通过这个方法，你可以指定 MyBatis 使用哪个日志框架来输出日志信息。

2. **日志框架：**

   日志框架是指用于记录和输出应用程序日志的工具或库，例如 Log4j、Logback、SLF4J 等。这些日志框架提供了不同的功能和特性，可以根据项目需求选择合适的日志框架来记录日志信息。

3. **关系：**

   `setLogImpl` 方法和日志框架之间的关系在于，通过调用这个方法并传入相应的日志实现实例，MyBatis 就可以使用指定的日志框架来记录 MyBatis 执行过程中的日志信息。换句话说，`setLogImpl` 方法提供了 MyBatis 和日志框架之间的桥梁，使得 MyBatis 能够与不同的日志框架集成。

例如，如果你想要 MyBatis 使用 Log4j 进行日志记录，可以通过以下方式设置：

```java
import org.apache.ibatis.logging.LogFactory;
import org.apache.ibatis.logging.log4j.Log4jImpl;

public class MyBatisConfig {
    public static void main(String[] args) {
        // 设置日志实现为 Log4jImpl
        LogFactory.useLog4JLogging();
    }
}
```

在这个示例中，我们调用了 `LogFactory.useLog4JLogging()` 方法来设置 MyBatis 使用 Log4j 作为日志实现。这样，在 MyBatis 执行过程中产生的日志信息就会使用 Log4j 进行记录和输出。
