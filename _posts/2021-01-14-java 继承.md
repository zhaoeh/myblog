---
layout:     post
title:      java 继承
subtitle:   继承、单继承、多继承
date:       2021-01-14
author:     zhaoeh
header-img: img/post-bg-2015.jpg
catalog: true
tags:
    - Java基础知识
---

# 1. 继承
<font color="#FF0000">  
 默认分情况，私有静态构造不继承。
 </font>
 
 注意：
 1.  父类中除了构造方法、私有成员、静态成员不能被子类继承，其他的任何东西都能够被子类继承。  
 2.  private成员尽管能被继承，但是不能被访问，因为它的访问权限是private的。能访问就能覆盖。因此private方法不能被覆盖。因为编译器隐式的将private方法修饰为final的了。  
 3.  default权限的成员可以被继承，但是能不能访问要分情况：如果子类和父类在同一包则子类可以访问，如果不在同一个包则子类不能访问。能访问就能覆盖。对于不同包的父类，编译器隐式的为default方法添加了final修饰；而同包的则没有添加。  
 4.  父类的static成员可以被子类继承，static成员是随着类的加载而最早被JVM加载到方法区内存的静态区的，属于类的静态加载而不随着实例对象去加载，因此static成员不是实例成员，所以不允许覆盖。  
 
 # 2. 单继承
 <font color="#FF0000">  口诀：一个孩子不能有多个亲生父亲 </font>
 
 子类继承父类在Java中只能是单继承而不能是多重继承；单继承即一个子类只能继承一个父类，而不能继承多个父类。  
 但是Java中一个类可以实现多层继承，即C继承B、B再继承A。  
 
 # 3. 多继承
 与单继承相对，即一个子类可以同时继承多个父类。
 <b>Java中，子类实现接口时，可以实现多个接口；  
    接口继承接口时，也可以继承多个接口。</b>  
    
# 4. 继承关系
 <font color="#FF0000">  
 口诀：    
 类与类、接口与接口是继承;类与接口是实现。 
 </font>
 
 1. 继承的关键字是extends；实现的关键字是implements。  
 (1) 类与类之间是继承关系，接口与接口之间是继承关系；用关键字extends去继承；  
 (2) 普通类继承抽象类，必须覆盖抽象类中所有的抽象方法。  
 
 2. 对于类与类之间，类与接口之间，接口与接口之间的继承关系如下：  
 (1) 普通类可以继承普通类；  
 (2) 普通类可以继承抽象类；  
 (3) 抽象类可以继承普通类；  
 (4) 抽象类可以继承抽象类；  
 (5) 普通类可以实现接口；  
 (6) 抽象类可以实现接口；  
 (7) 接口可以继承多个接口。  
 参考：[java继承原理](https://www.cnblogs.com/myseries/p/10973524.html)  
 
# 5. 深入父子类继承
<font color="#FF0000">   
口诀：实例化子类对象之前，如果子类对象存在直接父类，则先实例化父类对象；如果父类继续存在父类，则优先实例化父类的父类对象。以此类推。  
约束：对于父类是接口的，则不会实例化父类对象。  
</font>
 
 1.  继承关系中，对于方法而言，子类可以覆盖父类中的相同方法。  
 2.  继承关系中，对于父类的成员变量，子类是不能覆盖的，如果子类定义了和父类中完全相同的成员变量，那么此时子类将存在两份相同的变量，一份是继承自父类的（私有和静态的肯定不被继承），一份是子类自己的。  
 3.  成员变量没有覆盖一说，成员变量的继承也遵循“默认分情况、私有静态不覆盖、构造方法不继承”的原则，子类若能继承父类的成员变量，并且自身也有相同的变量，那么子类将会存在两个完全相同的两份变量，其中继承自父类的变量存储在父类的堆内存中，自己的成员变量存储在自己的堆内存中。  
 4.  子类中完全相同的两份变量，具体调用的是子类自己的还是继承自父类的，只需要关注调用的对象是子类的引用还是父类的引用。  
 5.  抽象类不能直接被实例化，但抽象类完全具备构造方法，意味着抽象类在作为父类时，是能够被JVM自动实例化的。  