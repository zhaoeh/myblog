---
layout:     post
title:      jackson
subtitle:   jackson是spring体系中默认的json序列化框架
categories: [Json]
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---
    
# 1. jackson简介
Jackson 是一个流行的 Java 序列化和反序列化库，通常用于处理 JSON 数据。关于 Jackson 会不会导致栈内存溢出的问题，一般情况下并不会，因为 Jackson 库本身不会直接导致栈内存溢出。

然而，如果你在使用 Jackson 进行大量的 JSON 数据处理时，可能会遇到内存相关的问题，比如堆内存溢出（Heap Overflow）。这种情况通常是因为 JSON 数据量过大，导致 Java 虚拟机的堆内存不足。

为了避免这种情况，你可以考虑以下几点：

1. **优化 JSON 数据结构：** 尽量减小 JSON 数据的大小，避免不必要的嵌套和重复数据。
2. **分批处理数据：** 如果数据量很大，可以考虑分批处理，减少单次处理的数据量。
3. **增加 JVM 堆内存：** 根据实际情况适当增加 Java 虚拟机的堆内存大小。
4. **使用流式处理：** 如果可能的话，可以考虑使用 Jackson 的流式 API，逐行处理数据，减少整体数据的加载到内存中。

通过这些方法，可以有效地避免由于 JSON 数据处理导致的内存问题。

# 2. jackson API使用总结
Jackson 是一个流行的 Java 序列化和反序列化库，广泛用于处理 JSON 数据。它提供了多种 API 和功能，以满足不同的需求。以下是 Jackson 的详细总结，包括各种 API 的使用和详细案例解释。

### 1. 依赖
首先，在项目中引入 Jackson 相关依赖：

**Maven:**
```xml
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.14.1</version>
</dependency>
```

**Gradle:**
```groovy
implementation 'com.fasterxml.jackson.core:jackson-databind:2.14.1'
```

### 2. 基本用法
Jackson 的核心类是 `ObjectMapper`，它负责序列化和反序列化操作。

#### 2.1 序列化
将 Java 对象转换为 JSON 字符串。
```java
import com.fasterxml.jackson.databind.ObjectMapper;

public class JacksonExample {
    public static void main(String[] args) throws Exception {
        ObjectMapper objectMapper = new ObjectMapper();
        User user = new User("John", "Doe", 30);
        String jsonString = objectMapper.writeValueAsString(user);
        System.out.println(jsonString);
    }
}

class User {
    private String firstName;
    private String lastName;
    private int age;

    // Constructors, getters and setters
    public User(String firstName, String lastName, int age) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
    }

    // Getters and Setters
}
```

#### 2.2 反序列化
将 JSON 字符串转换为 Java 对象。
```java
public class JacksonExample {
    public static void main(String[] args) throws Exception {
        ObjectMapper objectMapper = new ObjectMapper();
        String jsonString = "{\"firstName\":\"John\",\"lastName\":\"Doe\",\"age\":30}";
        User user = objectMapper.readValue(jsonString, User.class);
        System.out.println(user.getFirstName());
    }
}
```

### 3. 注解
Jackson 提供了一系列注解来定制序列化和反序列化的行为。

#### 3.1 @JsonProperty
用于重命名 JSON 属性。
```java
import com.fasterxml.jackson.annotation.JsonProperty;

public class User {
    @JsonProperty("first_name")
    private String firstName;
    
    @JsonProperty("last_name")
    private String lastName;
    
    @JsonProperty("age")
    private int age;

    // Constructors, getters and setters
}
```

#### 3.2 @JsonIgnore
用于忽略某个字段。
```java
import com.fasterxml.jackson.annotation.JsonIgnore;

public class User {
    private String firstName;
    private String lastName;
    
    @JsonIgnore
    private int age;

    // Constructors, getters and setters
}
```

#### 3.3 @JsonInclude
用于指定在序列化时包含哪些字段。
```java
import com.fasterxml.jackson.annotation.JsonInclude;

public class User {
    private String firstName;
    private String lastName;
    
    @JsonInclude(JsonInclude.Include.NON_NULL)
    private Integer age;

    // Constructors, getters and setters
}
```

### 4. 高级用法

#### 4.1 自定义序列化和反序列化
实现自定义的序列化器和反序列化器。

**自定义序列化器:**
```java
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;

import java.io.IOException;

public class UserSerializer extends StdSerializer<User> {
    public UserSerializer() {
        this(null);
    }

    public UserSerializer(Class<User> t) {
        super(t);
    }

    @Override
    public void serialize(User user, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
        jsonGenerator.writeStartObject();
        jsonGenerator.writeStringField("first_name", user.getFirstName());
        jsonGenerator.writeStringField("last_name", user.getLastName());
        jsonGenerator.writeEndObject();
    }
}
```

**自定义反序列化器:**
```java
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonDeserializer;

import java.io.IOException;

public class UserDeserializer extends JsonDeserializer<User> {
    @Override
    public User deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JsonProcessingException {
        JsonNode node = jsonParser.getCodec().readTree(jsonParser);
        String firstName = node.get("first_name").asText();
        String lastName = node.get("last_name").asText();
        return new User(firstName, lastName, 0);
    }
}
```

**注册自定义序列化器和反序列化器:**
```java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;

public class JacksonExample {
    public static void main(String[] args) throws Exception {
        ObjectMapper objectMapper = new ObjectMapper();

        SimpleModule module = new SimpleModule();
        module.addSerializer(User.class, new UserSerializer());
        module.addDeserializer(User.class, new UserDeserializer());
        objectMapper.registerModule(module);

        User user = new User("John", "Doe", 30);
        String jsonString = objectMapper.writeValueAsString(user);
        System.out.println(jsonString);

        User deserializedUser = objectMapper.readValue(jsonString, User.class);
        System.out.println(deserializedUser.getFirstName());
    }
}
```

### 5. 树模型
树模型提供了一种以树结构方式处理 JSON 数据的灵活方式。

#### 5.1 读取 JSON 到树模型
```java
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

public class JacksonExample {
    public static void main(String[] args) throws Exception {
        ObjectMapper objectMapper = new ObjectMapper();
        String jsonString = "{\"firstName\":\"John\",\"lastName\":\"Doe\",\"age\":30}";
        JsonNode rootNode = objectMapper.readTree(jsonString);
        
        String firstName = rootNode.get("firstName").asText();
        System.out.println(firstName);
    }
}
```

#### 5.2 修改树模型并写回 JSON
```java
public class JacksonExample {
    public static void main(String[] args) throws Exception {
        ObjectMapper objectMapper = new ObjectMapper();
        String jsonString = "{\"firstName\":\"John\",\"lastName\":\"Doe\",\"age\":30}";
        JsonNode rootNode = objectMapper.readTree(jsonString);

        ((ObjectNode) rootNode).put("age", 31);

        String modifiedJson = objectMapper.writeValueAsString(rootNode);
        System.out.println(modifiedJson);
    }
}
```

### 6. 流式解析
Jackson 也支持流式解析 JSON 数据，适用于处理大型 JSON 文件或数据流。

#### 6.1 流式读取
```java
import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;

import java.io.File;

public class JacksonExample {
    public static void main(String[] args) throws Exception {
        JsonFactory factory = new JsonFactory();
        JsonParser parser = factory.createParser(new File("user.json"));

        while (!parser.isClosed()) {
            JsonToken token = parser.nextToken();

            if (JsonToken.FIELD_NAME.equals(token)) {
                String fieldName = parser.getCurrentName();
                parser.nextToken();
                if ("firstName".equals(fieldName)) {
                    System.out.println(parser.getValueAsString());
                } else if ("age".equals(fieldName)) {
                    System.out.println(parser.getValueAsInt());
                }
            }
        }
    }
}
```

#### 6.2 流式写入
```java
import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonGenerator;

import java.io.File;

public class JacksonExample {
    public static void main(String[] args) throws Exception {
        JsonFactory factory = new JsonFactory();
        JsonGenerator generator = factory.createGenerator(new File("user.json"), JsonEncoding.UTF8);

        generator.writeStartObject();
        generator.writeStringField("firstName", "John");
        generator.writeStringField("lastName", "Doe");
        generator.writeNumberField("age", 30);
        generator.writeEndObject();

        generator.close();
    }
}
```

### 7. 与其他库的集成
Jackson 可以与其他流行的库集成，如 Spring Boot 和 JAX-RS。

#### 7.1 在 Spring Boot 中使用 Jackson
Spring Boot 默认使用 Jackson 作为 JSON 序列化和反序列化工具。

**Spring Boot 项目配置:**
```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class JacksonExampleApplication {
    public static void main(String[] args) {
        SpringApplication.run(JacksonExampleApplication.class, args);
    }
}
```

**控制器示例:**
```java
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/users")
public class UserController {
    @GetMapping
    public User getUser() {
        return new User("John", "Doe", 30);
    }
}
```

### 8. 

其他功能
Jackson 还支持许多其他功能，如多态类型处理、日期格式化、自定义命名策略等。

#### 8.1 多态类型处理
使用 `@JsonTypeInfo` 注解处理多态类型。
```java
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;

@JsonTypeInfo(
  use = JsonTypeInfo.Id.NAME,
  include = JsonTypeInfo.As.PROPERTY,
  property = "type")
@JsonSubTypes({
  @JsonSubTypes.Type(value = Dog.class, name = "dog"),
  @JsonSubTypes.Type(value = Cat.class, name = "cat")
})
public class Animal {
    public String name;
}

public class Dog extends Animal {
    public int barkVolume;
}

public class Cat extends Animal {
    public int lives;
}
```

#### 8.2 日期格式化
使用 `@JsonFormat` 注解进行日期格式化。
```java
import com.fasterxml.jackson.annotation.JsonFormat;

public class Event {
    private String name;

    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd HH:mm:ss")
    private Date eventDate;

    // Constructors, getters and setters
}
```

#### 8.3 自定义命名策略
使用 `PropertyNamingStrategy` 自定义命名策略。
```java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.PropertyNamingStrategies;

public class JacksonExample {
    public static void main(String[] args) throws Exception {
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setPropertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE);

        User user = new User("John", "Doe", 30);
        String jsonString = objectMapper.writeValueAsString(user);
        System.out.println(jsonString);
    }
}
```

通过以上总结，希望你对 Jackson 的各种 API 使用和功能有了全面的了解。

# 3. ObjectMapper 详解解释
`ObjectMapper` 是 Jackson 中的核心类，用于将 Java 对象与 JSON 数据之间进行序列化和反序列化操作。以下是 `ObjectMapper` 对象的各种使用方式及其详细演示：

### 1. 初始化 `ObjectMapper`
```java
ObjectMapper objectMapper = new ObjectMapper();
```

### 2. 序列化和反序列化
#### 2.1 序列化 (Java 对象到 JSON 字符串)
```java
User user = new User("John", "Doe", 30);
String jsonString = objectMapper.writeValueAsString(user);
System.out.println(jsonString); // {"firstName":"John","lastName":"Doe","age":30}
```

#### 2.2 反序列化 (JSON 字符串到 Java 对象)
```java
String jsonString = "{\"firstName\":\"John\",\"lastName\":\"Doe\",\"age\":30}";
User user = objectMapper.readValue(jsonString, User.class);
System.out.println(user.getFirstName()); // John
```

### 3. 序列化和反序列化到文件
#### 3.1 序列化到文件
```java
objectMapper.writeValue(new File("user.json"), user);
```

#### 3.2 从文件反序列化
```java
User userFromFile = objectMapper.readValue(new File("user.json"), User.class);
System.out.println(userFromFile.getFirstName()); // John
```

### 4. 使用注解进行配置
#### 4.1 @JsonProperty 重命名属性
```java
import com.fasterxml.jackson.annotation.JsonProperty;

public class User {
    @JsonProperty("first_name")
    private String firstName;

    @JsonProperty("last_name")
    private String lastName;

    @JsonProperty("age")
    private int age;

    // Constructors, getters, and setters
}
```

#### 4.2 @JsonIgnore 忽略属性
```java
import com.fasterxml.jackson.annotation.JsonIgnore;

public class User {
    private String firstName;
    private String lastName;

    @JsonIgnore
    private int age;

    // Constructors, getters, and setters
}
```

#### 4.3 @JsonInclude 包含非空属性
```java
import com.fasterxml.jackson.annotation.JsonInclude;

public class User {
    private String firstName;
    private String lastName;

    @JsonInclude(JsonInclude.Include.NON_NULL)
    private Integer age;

    // Constructors, getters, and setters
}
```

### 5. 自定义序列化和反序列化
#### 5.1 自定义序列化器
```java
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;

import java.io.IOException;

public class UserSerializer extends StdSerializer<User> {
    public UserSerializer() {
        this(null);
    }

    public UserSerializer(Class<User> t) {
        super(t);
    }

    @Override
    public void serialize(User user, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
        jsonGenerator.writeStartObject();
        jsonGenerator.writeStringField("first_name", user.getFirstName());
        jsonGenerator.writeStringField("last_name", user.getLastName());
        jsonGenerator.writeEndObject();
    }
}
```

#### 5.2 自定义反序列化器
```java
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonDeserializer;
import com.fasterxml.jackson.databind.JsonNode;

import java.io.IOException;

public class UserDeserializer extends JsonDeserializer<User> {
    @Override
    public User deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JsonProcessingException {
        JsonNode node = jsonParser.getCodec().readTree(jsonParser);
        String firstName = node.get("first_name").asText();
        String lastName = node.get("last_name").asText();
        return new User(firstName, lastName, 0);
    }
}
```

#### 5.3 注册自定义序列化器和反序列化器
```java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;

public class JacksonExample {
    public static void main(String[] args) throws Exception {
        ObjectMapper objectMapper = new ObjectMapper();

        SimpleModule module = new SimpleModule();
        module.addSerializer(User.class, new UserSerializer());
        module.addDeserializer(User.class, new UserDeserializer());
        objectMapper.registerModule(module);

        User user = new User("John", "Doe", 30);
        String jsonString = objectMapper.writeValueAsString(user);
        System.out.println(jsonString); // {"first_name":"John","last_name":"Doe"}

        User deserializedUser = objectMapper.readValue(jsonString, User.class);
        System.out.println(deserializedUser.getFirstName()); // John
    }
}
```

### 6. 树模型
#### 6.1 读取 JSON 到树模型
```java
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

public class JacksonExample {
    public static void main(String[] args) throws Exception {
        ObjectMapper objectMapper = new ObjectMapper();
        String jsonString = "{\"firstName\":\"John\",\"lastName\":\"Doe\",\"age\":30}";
        JsonNode rootNode = objectMapper.readTree(jsonString);

        String firstName = rootNode.get("firstName").asText();
        System.out.println(firstName); // John
    }
}
```

#### 6.2 修改树模型并写回 JSON
```java
import com.fasterxml.jackson.databind.node.ObjectNode;

public class JacksonExample {
    public static void main(String[] args) throws Exception {
        ObjectMapper objectMapper = new ObjectMapper();
        String jsonString = "{\"firstName\":\"John\",\"lastName\":\"Doe\",\"age\":30}";
        JsonNode rootNode = objectMapper.readTree(jsonString);

        ((ObjectNode) rootNode).put("age", 31);

        String modifiedJson = objectMapper.writeValueAsString(rootNode);
        System.out.println(modifiedJson); // {"firstName":"John","lastName":"Doe","age":31}
    }
}
```

### 7. 流式解析
#### 7.1 流式读取
```java
import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;

import java.io.File;

public class JacksonExample {
    public static void main(String[] args) throws Exception {
        JsonFactory factory = new JsonFactory();
        JsonParser parser = factory.createParser(new File("user.json"));

        while (!parser.isClosed()) {
            JsonToken token = parser.nextToken();

            if (JsonToken.FIELD_NAME.equals(token)) {
                String fieldName = parser.getCurrentName();
                parser.nextToken();
                if ("firstName".equals(fieldName)) {
                    System.out.println(parser.getValueAsString()); // John
                } else if ("age".equals(fieldName)) {
                    System.out.println(parser.getValueAsInt()); // 30
                }
            }
        }
    }
}
```

#### 7.2 流式写入
```java
import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonGenerator;

import java.io.File;
import java.io.IOException;

public class JacksonExample {
    public static void main(String[] args) throws IOException {
        JsonFactory factory = new JsonFactory();
        JsonGenerator generator = factory.createGenerator(new File("user.json"), JsonEncoding.UTF8);

        generator.writeStartObject();
        generator.writeStringField("firstName", "John");
        generator.writeStringField("lastName", "Doe");
        generator.writeNumberField("age", 30);
        generator.writeEndObject();

        generator.close();
    }
}
```

### 8. 配置 `ObjectMapper`
#### 8.1 设定配置
```java
ObjectMapper objectMapper = new ObjectMapper();
objectMapper.enable(SerializationFeature.INDENT_OUTPUT); // 美化输出
objectMapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); // 忽略未知属性
```

#### 8.2 自定义命名策略
```java
import com.fasterxml.jackson.databind.PropertyNamingStrategies;

ObjectMapper objectMapper = new ObjectMapper();
objectMapper.setPropertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE);

User user = new User("John", "Doe", 30);
String jsonString = objectMapper.writeValueAsString(user);
System.out.println(jsonString); // {"first_name":"John","last_name":"Doe","age":30}
```

#### 8.3 日期格式化
```java
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.databind.ObjectMapper;

public class Event {
    private String name;

    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd HH:mm:ss")
    private Date eventDate;

    // Constructors, getters, and setters
}

ObjectMapper objectMapper = new ObjectMapper();
Event event = new Event("Conference", new Date());
String jsonString = objectMapper.writeValueAsString(event);
System.out.println(jsonString); // {"name":"Conference","eventDate":"2023-07-16 14:34:56"}
```

### 9. 与其他库的集成
#### 9.1 Spring Boot 集成 Jackson
Spring Boot 默认使用 Jackson 作为 JSON 处理工具。

**控制器示例:**
```java
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/users")
public
```java```

# 3. convertValue 方法
你提到的 `convertValue` 方法确实是 `ObjectMapper` 类中的一个重要方法。除了这个方法外，`ObjectMapper` 还有一些其他有用的方法，可以帮助我们更方便地处理 JSON 数据。以下是 `convertValue` 方法以及其他一些常用方法的总结和详细解释：

### 1. `convertValue` 方法

`convertValue` 方法可以将一个对象转换为另一个类型的对象，而不需要先将其序列化为 JSON 字符串，然后再反序列化。这在需要类型转换时非常有用。

#### 示例
```java
import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.Map;

public class JacksonExample {
    public static void main(String[] args) {
        ObjectMapper objectMapper = new ObjectMapper();

        // 创建一个示例用户对象
        User user = new User("John", "Doe", 30);

        // 将 User 对象转换为 Map 对象
        Map<String, Object> userMap = objectMapper.convertValue(user, Map.class);
        System.out.println(userMap); // {firstName=John, lastName=Doe, age=30}

        // 将 Map 对象转换回 User 对象
        User convertedUser = objectMapper.convertValue(userMap, User.class);
        System.out.println(convertedUser.getFirstName()); // John
    }
}
```

### 2. `updateValue` 方法

`updateValue` 方法可以用来更新一个现有对象的值。这在需要部分更新一个对象的字段时非常有用。

#### 示例
```java
import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.HashMap;
import java.util.Map;

public class JacksonExample {
    public static void main(String[] args) throws Exception {
        ObjectMapper objectMapper = new ObjectMapper();

        User user = new User("John", "Doe", 30);

        // 创建一个包含更新数据的 Map
        Map<String, Object> updates = new HashMap<>();
        updates.put("age", 31);

        // 更新 User 对象
        User updatedUser = objectMapper.updateValue(user, updates);
        System.out.println(updatedUser.getAge()); // 31
    }
}
```

### 3. `readTree` 和 `writeTree` 方法

`readTree` 方法将 JSON 解析为 `JsonNode` 对象，`writeTree` 方法将 `JsonNode` 对象序列化为 JSON。

#### 示例
```java
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

public class JacksonExample {
    public static void main(String[] args) throws Exception {
        ObjectMapper objectMapper = new ObjectMapper();

        String jsonString = "{\"firstName\":\"John\",\"lastName\":\"Doe\",\"age\":30}";

        // 解析 JSON 字符串为 JsonNode 对象
        JsonNode rootNode = objectMapper.readTree(jsonString);
        System.out.println(rootNode.get("firstName").asText()); // John

        // 将 JsonNode 对象序列化为 JSON 字符串
        String jsonOutput = objectMapper.writeTree(rootNode).toString();
        System.out.println(jsonOutput); // {"firstName":"John","lastName":"Doe","age":30}
    }
}
```

### 4. `treeToValue` 和 `valueToTree` 方法

`treeToValue` 方法将 `JsonNode` 转换为 Java 对象，`valueToTree` 方法将 Java 对象转换为 `JsonNode`。

#### 示例
```java
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

public class JacksonExample {
    public static void main(String[] args) throws Exception {
        ObjectMapper objectMapper = new ObjectMapper();

        User user = new User("John", "Doe", 30);

        // 将 User 对象转换为 JsonNode 对象
        JsonNode userNode = objectMapper.valueToTree(user);
        System.out.println(userNode.get("firstName").asText()); // John

        // 将 JsonNode 对象转换回 User 对象
        User convertedUser = objectMapper.treeToValue(userNode, User.class);
        System.out.println(convertedUser.getFirstName()); // John
    }
}
```

### 5. `readerFor` 和 `writerFor` 方法

`readerFor` 和 `writerFor` 方法用于创建类型安全的读取和写入器。

#### 示例
```java
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.util.List;

public class JacksonExample {
    public static void main(String[] args) throws Exception {
        ObjectMapper objectMapper = new ObjectMapper();

        String jsonString = "[{\"firstName\":\"John\",\"lastName\":\"Doe\",\"age\":30}]";

        // 使用 readerFor 方法创建类型安全的读取器
        List<User> users = objectMapper.readerFor(new TypeReference<List<User>>() {}).readValue(jsonString);
        System.out.println(users.get(0).getFirstName()); // John

        // 使用 writerFor 方法创建类型安全的写入器
        String jsonOutput = objectMapper.writerFor(new TypeReference<List<User>>() {}).writeValueAsString(users);
        System.out.println(jsonOutput); // [{"firstName":"John","lastName":"Doe","age":30}]
    }
}
```

### 6. `canSerialize` 和 `canDeserialize` 方法

这些方法用于检查某个类是否可以被序列化或反序列化。

#### 示例
```java
import com.fasterxml.jackson.databind.ObjectMapper;

public class JacksonExample {
    public static void main(String[] args) {
        ObjectMapper objectMapper = new ObjectMapper();

        // 检查 User 类是否可以被序列化
        boolean canSerialize = objectMapper.canSerialize(User.class);
        System.out.println("Can serialize User: " + canSerialize); // true

        // 检查是否可以反序列化为 User 类
        boolean canDeserialize = objectMapper.canDeserialize(objectMapper.constructType(User.class));
        System.out.println("Can deserialize User: " + canDeserialize); // true
    }
}
```

### 7. `registerModule` 方法

用于注册自定义模块，比如自定义序列化器和反序列化器。

#### 示例
```java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;

public class JacksonExample {
    public static void main(String[] args) throws Exception {
        ObjectMapper objectMapper = new ObjectMapper();

        SimpleModule module = new SimpleModule();
        module.addSerializer(User.class, new UserSerializer());
        module.addDeserializer(User.class, new UserDeserializer());
        objectMapper.registerModule(module);

        User user = new User("John", "Doe", 30);
        String jsonString = objectMapper.writeValueAsString(user);
        System.out.println(jsonString); // {"first_name":"John","last_name":"Doe"}

        User deserializedUser = objectMapper.readValue(jsonString, User.class);
        System.out.println(deserializedUser.getFirstName()); // John
    }
}
```

通过上述总结，你可以全面了解 `ObjectMapper` 的各种使用方法和场景。希望这能帮助你更好地使用 Jackson 进行 JSON 数据处理。

# 4. Jackson中描述数据结构的通用对象
在 Jackson 中，可以使用 `JsonNode` 类来描述通用的 JSON 对象，类似于 `JSONObject`。`JsonNode` 是 Jackson 核心的一部分，它提供了一个树状模型来处理 JSON 数据。下面是一些示例，演示如何使用 `JsonNode` 来解析、处理和构建 JSON 数据。

### 1. 解析 JSON 字符串为 `JsonNode`

使用 `ObjectMapper` 的 `readTree` 方法可以将 JSON 字符串解析为 `JsonNode` 对象。

#### 示例
```java
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

public class JacksonExample {
    public static void main(String[] args) throws Exception {
        ObjectMapper objectMapper = new ObjectMapper();

        String jsonString = "{\"firstName\":\"John\",\"lastName\":\"Doe\",\"age\":30}";

        // 解析 JSON 字符串为 JsonNode 对象
        JsonNode rootNode = objectMapper.readTree(jsonString);
        System.out.println(rootNode.get("firstName").asText()); // John
        System.out.println(rootNode.get("age").asInt()); // 30
    }
}
```

### 2. 构建 `JsonNode` 对象

可以使用 `ObjectMapper` 的 `createObjectNode` 和 `createArrayNode` 方法来构建 `JsonNode` 对象。

#### 示例
```java
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.fasterxml.jackson.databind.node.ArrayNode;

public class JacksonExample {
    public static void main(String[] args) throws Exception {
        ObjectMapper objectMapper = new ObjectMapper();

        // 创建一个 ObjectNode 对象
        ObjectNode userNode = objectMapper.createObjectNode();
        userNode.put("firstName", "John");
        userNode.put("lastName", "Doe");
        userNode.put("age", 30);

        // 创建一个 ArrayNode 对象
        ArrayNode phoneNumbersNode = objectMapper.createArrayNode();
        phoneNumbersNode.add("123-456-7890");
        phoneNumbersNode.add("098-765-4321");

        // 将 ArrayNode 添加到 ObjectNode
        userNode.set("phoneNumbers", phoneNumbersNode);

        // 打印 JsonNode 对象
        System.out.println(userNode.toPrettyString());
    }
}
```

### 3. 修改 `JsonNode` 对象

可以使用 `ObjectNode` 的各种 `put` 方法来修改 `JsonNode` 对象。

#### 示例
```java
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;

public class JacksonExample {
    public static void main(String[] args) throws Exception {
        ObjectMapper objectMapper = new ObjectMapper();

        String jsonString = "{\"firstName\":\"John\",\"lastName\":\"Doe\",\"age\":30}";
        JsonNode rootNode = objectMapper.readTree(jsonString);

        // 修改 age 属性
        if (rootNode.isObject()) {
            ((ObjectNode) rootNode).put("age", 31);
        }

        // 打印修改后的 JsonNode 对象
        System.out.println(rootNode.toPrettyString());
    }
}
```

### 4. 遍历 `JsonNode` 对象

可以使用 `JsonNode` 的各种方法来遍历 JSON 数据。

#### 示例
```java
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.Iterator;
import java.util.Map;

public class JacksonExample {
    public static void main(String[] args) throws Exception {
        ObjectMapper objectMapper = new ObjectMapper();

        String jsonString = "{\"firstName\":\"John\",\"lastName\":\"Doe\",\"age\":30,\"address\":{\"city\":\"New York\",\"state\":\"NY\"}}";
        JsonNode rootNode = objectMapper.readTree(jsonString);

        // 遍历所有字段
        Iterator<Map.Entry<String, JsonNode>> fields = rootNode.fields();
        while (fields.hasNext()) {
            Map.Entry<String, JsonNode> field = fields.next();
            System.out.println(field.getKey() + ": " + field.getValue());
        }
    }
}
```

### 5. 将 `JsonNode` 转换为 Java 对象

可以使用 `ObjectMapper` 的 `treeToValue` 方法将 `JsonNode` 转换为 Java 对象。

#### 示例
```java
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

public class JacksonExample {
    public static void main(String[] args) throws Exception {
        ObjectMapper objectMapper = new ObjectMapper();

        String jsonString = "{\"firstName\":\"John\",\"lastName\":\"Doe\",\"age\":30}";
        JsonNode rootNode = objectMapper.readTree(jsonString);

        // 将 JsonNode 转换为 User 对象
        User user = objectMapper.treeToValue(rootNode, User.class);
        System.out.println(user.getFirstName()); // John
        System.out.println(user.getLastName()); // Doe
        System.out.println(user.getAge()); // 30
    }
}
```

### 6. 将 Java 对象转换为 `JsonNode`

可以使用 `ObjectMapper` 的 `valueToTree` 方法将 Java 对象转换为 `JsonNode`。

#### 示例
```java
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

public class JacksonExample {
    public static void main(String[] args) throws Exception {
        ObjectMapper objectMapper = new ObjectMapper();

        User user = new User("John", "Doe", 30);

        // 将 User 对象转换为 JsonNode
        JsonNode userNode = objectMapper.valueToTree(user);
        System.out.println(userNode.toPrettyString());
    }
}
```

通过使用 `JsonNode` 类，Jackson 提供了一种强大的方式来处理通用的 JSON 对象，使得 JSON 数据的解析、修改和构建变得更加灵活和方便。

# 5. jackson进行字符串和实体字段的驼峰命名
在 Spring Boot 中，使用 Jackson 可以方便地将 JSON 字段名从下划线格式（如 `z_test_name`）自动转换为驼峰命名格式（如 `zTestName`）。你可以通过配置 `ObjectMapper` 来实现这个功能。

### 使用 `PropertyNamingStrategies` 配置

`PropertyNamingStrategies` 提供了一些内置的命名策略，其中包括 `SNAKE_CASE` 和 `LOWER_CAMEL_CASE`。我们可以通过配置 `ObjectMapper` 来将 `SNAKE_CASE` 的字段名自动转换为 `LOWER_CAMEL_CASE`。

#### 1. 配置 `ObjectMapper` 在 Spring Boot 中

你可以通过两种方式来配置 `ObjectMapper`：

##### 方法一：在 `application.properties` 或 `application.yml` 中配置

你可以在 `application.properties` 或 `application.yml` 文件中直接配置 Jackson 的命名策略：

**application.properties:**
```properties
spring.jackson.property-naming-strategy=SNAKE_CASE
```

**application.yml:**
```yaml
spring:
  jackson:
    property-naming-strategy: SNAKE_CASE
```

##### 方法二：通过 Java 配置类配置

如果你需要更灵活的配置，可以创建一个配置类来配置 `ObjectMapper`：

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.PropertyNamingStrategies;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class JacksonConfig {

    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setPropertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE);
        return objectMapper;
    }
}
```

### 示例代码

假设我们有一个 `User` 类，其字段名使用驼峰命名法：

```java
public class User {
    private String firstName;
    private String lastName;
    private int age;

    // getters and setters
    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

现在我们创建一个 Spring Boot 应用，发送一个 JSON 请求，其中字段名使用下划线命名法，Spring Boot 会自动将其转换为驼峰命名法：

**Controller 类：**

```java
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class UserController {

    @PostMapping("/users")
    public User createUser(@RequestBody User user) {
        // 处理用户对象
        return user;
    }
}
```

**测试 JSON 请求：**

```json
{
    "first_name": "John",
    "last_name": "Doe",
    "age": 30
}
```

### 验证

你可以使用工具如 Postman 或 cURL 来测试上述 API：

**使用 cURL：**

```sh
curl -X POST -H "Content-Type: application/json" -d '{"first_name":"John","last_name":"Doe","age":30}' http://localhost:8080/users
```

服务器端会自动将 `first_name`、`last_name` 转换为 `firstName

# 6. jackson将“_”直接删除，替换为空格
Jackson 本身不直接支持将下划线删除并替换为空格的功能。然而，你可以通过自定义命名策略来实现这个需求。通过创建自定义的 `PropertyNamingStrategy`，你可以定义你自己的命名规则。

### 自定义 `PropertyNamingStrategy` 示例

下面是一个示例，展示如何创建自定义的 `PropertyNamingStrategy`，将 JSON 字段名中的下划线删除并替换为空格。

#### 1. 创建自定义 `PropertyNamingStrategy`

```java
import com.fasterxml.jackson.databind.PropertyNamingStrategy;
import com.fasterxml.jackson.databind.cfg.MapperConfig;
import com.fasterxml.jackson.databind.introspect.AnnotatedField;
import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;
import com.fasterxml.jackson.databind.introspect.AnnotatedParameter;

public class RemoveUnderscoresAndAddSpacesStrategy extends PropertyNamingStrategy {

    @Override
    public String nameForField(MapperConfig<?> config, AnnotatedField field, String defaultName) {
        return convert(defaultName);
    }

    @Override
    public String nameForGetterMethod(MapperConfig<?> config, AnnotatedMethod method, String defaultName) {
        return convert(defaultName);
    }

    @Override
    public String nameForSetterMethod(MapperConfig<?> config, AnnotatedMethod method, String defaultName) {
        return convert(defaultName);
    }

    @Override
    public String nameForConstructorParameter(MapperConfig<?> config, AnnotatedParameter ctorParam, String defaultName) {
        return convert(defaultName);
    }

    private String convert(String defaultName) {
        // 替换下划线为空格
        return defaultName.replace("_", " ");
    }
}
```

#### 2. 配置 `ObjectMapper` 使用自定义的命名策略

你可以在 Spring Boot 配置类中配置 `ObjectMapper` 使用自定义的命名策略。

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class JacksonConfig {

    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setPropertyNamingStrategy(new RemoveUnderscoresAndAddSpacesStrategy());
        return objectMapper;
    }
}
```

### 示例代码

假设我们有一个 `User` 类，其字段名使用驼峰命名法：

```java
public class User {
    private String firstName;
    private String lastName;
    private int age;

    // getters and setters
    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

### 处理 JSON 请求

创建一个 Spring Boot 控制器，接收并处理 JSON 请求：

```java
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class UserController {

    @PostMapping("/users")
    public User createUser(@RequestBody User user) {
        // 处理用户对象
        return user;
    }
}
```

### 测试 JSON 请求

发送一个 JSON 请求，其中字段名包含下划线：

```json
{
    "first_name": "John",
    "last_name": "Doe",
    "age": 30
}
```

服务器端将自动将 `first_name` 和 `last_name` 字段转换为 `firstName` 和 `lastName`，并删除下划线，替换为空格。

### 验证

你可以使用 Postman 或 cURL 来测试上述 API：

**使用 cURL：**

```sh
curl -X POST -H "Content-Type: application/json" -d '{"first name":"John","last name":"Doe","age":30}' http://localhost:8080/users
```

服务器端将自动将 `first_name` 和 `last_name` 字段转换为 `firstName` 和 `lastName`，并删除下划线，替换为空格。

# 7. springboot对ObjectMapper的管理
在 Spring Boot 中，当你尝试注入一个 `ObjectMapper` 对象时，它会自动注入进来。这是因为 Spring Boot 自动配置（Auto Configuration）机制为你管理了 `ObjectMapper` 实例。下面详细解释为什么会发生这种情况以及 `ObjectMapper` 是如何交给 Spring Boot 容器管理的。

### Spring Boot 自动配置机制

Spring Boot 提供了许多自动配置类，这些类根据类路径中的依赖和你在 `application.properties` 或 `application.yml` 文件中的配置，自动配置 Spring 应用程序。对于 Jackson 的 `ObjectMapper`，Spring Boot 提供了 `JacksonAutoConfiguration` 类来自动配置 `ObjectMapper`。

#### 自动配置 `ObjectMapper`

`JacksonAutoConfiguration` 是 Spring Boot 自动配置的一部分，它负责配置 Jackson 并将 `ObjectMapper` 注册为 Spring 的 Bean。默认情况下，Spring Boot 会在启动时自动扫描类路径中的 Jackson 库，并自动创建和配置一个 `ObjectMapper` 实例。

以下是 `JacksonAutoConfiguration` 的简化版本：

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(ObjectMapper.class)
@EnableConfigurationProperties(JacksonProperties.class)
@Import({JacksonAutoConfiguration.Jackson2ObjectMapperBuilderCustomizerConfiguration.class,
        JacksonAutoConfiguration.ParameterNamesModuleConfiguration.class})
public class JacksonAutoConfiguration {

    @Bean
    @Primary
    public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) {
        return builder.createXmlMapper(false).build();
    }

    // other beans and configurations
}
```

这里有几个关键点：

- `@Configuration`: 表示这是一个配置类。
- `@ConditionalOnClass(ObjectMapper.class)`: 只有在类路径中存在 `ObjectMapper` 类时才会进行配置。
- `@EnableConfigurationProperties(JacksonProperties.class)`: 启用 Jackson 的相关配置属性。
- `@Bean` 和 `@Primary`: 注册一个 `ObjectMapper` Bean，并将其标记为主要的（primary），以便在有多个 `ObjectMapper` Bean 时优先使用这个。

### 自动注入 `ObjectMapper`

由于 `JacksonAutoConfiguration` 已经配置了 `ObjectMapper` 并将其注册为 Spring 容器中的 Bean，因此你可以在你的 Spring Boot 应用程序中通过 `@Autowired` 或构造函数注入的方式直接注入 `ObjectMapper`，如下所示：

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class MyController {

    private final ObjectMapper objectMapper;

    @Autowired
    public MyController(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }

    @GetMapping("/test")
    public String test() {
        // 使用 objectMapper 进行操作
        return "ObjectMapper injected!";
    }
}
```

或者使用构造函数注入：

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class MyController {

    private final ObjectMapper objectMapper;

    public MyController(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }

    @GetMapping("/test")
    public String test() {
        // 使用 objectMapper 进行操作
        return "ObjectMapper injected!";
    }
}
```

### 自定义 `ObjectMapper`

如果你需要自定义 `ObjectMapper` 的配置，可以创建一个配置类并覆盖默认的 `ObjectMapper` Bean：

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.PropertyNamingStrategies;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class CustomJacksonConfig {

    @Bean
    public ObjectMapper customObjectMapper() {
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setPropertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE);
        // 添加其他自定义配置
        return objectMapper;
    }
}
```

这种方式可以确保你的自定义配置会被应用到 `ObjectMapper` 中，同时仍然保留了 Spring Boot 自动配置的大部分便利性。

总结来说，Spring Boot 自动配置机制通过 `JacksonAutoConfiguration` 类自动配置并管理 `ObjectMapper` 对象，使得你可以直接在应用程序中注入并使用它。如果需要自定义 `ObjectMapper`，可以通过定义自己的配置类来覆盖默认的配置。

# 8. JsonNode和ObjectNode
在 Jackson 中，`JsonNode` 是所有 JSON 节点（例如对象节点、数组节点、值节点等）的抽象基类，而 `ObjectNode` 是 `JsonNode` 的具体子类之一，表示 JSON 对象节点。你可以使用 `ObjectMapper` 来创建空的 `JsonNode` 或 `ObjectNode` 对象。

### 创建空的 `JsonNode` 对象

要创建一个空的 `JsonNode` 对象，你可以使用 `ObjectMapper` 的 `createObjectNode` 或 `createArrayNode` 方法。下面是一些示例：

#### 创建空的 `ObjectNode`

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;

public class JacksonExample {
    public static void main(String[] args) {
        ObjectMapper mapper = new ObjectMapper();
        ObjectNode emptyObjectNode = mapper.createObjectNode();
        System.out.println(emptyObjectNode.toString()); // 输出: {}
    }
}
```

#### 创建空的 `ArrayNode`

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;

public class JacksonExample {
    public static void main(String[] args) {
        ObjectMapper mapper = new ObjectMapper();
        ArrayNode emptyArrayNode = mapper.createArrayNode();
        System.out.println(emptyArrayNode.toString()); // 输出: []
    }
}
```

### `ObjectNode` 和 `JsonNode` 的关系

- `JsonNode` 是所有 JSON 节点的基类，它是一个抽象类。`JsonNode` 有许多子类，表示不同类型的 JSON 节点，例如 `ObjectNode`（对象节点）、`ArrayNode`（数组节点）、`TextNode`（文本节点）等。
- `ObjectNode` 是 `JsonNode` 的一个具体子类，表示 JSON 对象节点。`ObjectNode` 允许你以键值对的形式存储数据。

#### 示例：使用 `ObjectNode` 和 `JsonNode`

```java
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;

public class JacksonExample {
    public static void main(String[] args) {
        ObjectMapper mapper = new ObjectMapper();

        // 创建一个空的 ObjectNode
        ObjectNode objectNode = mapper.createObjectNode();
        objectNode.put("name", "John Doe");
        objectNode.put("age", 30);
        objectNode.put("email", "john.doe@example.com");

        // 输出 ObjectNode
        System.out.println(objectNode.toString());

        // 将 ObjectNode 转换为 JsonNode
        JsonNode jsonNode = objectNode;
        System.out.println(jsonNode.toString());
    }
}
```

在这个示例中，我们首先创建一个空的 `ObjectNode`，然后向其中添加一些键值对。接着，我们将 `ObjectNode` 赋值给一个 `JsonNode` 变量，因为 `ObjectNode` 是 `JsonNode` 的子类，可以被看作 `JsonNode`。

### 其他常用操作

#### 添加节点到 `ObjectNode`

```java
ObjectNode parentNode = mapper.createObjectNode();
parentNode.put("field1", "value1");
parentNode.put("field2", 123);

// 创建子节点
ObjectNode childNode = mapper.createObjectNode();
childNode.put("childField1", "childValue1");

// 将子节点添加到父节点
parentNode.set("childNode", childNode);

System.out.println(parentNode.toString());
// 输出: {"field1":"value1","field2":123,"childNode":{"childField1":"childValue1"}}
```

#### 读取 `JsonNode` 的值

```java
String jsonString = "{\"name\":\"John Doe\",\"age\":30}";
JsonNode rootNode = mapper.readTree(jsonString);
String name = rootNode.get("name").asText();
int age = rootNode.get("age").asInt();

System.out.println("Name: " + name + ", Age: " + age);
// 输出: Name: John Doe, Age: 30
```

通过这些示例和解释，希望你对 `JsonNode` 和 `ObjectNode` 之间的关系以及如何创建和操作它们有了更清晰的理解。

# 9. 实现一个需求
有一个java bean，部分字段使用了@JsonProperty指定了别名，现在想直接创建一个空的该对象，我的目的很简单，前端需要上送一个字段或者多个字段，这些字段是我上一个接口返回的该java bean序列化的值；现在当前端上送一个字段或者多个字段时，需要直接校验该字段是否属于这个java bean？   

要实现你的目标，即根据 `@JsonProperty` 注解创建一个空的 Java Bean 实例，并进行字段校验，你可以遵循以下步骤：

1. **定义 Java Bean 类**：
   - 使用 `@JsonProperty` 指定字段的别名。

2. **创建空的 Java Bean 实例**：
   - 使用 Jackson 的 `ObjectMapper` 反序列化来创建一个空的 Bean 实例。

3. **字段校验**：
   - 比较前端上送的字段与 Bean 中的字段，确保前端上送的字段是有效的。

下面是详细的步骤和代码示例：

### 1. 定义 Java Bean 类

假设你有一个 Java Bean 类 `User`，其中一些字段使用 `@JsonProperty` 指定了别名：

```java
import com.fasterxml.jackson.annotation.JsonProperty;

public class User {

    @JsonProperty("user_name")
    private String userName;

    @JsonProperty("user_age")
    private int age;

    @JsonProperty("user_email")
    private String email;

    // Getters and setters
    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }
}
```

### 2. 创建空的 Java Bean 实例

使用 Jackson 的 `ObjectMapper` 创建空的 Java Bean 实例：

```java
import com.fasterxml.jackson.databind.ObjectMapper;

public class BeanCreator {

    public static void main(String[] args) throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        User user = mapper.readValue("{}", User.class); // 创建一个空的 User 实例

        System.out.println(user);
    }
}
```

### 3. 字段校验

要验证前端上送的字段是否属于 `User` 类，你可以使用反射来获取 `User` 类的所有字段，并将它们与前端上送的字段进行比较。下面的代码演示了如何进行这种字段校验：

```java
import com.fasterxml.jackson.annotation.JsonProperty;
import java.lang.reflect.Field;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class FieldValidator {

    public static void main(String[] args) throws Exception {
        Set<String> validFields = getValidFields(User.class);
        System.out.println("Valid fields: " + validFields);

        // 模拟前端上送的字段
        Set<String> incomingFields = new HashSet<>(Arrays.asList("user_name", "invalid_field"));

        // 校验
        for (String field : incomingFields) {
            if (!validFields.contains(field)) {
                System.out.println("Invalid field: " + field);
            } else {
                System.out.println("Valid field: " + field);
            }
        }
    }

    private static Set<String> getValidFields(Class<?> clazz) {
        Set<String> fields = new HashSet<>();
        for (Field field : clazz.getDeclaredFields()) {
            JsonProperty jsonProperty = field.getAnnotation(JsonProperty.class);
            if (jsonProperty != null) {
                fields.add(jsonProperty.value());
            } else {
                fields.add(field.getName());
            }
        }
        return fields;
    }
}
```

### 总结

1. **定义 Bean 类**：使用 `@JsonProperty` 注解来指定字段的别名。
2. **创建实例**：使用 `ObjectMapper` 从空 JSON 字符串创建一个空的 Bean 实例。
3. **字段校验**：使用反射获取 Bean 类的字段名（包括 `@JsonProperty` 的别名），并与前端上送的字段进行比较，确保其有效性。

这样，你就可以根据 `@JsonProperty` 指定的别名，动态地校验前端上送的字段是否属于你的 Java Bean。

# 10. 如何获取一个空的jackson的所有key？
如果你需要获取一个空的 Jackson JSON 对象的所有键（keys），即使它们还没有被设置，你可以利用 Jackson 的 `ObjectMapper` 和 `ObjectNode` 来实现。由于一个空的 `ObjectNode` 本身没有任何键，首先你需要创建一个 `ObjectNode` 对象，并在其上定义一些默认的键。

### 示例：获取一个空 `ObjectNode` 的所有键

由于 `ObjectNode` 是一个 JSON 对象节点，它在创建时是空的，因此你需要手动添加一些键以便获取这些键。以下是一个示例，展示了如何在创建 `ObjectNode` 后添加一些键并获取这些键：

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;

import java.util.Iterator;
import java.util.Map;

public class JacksonExample {
    public static void main(String[] args) throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        ObjectNode objectNode = mapper.createObjectNode();

        // 添加一些键值对
        objectNode.put("key1", "value1");
        objectNode.put("key2", "value2");
        objectNode.put("key3", "value3");

        // 获取所有的键
        Iterator<Map.Entry<String, com.fasterxml.jackson.databind.JsonNode>> fields = objectNode.fields();
        
        System.out.println("Keys in the ObjectNode:");
        while (fields.hasNext()) {
            Map.Entry<String, com.fasterxml.jackson.databind.JsonNode> field = fields.next();
            System.out.println(field.getKey());
        }
    }
}
```

### 解析

1. **创建 `ObjectNode`**:
   ```java
   ObjectNode objectNode = mapper.createObjectNode();
   ```

2. **添加键值对**:
   ```java
   objectNode.put("key1", "value1");
   objectNode.put("key2", "value2");
   objectNode.put("key3", "value3");
   ```

3. **获取所有的键**:
   - `objectNode.fields()` 返回一个 `Iterator`，你可以通过它遍历所有的字段。
   - `Map.Entry<String, JsonNode>` 中的 `getKey()` 方法返回字段的键。

### 示例：获取具有特定结构的空 `ObjectNode` 的所有键

如果你有一个预定义的 JSON 结构，你希望从中获取键，即使这些键最初是空的，可以先定义结构，然后获取键。以下是一个示例：

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;

import java.util.Iterator;

public class JacksonExample {
    public static void main(String[] args) throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        ObjectNode objectNode = mapper.createObjectNode();

        // 定义结构，添加默认值
        objectNode.put("name", (String) null);
        objectNode.put("age", (Integer) null);
        objectNode.put("email", (String) null);

        // 获取所有的键
        Iterator<String> fieldNames = objectNode.fieldNames();

        System.out.println("Keys in the ObjectNode:");
        while (fieldNames.hasNext()) {
            String fieldName = fieldNames.next();
            System.out.println(fieldName);
        }
    }
}
```

### 解析

1. **定义结构**:
   ```java
   objectNode.put("name", (String) null);
   objectNode.put("age", (Integer) null);
   objectNode.put("email", (String) null);
   ```

2. **获取所有键**:
   - `objectNode.fieldNames()` 返回一个 `Iterator`，它提供了所有字段名。

### 总结

- `ObjectNode` 在创建时是空的。你需要添加键值对才能获取这些键。
- 使用 `objectNode.fields()` 可以获取字段名和字段值。
- 使用 `objectNode.fieldNames()` 可以获取字段名而不需要字段值。

通过这些方法，你可以动态地创建并获取 JSON 对象中的所有键。

# 11. springBoot中如何生成json文件？返回给前端下载
在 Spring Boot 中生成 JSON 文件并将其返回给前端进行下载，可以通过创建一个 `ResponseEntity` 来实现。以下是实现这一功能的步骤：

1. **生成 JSON 数据**：创建一个 JSON 对象（例如，使用 Jackson 的 `ObjectMapper`）。
2. **将 JSON 数据写入文件**：将 JSON 数据写入临时文件。
3. **将文件作为响应返回**：使用 `ResponseEntity` 将文件内容返回给前端，设置适当的 HTTP 头信息以提示浏览器下载文件。

下面是一个详细的示例：

### 1. 创建 JSON 数据

首先，定义一个 JSON 对象并将其序列化为字符串。

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;

@RestController
@RequestMapping("/api")
public class FileDownloadController {

    private final ObjectMapper objectMapper = new ObjectMapper();

    @GetMapping("/download")
    public ResponseEntity<byte[]> downloadJsonFile() throws IOException {
        // 创建 JSON 对象
        ObjectNode jsonObject = objectMapper.createObjectNode();
        jsonObject.put("name", "John Doe");
        jsonObject.put("age", 30);
        jsonObject.put("email", "john.doe@example.com");

        // 将 JSON 对象写入 ByteArrayOutputStream
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        objectMapper.writeValue(outputStream, jsonObject);

        // 获取文件内容的字节数组
        byte[] jsonBytes = outputStream.toByteArray();

        // 设置响应的内容和头信息
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.setContentDisposition(ContentDisposition.attachment().filename("data.json").build());

        return ResponseEntity.ok()
                .headers(headers)
                .body(jsonBytes);
    }
}
```

### 解析

1. **创建 JSON 数据**：
   - 使用 `ObjectMapper` 创建一个 JSON 对象并将数据放入其中。

2. **将 JSON 数据写入 `ByteArrayOutputStream`**：
   - 使用 `objectMapper.writeValue(outputStream, jsonObject)` 将 JSON 数据写入 `ByteArrayOutputStream`，然后获取字节数组。

3. **设置响应的内容和头信息**：
   - 使用 `HttpHeaders` 设置内容类型和内容处置（提示浏览器下载文件）。
   - `ContentDisposition.attachment().filename("data.json").build()` 设置文件名。

4. **返回 `ResponseEntity`**：
   - 使用 `ResponseEntity.ok().headers(headers).body(jsonBytes)` 返回字节数组作为响应体。

### 注意事项

- **Content-Type**: 设置为 `application/json`，表示返回的内容是 JSON 格式。
- **Content-Disposition**: 设置为 `attachment`，并指定文件名，表示文件将作为附件下载。

### 完整示例

以下是完整的 Spring Boot 控制器示例，供你参考：

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.springframework.core.io.InputStreamResource;
import org.springframework.http.*;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;

@RestController
@RequestMapping("/api")
public class FileDownloadController {

    private final ObjectMapper objectMapper = new ObjectMapper();

    @GetMapping("/download")
    public ResponseEntity<byte[]> downloadJsonFile() throws IOException {
        // 创建 JSON 对象
        ObjectNode jsonObject = objectMapper.createObjectNode();
        jsonObject.put("name", "John Doe");
        jsonObject.put("age", 30);
        jsonObject.put("email", "john.doe@example.com");

        // 将 JSON 对象写入 ByteArrayOutputStream
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        objectMapper.writeValue(outputStream, jsonObject);

        // 获取文件内容的字节数组
        byte[] jsonBytes = outputStream.toByteArray();

        // 设置响应的内容和头信息
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.setContentDisposition(ContentDisposition.attachment().filename("data.json").build());

        return ResponseEntity.ok()
                .headers(headers)
                .body(jsonBytes);
    }
}
```

在前端，你可以使用标准的下载机制（如 `window.location.href` 或 `fetch` API）来触发文件下载。这个示例展示了如何在 Spring Boot 应用程序中生成和返回 JSON 文件，供客户端下载。

# 12. 以流的方式怎么实现呢？
使用流的方式来生成和返回 JSON 文件，可以在 Spring Boot 中实现更高效的文件下载，尤其是当数据量较大时。通过流的方式，你可以直接将 JSON 数据写入响应流，而不是将数据加载到内存中。

以下是如何在 Spring Boot 中使用流的方式生成 JSON 文件并返回给前端进行下载的示例：

### 示例：使用流的方式生成 JSON 文件

1. **创建 JSON 数据并写入响应流**：
   - 使用 `ObjectMapper` 创建 JSON 数据。
   - 将数据写入 `ServletOutputStream`，这是 Spring MVC 提供的响应流。

2. **配置响应头**：
   - 设置内容类型为 `application/json`。
   - 设置 `Content-Disposition` 以指示文件下载。

### 代码示例

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.OutputStream;

@RestController
@RequestMapping("/api")
public class FileDownloadController {

    private final ObjectMapper objectMapper = new ObjectMapper();

    @GetMapping("/download")
    public void downloadJsonFile(HttpServletResponse response) throws IOException {
        // 创建 JSON 对象
        ObjectNode jsonObject = objectMapper.createObjectNode();
        jsonObject.put("name", "John Doe");
        jsonObject.put("age", 30);
        jsonObject.put("email", "john.doe@example.com");

        // 设置响应内容类型和文件名
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setHeader(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=data.json");

        // 将 JSON 对象写入响应流
        try (OutputStream outputStream = response.getOutputStream()) {
            objectMapper.writeValue(outputStream, jsonObject);
            outputStream.flush();
        }
    }
}
```

### 解析

1. **创建 JSON 数据**：
   - 使用 `ObjectMapper` 创建 JSON 数据。

2. **配置响应头**：
   - `response.setContentType(MediaType.APPLICATION_JSON_VALUE)` 设置响应内容类型为 `application/json`。
   - `response.setHeader(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=data.json")` 设置 `Content-Disposition` 头，以指示浏览器下载文件，文件名为 `data.json`。

3. **写入响应流**：
   - 使用 `response.getOutputStream()` 获取响应的 `OutputStream`。
   - 使用 `objectMapper.writeValue(outputStream, jsonObject)` 将 JSON 数据写入响应流。

4. **刷新并关闭流**：
   - `outputStream.flush()` 确保所有数据被写入到响应中。
   - 使用 `try-with-resources` 确保流在操作完成后被正确关闭。

### 注意事项

- **内存管理**：使用流的方式避免了将整个 JSON 数据加载到内存中，可以处理较大的数据集。
- **响应头配置**：确保正确配置 `Content-Type` 和 `Content-Disposition` 头，以便浏览器处理文件下载。

这个示例展示了如何在 Spring Boot 应用程序中使用流的方式生成和返回 JSON 文件，实现高效的数据下载。

# 13. 下载的json文件如何格式化呢？通过代码直接给格式化好
要在 Spring Boot 中生成并下载格式化（漂亮打印）的 JSON 文件，你可以使用 Jackson 的 `ObjectMapper` 来配置 JSON 输出的格式。Jackson 提供了选项来使 JSON 输出易于阅读（即格式化 JSON）。

以下是如何在 Spring Boot 中生成格式化的 JSON 文件并返回给前端进行下载的示例：

### 示例：生成并下载格式化的 JSON 文件

1. **配置 `ObjectMapper` 以格式化输出**：使用 `ObjectMapper` 的 `writerWithDefaultPrettyPrinter()` 方法生成格式化的 JSON。
2. **将格式化后的 JSON 写入响应流**：将 JSON 数据写入 `ServletOutputStream`，这是 Spring MVC 提供的响应流。

### 代码示例

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.OutputStream;

@RestController
@RequestMapping("/api")
public class FileDownloadController {

    private final ObjectMapper objectMapper = new ObjectMapper();

    @GetMapping("/download")
    public void downloadJsonFile(HttpServletResponse response) throws IOException {
        // 创建 JSON 对象
        ObjectNode jsonObject = objectMapper.createObjectNode();
        jsonObject.put("name", "John Doe");
        jsonObject.put("age", 30);
        jsonObject.put("email", "john.doe@example.com");

        // 设置响应内容类型和文件名
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setHeader(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=data.json");

        // 将格式化的 JSON 对象写入响应流
        try (OutputStream outputStream = response.getOutputStream()) {
            // 使用 writerWithDefaultPrettyPrinter() 生成格式化的 JSON
            String formattedJson = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonObject);
            outputStream.write(formattedJson.getBytes());
            outputStream.flush();
        }
    }
}
```

### 解析

1. **创建 JSON 数据**：
   - 使用 `ObjectMapper` 创建 JSON 数据。

2. **配置响应头**：
   - `response.setContentType(MediaType.APPLICATION_JSON_VALUE)` 设置响应内容类型为 `application/json`。
   - `response.setHeader(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=data.json")` 设置 `Content-Disposition` 头，以指示浏览器下载文件，文件名为 `data.json`。

3. **格式化 JSON 输出**：
   - 使用 `objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonObject)` 生成格式化的 JSON 字符串。`writerWithDefaultPrettyPrinter()` 返回一个 `ObjectWriter` 实例，该实例用于生成格式化的 JSON 输出。

4. **写入响应流**：
   - 将格式化后的 JSON 字符串写入 `OutputStream`。
   - 使用 `outputStream.write(formattedJson.getBytes())` 将字符串转换为字节数组，并写入响应流。

5. **刷新并关闭流**：
   - `outputStream.flush()` 确保所有数据被写入到响应中。
   - 使用 `try-with-resources` 确保流在操作完成后被正确关闭。

### 总结

通过这种方式，你可以生成格式化（漂亮打印）的 JSON 文件，并将其作为下载文件返回给前端。这使得 JSON 数据不仅正确而且易于阅读，尤其适用于需要进行调试或展示的场景。

# 14. 感觉这种方式生成的json也不是特别漂亮，和在idea中手动格式化的结果不太一样
Jackson 的 `ObjectMapper` 的默认 `DefaultPrettyPrinter` 确实能够格式化 JSON，但它的格式化效果可能与某些编辑器（如 IntelliJ IDEA）的格式化结果略有不同。如果你需要更细致的控制和更接近编辑器的格式化效果，可以考虑自定义格式化器或使用其他工具。

### 自定义格式化 JSON

Jackson 提供了 `DefaultPrettyPrinter` 的一些自定义选项。如果你觉得默认的格式化效果还不够好，可以通过自定义 `PrettyPrinter` 来满足更复杂的格式化需求。

### 使用 Jackson 的 `DefaultPrettyPrinter` 自定义格式化

Jackson 提供了一些配置选项来定制格式化效果。你可以通过 `ObjectMapper` 的 `DefaultPrettyPrinter` 自定义 JSON 输出的格式：

```java
import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.OutputStream;

@RestController
@RequestMapping("/api")
public class FileDownloadController {

    private final ObjectMapper objectMapper = new ObjectMapper();

    @GetMapping("/download")
    public void downloadJsonFile(HttpServletResponse response) throws IOException {
        // 创建 JSON 对象
        ObjectNode jsonObject = objectMapper.createObjectNode();
        jsonObject.put("name", "John Doe");
        jsonObject.put("age", 30);
        jsonObject.put("email", "john.doe@example.com");

        // 设置响应内容类型和文件名
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setHeader(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=data.json");

        // 自定义 PrettyPrinter
        DefaultPrettyPrinter prettyPrinter = new DefaultPrettyPrinter();
        prettyPrinter.indentArraysWith(DefaultPrettyPrinter.FixedSpaceIndenter.instance);

        // 将格式化的 JSON 对象写入响应流
        try (OutputStream outputStream = response.getOutputStream()) {
            String formattedJson = objectMapper.writer(prettyPrinter).writeValueAsString(jsonObject);
            outputStream.write(formattedJson.getBytes());
            outputStream.flush();
        }
    }
}
```

### 自定义 PrettyPrinter 配置

- **`indentArraysWith`**: 设置数组的缩进方式。可以使用 `DefaultPrettyPrinter.FixedSpaceIndenter.instance` 或自定义缩进。
- **`DefaultPrettyPrinter`**: 提供了其他方法来控制缩进、行结束符等。

### 其他工具

如果 Jackson 的格式化效果仍然不符合需求，你可以使用其他 JSON 格式化工具来处理 JSON 数据。以下是一些工具示例：

1. **`json-formatter`**: 使用第三方库来格式化 JSON 数据。
2. ****自定义格式化**：使用其他库或工具对 JSON 进行更细致的格式化。

### 使用 `json-formatter` 作为替代

一个常见的第三方工具是 `json-formatter`。你可以使用它来格式化 JSON 数据并生成漂亮的输出。以下是如何集成 `json-formatter` 的示例：

```java
import com.github.fge.jsonschema.core.exceptions.ProcessingException;
import com.github.fge.jsonschema.JsonSchema;
import com.github.fge.jsonschema.JsonSchemaFactory;
import com.github.fge.jsonschema.JsonSchemaGenerator;
import com.github.fge.jsonschema.JsonSchemaReader;
import com.github.fge.jsonschema.JsonSchemaValidator;
import com.github.fge.jsonschema.Schema;

import java.io.IOException;
import java.io.OutputStream;

@RestController
@RequestMapping("/api")
public class FileDownloadController {

    @GetMapping("/download")
    public void downloadJsonFile(HttpServletResponse response) throws IOException, ProcessingException {
        // 创建 JSON 对象
        ObjectNode jsonObject = new ObjectMapper().createObjectNode();
        jsonObject.put("name", "John Doe");
        jsonObject.put("age", 30);
        jsonObject.put("email", "john.doe@example.com");

        // 使用 json-formatter 工具格式化 JSON 数据
        String formattedJson = JsonFormatter.format(jsonObject.toString());

        // 设置响应内容类型和文件名
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setHeader(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=data.json");

        // 将格式化的 JSON 对象写入响应流
        try (OutputStream outputStream = response.getOutputStream()) {
            outputStream.write(formattedJson.getBytes());
            outputStream.flush();
        }
    }
}
```

### 总结

- 使用 Jackson 的 `DefaultPrettyPrinter` 可以自定义 JSON 格式化。
- 如果需要更高的格式化精度，可以使用第三方 JSON 格式化工具。
- 根据具体需求选择最适合的格式化工具和配置方式。

通过这些方法，你可以生成和返回格式化的 JSON 文件，确保 JSON 数据在浏览器中以漂亮的格式呈现。

# 15. fastJson中的JSONObject对象，我现在有一个需求，需要更改JSONObject对象中的某个字段值，将它从原来的值，统一转换为一个新的值，比如从原始的a统一修改为a11，请问FastJson有提供这种能力吗
在 Fastjson 中，你可以使用 `JSONObject` 来修改 JSON 对象的字段值。虽然 Fastjson 本身没有提供直接的功能来批量修改某个字段的所有值，但你可以通过遍历 JSON 对象和使用基本的替换逻辑来实现这个需求。

下面是如何使用 Fastjson 来修改 `JSONObject` 对象中的某个字段的值，从原来的值（例如 `a`）修改为新的值（例如 `a11`）的示例：

### 示例代码

```java
import com.alibaba.fastjson.JSONObject;

public class FastjsonReplaceExample {
    public static void main(String[] args) {
        // 创建示例 JSON 对象
        String jsonString = "{ \"name\": \"a\", \"age\": 30, \"address\": { \"street\": \"a\", \"city\": \"b\" } }";
        JSONObject jsonObject = JSONObject.parseObject(jsonString);

        // 打印原始 JSON 对象
        System.out.println("Original JSON: " + jsonObject.toJSONString());

        // 需要替换的旧值和新值
        String oldValue = "a";
        String newValue = "a11";

        // 修改 JSON 对象中的所有字段
        replaceFieldValues(jsonObject, oldValue, newValue);

        // 打印修改后的 JSON 对象
        System.out.println("Modified JSON: " + jsonObject.toJSONString());
    }

    private static void replaceFieldValues(JSONObject jsonObject, String oldValue, String newValue) {
        for (String key : jsonObject.keySet()) {
            Object value = jsonObject.get(key);
            if (value instanceof JSONObject) {
                // 递归处理嵌套的 JSONObject
                replaceFieldValues((JSONObject) value, oldValue, newValue);
            } else if (value instanceof String) {
                // 替换字段值
                String stringValue = (String) value;
                if (stringValue.equals(oldValue)) {
                    jsonObject.put(key, newValue);
                }
            }
        }
    }
}
```

### 解析

1. **创建 JSON 对象**：
   - 使用 `JSONObject.parseObject()` 方法将 JSON 字符串解析为 `JSONObject` 实例。

2. **打印原始 JSON**：
   - 打印原始的 JSON 对象，以便比较。

3. **替换字段值**：
   - 定义 `replaceFieldValues` 方法，该方法递归遍历 JSON 对象。
   - 如果值是 `JSONObject`，则递归调用 `replaceFieldValues` 方法。
   - 如果值是 `String`，则检查是否等于旧值，并替换为新值。

4. **打印修改后的 JSON**：
   - 打印修改后的 JSON 对象，以查看替换效果。

### 注意事项

- **递归处理**：示例代码中使用了递归来处理嵌套的 JSON 对象。对于更复杂的 JSON 结构，你可能需要进一步调整递归逻辑。
- **性能考虑**：对于大规模 JSON 对象，频繁的递归调用可能会影响性能。确保在实际应用中进行性能测试。

这种方法可以帮助你在 Fastjson 中批量修改 JSON 对象中的字段值，适应不同的 JSON 数据结构和替换需求。

# 16. jackson在序列化时，如何根据条件动态选择忽略哪些字段呢
在使用 Jackson 进行序列化时，可以通过自定义序列化器或使用 `@JsonView` 注解来根据条件动态选择忽略某些字段。以下是几种常见的方法：

### 方法 1: 使用 `@JsonView`

使用 `@JsonView` 可以根据不同的视图定义不同的字段进行序列化。你需要定义视图接口，并在模型类中使用这些视图。

```java
import com.fasterxml.jackson.annotation.JsonView;

public class User {
    public interface View {
        interface Public {}
        interface Internal extends Public {}
    }

    @JsonView(View.Public.class)
    private String username;

    @JsonView(View.Internal.class)
    private String password;

    // Getters and setters
}

// 在序列化时使用不同的视图
ObjectMapper mapper = new ObjectMapper();
User user = new User();
user.setUsername("user123");
user.setPassword("secret");

// 序列化为 Public 视图
String publicJson = mapper.writerWithView(User.View.Public.class).writeValueAsString(user);
// 结果: {"username":"user123"}

// 序列化为 Internal 视图
String internalJson = mapper.writerWithView(User.View.Internal.class).writeValueAsString(user);
// 结果: {"username":"user123","password":"secret"}
```

### 方法 2: 使用自定义序列化器

如果需要更复杂的逻辑，可以创建一个自定义序列化器，通过条件判断来选择要序列化的字段。

```java
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;

import java.io.IOException;

public class User {
    private String username;
    private String password;

    @JsonSerialize(using = CustomUserSerializer.class)
    public String getUsername() {
        return username;
    }

    public String getPassword() {
        return password;
    }
}

// 自定义序列化器
public class CustomUserSerializer extends JsonSerializer<String> {
    @Override
    public void serialize(String value, JsonGenerator gen, SerializerProvider serializers) throws IOException {
        if (someCondition()) {
            // 根据条件选择序列化
            gen.writeString(value);
        }
    }

    private boolean someCondition() {
        // 自定义条件
        return true; // 示例条件
    }
}
```

### 方法 3: 使用 `JsonNode`

还可以使用 `JsonNode` 和动态构建 JSON 对象的方式来实现条件序列化：

```java
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.util.HashMap;
import java.util.Map;

public class User {
    private String username;
    private String password;

    // Getters and setters
}

// 动态序列化
public static JsonNode serializeUser(User user, boolean includePassword) {
    ObjectMapper mapper = new ObjectMapper();
    Map<String, Object> userMap = new HashMap<>();
    userMap.put("username", user.getUsername());
    
    if (includePassword) {
        userMap.put("password", user.getPassword());
    }

    return mapper.valueToTree(userMap);
}

// 使用示例
User user = new User();
user.setUsername("user123");
user.setPassword("secret");

JsonNode jsonNode = serializeUser(user, false); // 不包含密码
```

选择适合你的具体需求的方法，可以灵活地控制 Jackson 在序列化时忽略的字段。

