---
layout:     post
title:      java读取文件
subtitle:   java读取文件的方式汇总
categories: [零散知识点]
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---

# 1. 加载文件离不开class和classLoader
在java中我们要加载文件，最常见的方式就是使用File去new一个文件对象，这样就能通过文件对象来操作磁盘上的目标文件资源。   
但这里面最核心的问题是，File file = new File(path); 中需要path。   
所有，最核心的问题就是如何获取到我们需要操作的目标文件的path。   
如果我们知道目标文件的绝对路径还好说，但是一般在工程中我们只知道目标文件的相对路径，而没法知道目标文件在磁盘上的绝对路径到底是啥。   
因此，我们需要对目标文件进行资源定位。   
java中对资源的定位，其底层都离不开classLoader。   
因为classLoader实际上就是负责向JVM内存中装载所有class以及其他相关资源的。   
可以认为，JVM中所有的东西都是通过classLoader装载进去的。   
同样，java中读取文件，文件也是资源的一种。   
因此，java定位文件资源也离不开classLoader。   

一般来说，定位文件经常使用两种方式，一种是通过class对象去做，一种是通过classLoader对象去做。   
下面我们分析下这两种方式。   

class和classLoader定位文件有和不同？   
创建一个LoaderUtils.java类：   
```java
package code08readfile;

import org.junit.Test;

import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.Enumeration;

public class LoaderUtils {

    @Test
    public void testLoader() {
        // Class方式加载资源底层实际上是对ClassLoader方式的封装。
        // class.getResource()方法返回一个URL对象。
        // 这个对象代表JVM内存中的一个资源标识。
        // 它本身只用于定位资源，这个资源可以是网络资源、IO资源、类资源等。
        // 我们此处要找的资源是一个文件。
        // /C:/D/zhaoehcode-java/springboot/target/classes/code08readfile/
        System.out.println(LoaderUtils.class.getResource(""));

        // /C:/D/zhaoehcode-java/springboot/target/classes/
        System.out.println(LoaderUtils.class.getResource("/"));

        // null
        System.out.println(LoaderUtils.class.getResource("test.loader"));

        // /C:/D/zhaoehcode-java/springboot/target/classes/test.loader
        System.out.println(LoaderUtils.class.getResource("/test.loader"));

        // /C:/D/zhaoehcode-java/springboot/target/classes/
        System.out.println(LoaderUtils.class.getClassLoader().getResource(""));

        // null
        System.out.println(LoaderUtils.class.getClassLoader().getResource("/"));

        // /C:/D/zhaoehcode-java/springboot/target/classes/test.loader
        System.out.println(LoaderUtils.class.getClassLoader().getResource("test.loader"));

        // null
        System.out.println(LoaderUtils.class.getClassLoader().getResource("/test.loader"));

    }

    // classLoader提供了getResource()方法返回classpath下匹配到的第一个目标资源；
    // 也提供了getResources()方法返回classpath下匹配到的所有目标资源。
    // 而class不提供getResources()方式。
    @Test
    public void testLoaderResources() throws IOException {
        // classLoader.getResource()：从classpath下返回目标资源，只返回匹配到的第一个目标资源，当前工程中的classpath下的文件优先被匹配返回。
        URL url = LoaderUtils.class.getClassLoader().getResource("test.loader");
        System.out.println(url);

        // classLoader.getResources()：从classpath下返回目标资源，所有匹配到的目标资源都被返回。
        // 比如当前工程中有test.loader文件，其他引入的jar包的classpath下也有test.loader文件，它会返回所有匹配到的资源。
        // 我们可以看到它返回的是一个url集合。
        Enumeration<URL> urls = LoaderUtils.class.getClassLoader().getResources("test.loader");
        System.out.println(urls.nextElement());
    }


    // class和classLoader的方式都提供直接返回目标文件流
    @Test
    public void testAsStream() {
        InputStream inputStream = LoaderUtils.class.getResourceAsStream("test.loader");

        inputStream = LoaderUtils.class.getClassLoader().getResourceAsStream("test.loader");
    }
}

```

通过上面的代码可以得出如下结论：   
（1）class.getResource()底层实际上使用的还是classLoader.getResource()；   
（2）class.getResource()如果传入""，则返回的是指向当前class所在包的绝对路径；如果传入"/"，则返回执行classpath的绝对路径。这意味着，使用class的getResource()，如果带"/"，就是从当前classpath下查找资源；如果不带"/"，就是从当前类所在包下查找资源。      
（3）classLoader.getResource()不支持带"/"，只要带"/"返回的就是null；不带"/"它直接从classpath下查找资源。   
（4）classLoader.getResource()获取classpath下匹配到的第一个目标资源；classLoader.getResources()获取classpath下匹配到的所有目标资源。      
（5）class和classLoader都提供getResourceAsStream()的方式直接返回目标资源流。这个特性特别重要，当我们把java工程打成jar包后，工程里面的资源文件就只能通过这种直接返回Stream的方式来处理，如果直接尝试读取一个file是找不到文件的，因为jar包里面的file说白了没有绝对的磁盘路径，因为我们直接通过class或者classLoader直接读取目标文件的Stream.         


# 2. 返回目标资源的绝对路径
传入一个文件路径，返回其对应的绝对路径。   
写一个工具类 PathManager .   

（1）直接传入一个绝对路径，则直接返回：
```java
    // 直接传入绝对路径，返回一个绝对路径
    public static String getPathFromAbsolutePath(String absolutePath) {
        return absolutePath;
    }
```

（2）使用spring的FileSystemResourceLoader，传入绝对路径，返回绝对路径：
```java
    // 使用spring的 FileSystemResourceLoader，传入绝对路径，返回绝对路径
    public static String getPathFromAbsolutePathUseFileSystemResourceLoader(String absolutePath) throws IOException {
        ResourceLoader resourceLoader = new FileSystemResourceLoader();
        Resource resource = resourceLoader.getResource(absolutePath);
        return resource.getURI().getPath();
    }
```

（3）使用ClassLoader返回绝对路径：
```java
    // 传入相对路径，使用classLoader返回绝对路径
    public static String getPathFromRelativePathUseClassLoader(String relativePath) throws FileNotFoundException {
        ClassLoader classLoader = FileManager.class.getClassLoader();
        URL resource = classLoader.getResource(relativePath);
        String absolutePathOfCurrentFile = resource.getFile();
        return absolutePathOfCurrentFile;
    }
```

（4）使用classLoader的toURI方法返回绝对路径：
```java
    // 传入相对路径，使用classLoader返回绝对路径
    public static String getPathFromRelativePathUseClassLoaderAsUri(String relativePath) throws URISyntaxException {
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        URL resource = classLoader.getResource(relativePath);
        URI uri = resource.toURI();
        return uri.getPath();
    }
```

（5）使用spring的DefaultResourceLoader返回绝对路径：
```java
    // 传入相对路径，使用spring的ResourceLoader返回绝对路径
    public static String getPathFromRelativePathUseResourceLoaderAsFile(String relativePath) throws IOException {
        ResourceLoader resourceLoader = new DefaultResourceLoader();
        Resource classPathResource = resourceLoader.getResource("classpath:" + relativePath);
        return classPathResource.getURI().getPath();
    }
```

（6）使用spring的DefaultResourceLoader，返回绝对路径
```java
    // 传入相对路径，使用spring的ResourceLoader返回绝对路径
    public static String getPathFromRelativePathUseResourceLoaderAsResourceFile(String relativePath) throws IOException {
        ResourceLoader resourceLoader = new DefaultResourceLoader();
        Resource resource = resourceLoader.getResource(relativePath);
        return resource.getURI().getPath();
    }
```

# 3. java根据文件路径返回一个文件对象
写一个File工具类 FileManager.

（1）传入绝对路径，获取file。   
方式1：直接传入一个磁盘的绝对路径文件，获取对应的file
```java
    // 直接传入绝对路径，返回一个file
    public static File readFileFromAbsolutePath(String absolutePath) {
        // 根据绝对路径，实例化一个file对象
        File file = new File(absolutePath);
        return file;
    }
```
方式2：可以使用spring提供的 FileSystemResourceLoader，传入一个绝对路径，去获取其对应的file对象
```java
    // 使用spring的 FileSystemResourceLoader，传入绝对路径，返回一个文件对象
    public static File readFileFromAbsolutePathUseFileSystemResourceLoader(String absolutePath) throws IOException {
        ResourceLoader resourceLoader = new FileSystemResourceLoader();
        Resource resource = resourceLoader.getResource(absolutePath);
        // 获取目标资源对应的磁盘文件
        File file = resource.getFile();
        return file;
    }
```

（2）传入相对路径，获取file。   
方式1：使用 ClassLoader 去获取相对路径文件的file。
```java
    // 直接传入相对路径（相对resources资源的路径）
    // 使用jdk提供的classLoader加载器进行加载
    public static File readFileFromRelativePathUseClassLoader(String relativePath) throws FileNotFoundException {
        // 获取当前class loader
        ClassLoader classLoader = FileManager.class.getClassLoader();
        // 根据classLoader获取当前资源文件的资源
        URL resource = classLoader.getResource(relativePath);
        // 获取当前资源文件的绝对路径
        String absolutePathOfCurrentFile = resource.getFile();
        File file = new File(absolutePathOfCurrentFile);
        return file;
    }
```
方式2：使用 ClassLoader 去获取相对路径文件的file。
```java
    // 直接传入相对路径（相对resources资源的路径）
    // 使用jdk提供的classLoader加载器进行加载
    public static File readFileFromRelativePathUseClassLoaderAsUri(String relativePath) throws URISyntaxException {
        // 通过线程的方式获取当前class loader，和上面获取class loader的方式差不多
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        // 根据classLoader获取当前资源文件的资源
        URL resource = classLoader.getResource(relativePath);
        URI uri = resource.toURI();
        File file = new File(uri);
        return file;
    }
```
方式3：使用spring的DefaultResourceLoader去获取相对路径的文件对象。
```java
    // 直接传入相对路径（相对resources资源的路径）
    // 使用spring提供的resourceLoader进行加载，底层还是使用的jdk的ClassLoader
    public static File readFileFromRelativePathUseResourceLoaderAsFile(String relativePath) throws IOException {
        ResourceLoader resourceLoader = new DefaultResourceLoader();
        Resource classPathResource = resourceLoader.getResource("classpath:" + relativePath);
        // 获取目标资源对应的磁盘文件
        File file = classPathResource.getFile();
        return file;
    }
```
方式4：使用spring的DefaultResourceLoader去获取相对路径的文件对象。
```java
    // 直接传入相对路径（相对resources资源的路径）
    // 使用spring提供的resourceLoader进行加载，底层还是使用的jdk的ClassLoader
    public static File readFileFromRelativePathUseResourceLoaderAsResourceFile(String relativePath) throws IOException {
        ResourceLoader resourceLoader = new DefaultResourceLoader();
        Resource resource = resourceLoader.getResource(relativePath);
        // 获取目标资源对应的磁盘文件
        File file = resource.getFile();
        return file;
    }
```

# 4. java直接读取磁盘文件返回文件流
读取磁盘文件，返回一个文件流，其实底层方式就一个，将磁盘上的文件直接转换成输入流就完事儿了。   
所以，不论下面提到的方式有多丰富，它的本质就是找到目标文件的绝对磁盘路径，然后将其转换为Stream。   
java读取所有文件，首先都是要将文件转化为一个Stream，然后再看是什么文件，再做对应处理。   
比如json文件，xml文件，properties文件，yml文件等，都有各自的解析方式，但是，最根本的是首先需要将文件读取到InputStream中，才能做后续的动作。   
编写一个Stream工具类，结合上面获取文件的方式统一获取Stream.   
```java
package code08readfile;

import org.springframework.core.io.DefaultResourceLoader;
import org.springframework.core.io.FileSystemResourceLoader;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;

import java.io.*;
import java.net.URISyntaxException;
import java.net.URL;

// stream流工具类,直接操作底层文件返回文件流
// 下面封装了好多种方式，其实底层原理都使用的是Class Loader的方式去加载的文件资源
public class StreamManager {

    // 直接传入绝对路径
    public static InputStream readStreamFromAbsolutePath(String absolutePath) throws FileNotFoundException {
        // 根据绝对路径，实例化一个file对象
        File file = FileManager.readFileFromAbsolutePath(absolutePath);
        // 将磁盘上的file文件转换为输入流并返回
        return new FileInputStream(file);
    }
    
    

    // 直接传入相对路径（相对resources资源的路径）
    // 使用spring的 FileSystemResourceLoader
    public static InputStream readStreamFromRelativePathUseResourceLoaderAsFileSystemResource(String relativePath) throws IOException {
        File file = FileManager.readFileFromAbsolutePathUseFileSystemResourceLoader(relativePath);
        return new FileInputStream(file);
    }
    
    

    // 直接传入相对路径（相对resources资源的路径）
    public static InputStream readStreamFromRelativePathUseClassLoader(String relativePath) throws FileNotFoundException {
        File file = FileManager.readFileFromRelativePathUseClassLoader(relativePath);
        return new FileInputStream(file);
    }
    
    

    // 直接传入相对路径（相对resources资源的路径）
    public static InputStream readStreamFromRelativePathUseClassLoaderAsUri(String relativePath) throws FileNotFoundException, URISyntaxException {
        File file = FileManager.readFileFromRelativePathUseClassLoaderAsUri(relativePath);
        return new FileInputStream(file);
    }
    
    

    // 直接传入相对路径（相对resources资源的路径）
    // 使用jdk提供的classLoader加载器进行加载
    public static InputStream readStreamFromRelativePathUseClassLoaderAsOpenStream(String relativePath) throws IOException {
        // 获取当前class loader
        ClassLoader classLoader = FileManager.class.getClassLoader();
        // 根据classLoader获取当前资源文件的资源
        URL resource = classLoader.getResource(relativePath);
        // url的openStream直接返回流
        return resource.openStream();
    }
    
    

    // 直接传入相对路径（相对resources资源的路径）
    // 使用jdk提供的classLoader加载器进行加载
    public static InputStream readStreamFromRelativePathUseClassLoaderAsStream(String relativePath) {
        // 获取当前class loader
        ClassLoader classLoader = FileManager.class.getClassLoader();
        // 直接通过classLoader返回目标资源流
        return classLoader.getResourceAsStream(relativePath);
    }
    
    

    // 直接传入相对路径（相对resources资源的路径）
    // 使用spring提供的resourceLoader进行加载，底层还是使用的jdk的ClassLoader
    public static InputStream readStreamFromRelativePathUseResourceLoader(String relativePath) throws IOException {
        ResourceLoader resourceLoader = new DefaultResourceLoader();
        Resource classPathResource = resourceLoader.getResource("classpath:" + relativePath);
        InputStream inputStream = classPathResource.getInputStream();
        return inputStream;
    }
    
    

    // 直接传入相对路径（相对resources资源的路径）
    public static InputStream readStreamFromRelativePathUseResourceLoaderAsFile(String relativePath) throws IOException {
        File file = FileManager.readFileFromRelativePathUseResourceLoaderAsFile(relativePath);
        return new FileInputStream(file);
    }
    
    

    // 直接传入相对路径（相对resources资源的路径）
    // 使用spring提供的resourceLoader进行加载，底层还是使用的jdk的ClassLoader
    public static InputStream readStreamFromRelativePathUseResourceLoaderAsResourceStream(String relativePath) throws IOException {
        ResourceLoader resourceLoader = new DefaultResourceLoader();
        Resource resource = resourceLoader.getResource(relativePath);
        return resource.getInputStream();
    }
    
    

    // 直接传入相对路径（相对resources资源的路径）
    // 使用spring提供的resourceLoader进行加载，底层还是使用的jdk的ClassLoader
    public static InputStream readStreamFromRelativePathUseResourceLoaderAsResourceFile(String relativePath) throws IOException {
        File file = FileManager.readFileFromRelativePathUseResourceLoaderAsResourceFile(relativePath);
        return new FileInputStream(file);
    }
    


    // 直接传入相对路径（相对resources资源的路径）
    // 使用spring的 FileSystemResourceLoader
    public static InputStream readStreamFromRelativePathUseResourceLoaderAsFileSystemResourceStream(String relativePath) throws IOException {
        ResourceLoader resourceLoader = new FileSystemResourceLoader();
        Resource resource = resourceLoader.getResource(relativePath);
        return resource.getInputStream();
    }
}

```

# 5. java读取json文件
下面看看具体如何读取Json文件。   
读取json文件说白了就是要把文件流或者直接把文件转换成json字符串，要使用到上面封装的两个类。    
（1）使用纯java的方式将stream转换为json字符串   
```java
    public static String readJsonFile(String filePath) {
        String jsonStr = "";
        try {
            InputStream inputStream = StreamManager.readStreamFromRelativePathUseClassLoader(filePath);
            // 根据文件绝对路径创建一个File对象
            // 根据文件对象包装一个Reader流
            Reader reader = new InputStreamReader(inputStream, "utf-8");
            int ch;
            // 创建一个StringBuffer对象
            StringBuffer stringBuffer = new StringBuffer();
            // 从reader中遍历读取数据，然后拼接到StringBuffer中
            while ((ch = reader.read()) != -1) {
                stringBuffer.append((char) ch);
            }
            reader.close();
            jsonStr = stringBuffer.toString();
            return jsonStr;
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }
```   

（2）使用apache common的方式将stream转换json字符串
```java
    public static String readJsonFromFile(String fileName) throws IOException {
        InputStream inputStream = StreamManager.readStreamFromRelativePathUseResourceLoader(fileName);
        // 使用apache common的公共包方便地将inputStream转换为String
        return IOUtils.toString(inputStream, StandardCharsets.UTF_8);
    }
```

（3）使用apache common包的FileUtils将file转换为json字符串
```java
    public static String loadFileFromPath(String filePath) throws IOException {
        File file = FileManager.readFileFromRelativePathUseResourceLoaderAsResourceFile(filePath);
        return FileUtils.readFileToString(file, StandardCharsets.UTF_8);
    }
```

（4）使用apache common包的FileUtils，多转了几手将file转换为json字符串
```java
    public static String readJsonToBeString(String filePath) throws IOException {
        FileInputStream fileInputStream = null;
        String fileContent = "";
        File file = FileManager.readFileFromRelativePathUseResourceLoaderAsResourceFile(filePath);
        try {
            fileInputStream = FileUtils.openInputStream(file);
            fileContent = IOUtils.toString(fileInputStream, StandardCharsets.UTF_8);
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fileInputStream != null) {
                try {
                    fileInputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        return fileContent;
    }
```

（5）使用nio将file转换为json字符串
```java
    public static String readFileContent(String filePath) {
        try {
            File file = FileManager.readFileFromRelativePathUseClassLoaderAsUri(filePath);
            return new String(Files.readAllBytes(file.toPath()), StandardCharsets.UTF_8.toString());
        } catch (URISyntaxException | IOException e) {
            return null;
        }
    }
```

（6）使用jackson将file转换为json字符串
```java
    public static String readFileAsJsonString(String filePath) throws IOException {
        File file = FileManager.readFileFromRelativePathUseClassLoader(filePath);
        ObjectMapper objectMapper = new ObjectMapper();
        Map jsonMap = objectMapper.readValue(file, Map.class);
        String jsonString = objectMapper.writeValueAsString(jsonMap);
        return jsonString;
    }
```