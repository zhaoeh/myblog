---
layout:     post
title:      分库分表
subtitle:   分库分表
categories: [gpt]
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---

# 1. springboot启动后，有没有可能哪些对象长期不使用会被自动gc？比如动态数据源中引用的真实数据源，由于写法有问题，一天不操作就会被当做垃圾对象回收了？
在Spring Boot应用中，如果某些对象长期不使用而被自动垃圾回收，这通常是因为这些对象不再被引用。Java垃圾回收器（GC）会回收那些没有活动引用的对象。具体到动态数据源的问题，如果动态数据源中引用的真实数据源对象一天不操作就被回收了，这可能是因为这些对象的引用没有被适当地保持。

### 常见原因及解决方案

1. **没有持久引用**：
   如果你的动态数据源对象没有被持久化引用，它们会被GC回收。例如，如果动态数据源对象被局部变量持有，当方法执行完毕后这些对象就会被回收。

   **解决方案**：确保这些对象有一个持久的引用，例如，将它们存储在一个静态变量或单例Bean中。

2. **不在Spring管理下**：
   如果你没有使用Spring管理这些动态数据源，它们可能会在不再被引用时被GC回收。

   **解决方案**：确保所有动态数据源都在Spring上下文中进行管理，使用`@Bean`或`@Component`等注解来声明。

3. **动态数据源管理不当**：
   如果你的动态数据源管理机制有问题，例如，没有正确地将动态数据源对象存储在一个持久的容器中，这些对象也可能会被回收。

   **解决方案**：检查你的动态数据源管理代码，确保每个数据源对象都被正确引用和管理。

### 示例代码

以下是一个如何在Spring上下文中管理动态数据源的示例：

```java
@Configuration
public class DataSourceConfig {

    private Map<String, DataSource> dataSourceMap = new HashMap<>();

    @Bean
    @Primary
    public DataSource dataSource() {
        return new AbstractRoutingDataSource() {
            @Override
            protected Object determineCurrentLookupKey() {
                return DynamicDataSourceContextHolder.getDataSourceKey();
            }

            @Override
            protected DataSource determineTargetDataSource() {
                String dataSourceKey = determineCurrentLookupKey().toString();
                return dataSourceMap.get(dataSourceKey);
            }
        };
    }

    public void addDataSource(String key, DataSource dataSource) {
        dataSourceMap.put(key, dataSource);
    }
}
```

在上述示例中，`dataSourceMap`保存了所有动态数据源的引用，确保它们不会被GC回收。

### 结论

要防止对象被GC回收，你需要确保这些对象被持久化引用。如果你在使用动态数据源，请确保它们被适当地管理，并且所有的引用都不会在不使用时被丢弃。这样可以防止这些对象被Java垃圾回收器回收。

# 2. 那些不恰当的编码导致真实数据源被回收，能否各自给一个案例
以下是一些不恰当的编码示例，这些示例可能导致真实数据源对象在长期不使用时被GC回收：

### 示例1：局部变量引用
如果真实数据源对象仅被局部变量引用，当方法结束时，这些局部变量会被回收，从而导致真实数据源对象被GC回收。

```java
public class DynamicDataSource {

    public void addDataSource(String key, DataSource dataSource) {
        // 这是一个局部变量，方法结束后将被回收
        Map<String, DataSource> dataSourceMap = new HashMap<>();
        dataSourceMap.put(key, dataSource);
    }

    public DataSource getDataSource(String key) {
        // 再次创建的局部变量，没有保存之前的数据源
        Map<String, DataSource> dataSourceMap = new HashMap<>();
        return dataSourceMap.get(key);
    }
}
```

### 解决方案
应将`dataSourceMap`作为类的成员变量以保持持久引用：

```java
public class DynamicDataSource {

    private Map<String, DataSource> dataSourceMap = new HashMap<>();

    public void addDataSource(String key, DataSource dataSource) {
        dataSourceMap.put(key, dataSource);
    }

    public DataSource getDataSource(String key) {
        return dataSourceMap.get(key);
    }
}
```

### 示例2：未在Spring管理下
如果真实数据源对象未在Spring上下文中进行管理，它们可能会被GC回收。

```java
public class DynamicDataSource {

    private static final Map<String, DataSource> dataSourceMap = new HashMap<>();

    public void addDataSource(String key, DataSource dataSource) {
        dataSourceMap.put(key, dataSource);
    }

    public DataSource getDataSource(String key) {
        return dataSourceMap.get(key);
    }
}
```

在这个例子中，虽然数据源被保存到了静态变量中，但如果没有被Spring管理，当应用程序的其他部分不再引用这些数据源时，它们仍然可能被回收。

### 解决方案
使用Spring管理数据源：

```java
@Configuration
public class DataSourceConfig {

    private Map<String, DataSource> dataSourceMap = new HashMap<>();

    @Bean
    @Primary
    public DataSource dataSource() {
        return new AbstractRoutingDataSource() {
            @Override
            protected Object determineCurrentLookupKey() {
                return DynamicDataSourceContextHolder.getDataSourceKey();
            }

            @Override
            protected DataSource determineTargetDataSource() {
                String dataSourceKey = determineCurrentLookupKey().toString();
                return dataSourceMap.get(dataSourceKey);
            }
        };
    }

    public void addDataSource(String key, DataSource dataSource) {
        dataSourceMap.put(key, dataSource);
    }
}
```

### 示例3：弱引用使用不当
如果使用了弱引用（WeakReference）来引用数据源对象，当GC运行时，这些对象很可能会被回收。

```java
public class DynamicDataSource {

    private Map<String, WeakReference<DataSource>> dataSourceMap = new HashMap<>();

    public void addDataSource(String key, DataSource dataSource) {
        dataSourceMap.put(key, new WeakReference<>(dataSource));
    }

    public DataSource getDataSource(String key) {
        WeakReference<DataSource> weakRef = dataSourceMap.get(key);
        return (weakRef != null) ? weakRef.get() : null;
    }
}
```

### 解决方案
使用强引用而不是弱引用来保存数据源对象：

```java
public class DynamicDataSource {

    private Map<String, DataSource> dataSourceMap = new HashMap<>();

    public void addDataSource(String key, DataSource dataSource) {
        dataSourceMap.put(key, dataSource);
    }

    public DataSource getDataSource(String key) {
        return dataSourceMap.get(key);
    }
}
```

通过上述调整，确保数据源对象不会因不当的引用管理而被GC回收。

# 3. 有没有可能是因为在通过@bean创建数据源对象时，类上面没有标注@configuration导致的？
确实，有可能是因为在通过`@Bean`创建数据源对象时，类上没有标注`@Configuration`导致的。这会使得Spring无法正确管理这些Bean，从而可能导致数据源对象没有被持久引用，最终被垃圾回收。

### 示例

以下是一个没有使用`@Configuration`注解的错误示例：

```java
public class DataSourceConfig {

    @Bean
    public DataSource dataSource() {
        // 配置数据源
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/mydb");
        dataSource.setUsername("user");
        dataSource.setPassword("password");
        return dataSource;
    }
}
```

在这个例子中，由于`DataSourceConfig`类没有标注`@Configuration`，Spring不会自动扫描并管理这个类中的`@Bean`方法，因此`dataSource`不会被Spring容器管理。

### 解决方案

正确的做法是将类标注为`@Configuration`，以便Spring能够识别并管理其中的`@Bean`方法：

```java
@Configuration
public class DataSourceConfig {

    @Bean
    public DataSource dataSource() {
        // 配置数据源
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/mydb");
        dataSource.setUsername("user");
        dataSource.setPassword("password");
        return dataSource;
    }
}
```

### 其他可能的配置错误

1. **没有启用组件扫描**：
   确保你的Spring Boot应用程序启用了组件扫描。如果组件扫描没有正确配置，Spring可能不会扫描到你的配置类。

   ```java
   @SpringBootApplication
   public class MyApplication {
       public static void main(String[] args) {
           SpringApplication.run(MyApplication.class, args);
       }
   }
   ```

2. **配置类不在扫描范围内**：
   确保你的配置类位于Spring Boot应用程序包或其子包下，这样Spring Boot的组件扫描机制才能找到并注册它们。

3. **Bean作用域不正确**：
   确保你的数据源Bean是单例的，默认情况下，Spring的`@Bean`方法创建的Bean是单例的。如果你显式设置了其他作用域，例如`@Scope("prototype")`，每次调用`dataSource()`方法时都会创建一个新的实例，这可能会导致引用问题。

   ```java
   @Configuration
   public class DataSourceConfig {

       @Bean
       @Scope("singleton") // 确保是单例作用域
       public DataSource dataSource() {
           // 配置数据源
           HikariDataSource dataSource = new HikariDataSource();
           dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/mydb");
           dataSource.setUsername("user");
           dataSource.setPassword("password");
           return dataSource;
       }
   }
   ```

通过确保配置类正确标注为`@Configuration`，并遵循Spring的最佳实践，可以避免数据源对象由于不当的引用管理而被垃圾回收。

# 4. 请详细解释下局部变量引用的动态数据源问题
局部变量引用的问题在于，当方法执行完毕后，局部变量会被销毁。如果你在方法内部创建并引用一个动态数据源对象，而没有将其保存在一个持久的引用中（例如类的成员变量或Spring上下文中），那么这些对象在方法结束后可能会被垃圾回收。

### 示例：局部变量引用动态数据源

#### 不当的实现方式

下面是一个不正确的示例，动态数据源对象仅被局部变量引用：

```java
public class DynamicDataSourceManager {

    public void addDataSource(String key, DataSource dataSource) {
        // dataSourceMap是局部变量，方法结束后将被回收
        Map<String, DataSource> dataSourceMap = new HashMap<>();
        dataSourceMap.put(key, dataSource);
    }

    public DataSource getDataSource(String key) {
        // 新创建的局部变量，没有保存之前的数据源
        Map<String, DataSource> dataSourceMap = new HashMap<>();
        return dataSourceMap.get(key);
    }
}
```

在上面的代码中，每次调用`addDataSource`或`getDataSource`方法时，都会创建一个新的`dataSourceMap`局部变量。这样，之前存储的动态数据源对象无法被持久引用，当方法结束后这些对象就可能被垃圾回收。

#### 解决方案：使用持久引用

要解决这个问题，需要将动态数据源对象保存在一个持久引用中，例如类的成员变量：

```java
public class DynamicDataSourceManager {

    // 使用类的成员变量来持久化保存数据源对象
    private Map<String, DataSource> dataSourceMap = new HashMap<>();

    public void addDataSource(String key, DataSource dataSource) {
        dataSourceMap.put(key, dataSource);
    }

    public DataSource getDataSource(String key) {
        return dataSourceMap.get(key);
    }
}
```

在这个修正的例子中，`dataSourceMap`是一个类的成员变量（实例变量），它在`DynamicDataSourceManager`对象的生命周期内存在。这确保了数据源对象在添加之后不会因为方法结束而被垃圾回收。

### 示例：结合Spring管理动态数据源

为了进一步确保数据源对象的管理，可以将动态数据源管理器和数据源对象交给Spring管理：

```java
@Configuration
public class DataSourceConfig {

    private Map<String, DataSource> dataSourceMap = new HashMap<>();

    @Bean
    @Primary
    public DataSource dataSource() {
        return new AbstractRoutingDataSource() {
            @Override
            protected Object determineCurrentLookupKey() {
                return DynamicDataSourceContextHolder.getDataSourceKey();
            }

            @Override
            protected DataSource determineTargetDataSource() {
                String dataSourceKey = determineCurrentLookupKey().toString();
                return dataSourceMap.get(dataSourceKey);
            }
        };
    }

    public void addDataSource(String key, DataSource dataSource) {
        dataSourceMap.put(key, dataSource);
    }
}
```

在这个例子中，`DataSourceConfig`类使用了`@Configuration`注解，确保Spring能够管理这个类并识别其中的`@Bean`方法。`dataSourceMap`被定义为类的成员变量，用于持久化保存所有数据源对象。`addDataSource`方法允许动态添加数据源，而`dataSource`方法则返回一个动态路由的数据源对象。

### 关键点总结

1. **局部变量的生命周期**：
   - 局部变量的生命周期仅限于方法的执行周期，当方法结束后，这些变量会被销毁。
   - 如果动态数据源对象只被局部变量引用，当方法结束后，这些对象也会被GC回收。

2. **持久引用**：
   - 将动态数据源对象存储在类的成员变量或Spring上下文中，以确保它们在整个应用程序运行期间存在。

3. **Spring管理**：
   - 使用Spring管理动态数据源，通过`@Configuration`和`@Bean`注解，让Spring负责管理Bean的生命周期，确保数据源对象不会被意外回收。

通过正确的引用管理和Spring的Bean管理机制，可以确保动态数据源对象在应用程序的整个生命周期内都能正常使用。

# 5. 我的代码中是这样的:一个@bean标注的方法，返回一个Datasource对象，实际上是个DynamicDatasource对象。然后这个方法内部，创建了一个map，map中存储了@bean标注的真实的Datasource对象
明白了，你描述的场景是一个方法标注了`@Bean`，返回一个`DataSource`对象（实际上是一个`DynamicDataSource`对象），而在这个方法内部创建了一个`Map`来存储多个真实的`DataSource`对象。如果这个`Map`是一个局部变量，它会在方法结束时被销毁，从而导致其中存储的真实数据源对象没有持久引用而被GC回收。

### 示例代码及问题分析

#### 不正确的实现方式

```java
@Configuration
public class DataSourceConfig {

    @Bean
    public DataSource dynamicDataSource() {
        // 局部变量Map
        Map<String, DataSource> dataSourceMap = new HashMap<>();
        
        // 创建并存储真实的DataSource对象
        DataSource dataSource1 = createDataSource("jdbc:mysql://localhost:3306/db1", "user1", "password1");
        DataSource dataSource2 = createDataSource("jdbc:mysql://localhost:3306/db2", "user2", "password2");
        
        dataSourceMap.put("db1", dataSource1);
        dataSourceMap.put("db2", dataSource2);
        
        // 创建并返回DynamicDataSource对象
        DynamicDataSource dynamicDataSource = new DynamicDataSource();
        dynamicDataSource.setTargetDataSources(dataSourceMap);
        return dynamicDataSource;
    }

    private DataSource createDataSource(String url, String username, String password) {
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setJdbcUrl(url);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        return dataSource;
    }
}
```

在这个例子中，`dataSourceMap`是一个局部变量，仅在`dynamicDataSource`方法的执行期间存在。方法结束后，这个`Map`会被销毁，导致其中存储的`DataSource`对象没有持久引用，从而可能被GC回收。

### 解决方案

#### 方法一：使用成员变量持久化存储数据源对象

将`dataSourceMap`作为类的成员变量，以持久化保存这些数据源对象：

```java
@Configuration
public class DataSourceConfig {

    private Map<String, DataSource> dataSourceMap = new HashMap<>();

    @Bean
    public DataSource dynamicDataSource() {
        // 配置并存储真实的DataSource对象
        DataSource dataSource1 = createDataSource("jdbc:mysql://localhost:3306/db1", "user1", "password1");
        DataSource dataSource2 = createDataSource("jdbc:mysql://localhost:3306/db2", "user2", "password2");
        
        dataSourceMap.put("db1", dataSource1);
        dataSourceMap.put("db2", dataSource2);
        
        // 创建并返回DynamicDataSource对象
        DynamicDataSource dynamicDataSource = new DynamicDataSource();
        dynamicDataSource.setTargetDataSources(dataSourceMap);
        return dynamicDataSource;
    }

    private DataSource createDataSource(String url, String username, String password) {
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setJdbcUrl(url);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        return dataSource;
    }
}
```

在这个修正的例子中，`dataSourceMap`被声明为类的成员变量，因此这些数据源对象在`DataSourceConfig`类的整个生命周期内都存在，不会被GC回收。

#### 方法二：使用Spring的Bean管理

将每个真实的数据源对象都定义为一个Spring Bean，并将它们注入到`DynamicDataSource`中：

```java
@Configuration
public class DataSourceConfig {

    @Bean
    public DataSource dataSource1() {
        return createDataSource("jdbc:mysql://localhost:3306/db1", "user1", "password1");
    }

    @Bean
    public DataSource dataSource2() {
        return createDataSource("jdbc:mysql://localhost:3306/db2", "user2", "password2");
    }

    @Bean
    public DataSource dynamicDataSource(@Qualifier("dataSource1") DataSource dataSource1,
                                        @Qualifier("dataSource2") DataSource dataSource2) {
        Map<String, DataSource> dataSourceMap = new HashMap<>();
        dataSourceMap.put("db1", dataSource1);
        dataSourceMap.put("db2", dataSource2);
        
        DynamicDataSource dynamicDataSource = new DynamicDataSource();
        dynamicDataSource.setTargetDataSources(dataSourceMap);
        return dynamicDataSource;
    }

    private DataSource createDataSource(String url, String username, String password) {
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setJdbcUrl(url);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        return dataSource;
    }
}
```

在这个例子中，每个真实的数据源对象都被定义为一个Spring Bean (`dataSource1`和`dataSource2`)。`dynamicDataSource`方法使用`@Qualifier`注解来注入这些Bean，并将它们存储在一个局部变量中。由于这些数据源对象由Spring管理，它们不会被GC回收。

通过确保数据源对象被持久引用或由Spring管理，可以避免因局部变量引用导致的对象被GC回收的问题。

# 6. 你的方式2中，map也是一个局部变量啊，为啥不会被回收
你提到的方式2中，虽然`Map<String, DataSource>`是一个局部变量，但问题的关键在于这个`Map`最终被设置到`DynamicDataSource`对象中，而这个`DynamicDataSource`对象本身是由Spring管理的Bean，因此不会被回收。下面详细解释这种情况下对象的生命周期管理。

### 详细解释

#### Spring Bean的生命周期

Spring管理的Bean，其生命周期由Spring容器控制，只要容器存在，这些Bean对象就不会被垃圾回收。无论是`DynamicDataSource`还是它所引用的`Map`，只要它们被Spring管理并且有持久的引用链，就不会被GC回收。

### 示例：Spring管理的数据源对象

```java
@Configuration
public class DataSourceConfig {

    @Bean
    public DataSource dataSource1() {
        return createDataSource("jdbc:mysql://localhost:3306/db1", "user1", "password1");
    }

    @Bean
    public DataSource dataSource2() {
        return createDataSource("jdbc:mysql://localhost:3306/db2", "user2", "password2");
    }

    @Bean
    public DataSource dynamicDataSource(@Qualifier("dataSource1") DataSource dataSource1,
                                        @Qualifier("dataSource2") DataSource dataSource2) {
        Map<String, DataSource> dataSourceMap = new HashMap<>();
        dataSourceMap.put("db1", dataSource1);
        dataSourceMap.put("db2", dataSource2);
        
        DynamicDataSource dynamicDataSource = new DynamicDataSource();
        dynamicDataSource.setTargetDataSources(dataSourceMap);
        return dynamicDataSource;
    }

    private DataSource createDataSource(String url, String username, String password) {
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setJdbcUrl(url);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        return dataSource;
    }
}
```

### 关键点解析

1. **`@Bean`定义的数据源**：
   - `dataSource1`和`dataSource2`都是由Spring容器管理的Bean，它们的生命周期由Spring容器控制，不会被GC回收。

2. **`dynamicDataSource`方法中的局部变量`Map`**：
   - 虽然`dataSourceMap`是`dynamicDataSource`方法中的局部变量，但它被传递给了`DynamicDataSource`的`setTargetDataSources`方法。
   - `DynamicDataSource`对象同样是由Spring管理的Bean，因此`dataSourceMap`作为`DynamicDataSource`的内部引用，也不会被GC回收。

3. **引用链**：
   - Spring容器持有`DynamicDataSource`的引用，`DynamicDataSource`持有`dataSourceMap`的引用，`dataSourceMap`持有`dataSource1`和`dataSource2`的引用。
   - 这种引用链确保了所有相关对象在Spring容器存活期间都不会被垃圾回收。

### 更深入的理解

#### 内存管理和GC

Java的垃圾回收机制会回收所有没有持久引用的对象。在这种场景下，只要存在一个从根对象（Root Object）到目标对象的引用链，目标对象就不会被GC回收。

#### Spring的管理

Spring管理的Bean对象，其生命周期是由Spring容器控制的。Spring容器会确保所有被管理的Bean对象及其引用在整个容器的生命周期内保持有效，除非显式地销毁这些Bean。

### 总结

通过使用Spring管理数据源对象，并将这些对象的引用链包含在Spring管理的Bean中，确保了所有相关对象在Spring容器的生命周期内都不会被GC回收。即使局部变量`dataSourceMap`在方法结束后被销毁，存储在其中的实际数据源对象由于被`DynamicDataSource`对象持有引用而不会被回收。

# 7. 你仔细和你前面的错误示例比较一下，我觉得你只是将真实数据源交给spring管理了，但是dynamicDatasource始终都是spring在管理的
你说得对。无论在错误示例还是在解决方案中，`DynamicDataSource`都是由Spring管理的。因此，核心问题在于如何确保`DynamicDataSource`内部的`Map`中的数据源不会因为引用问题而被GC回收。

关键在于`DynamicDataSource`内部的引用管理。以下是进一步优化和详细解释：

### 原错误示例

```java
@Configuration
public class DataSourceConfig {

    @Bean
    public DataSource dynamicDataSource() {
        // 局部变量Map
        Map<String, DataSource> dataSourceMap = new HashMap<>();
        
        // 创建并存储真实的DataSource对象
        DataSource dataSource1 = createDataSource("jdbc:mysql://localhost:3306/db1", "user1", "password1");
        DataSource dataSource2 = createDataSource("jdbc:mysql://localhost:3306/db2", "user2", "password2");
        
        dataSourceMap.put("db1", dataSource1);
        dataSourceMap.put("db2", dataSource2);
        
        // 创建并返回DynamicDataSource对象
        DynamicDataSource dynamicDataSource = new DynamicDataSource();
        dynamicDataSource.setTargetDataSources(dataSourceMap);
        return dynamicDataSource;
    }

    private DataSource createDataSource(String url, String username, String password) {
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setJdbcUrl(url);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        return dataSource;
    }
}
```

在这个示例中，`dataSourceMap`确实是一个局部变量，但它被设置到`DynamicDataSource`中。`DynamicDataSource`由Spring管理，因此不会被GC回收。然而，如果`DynamicDataSource`类本身没有正确管理内部`Map`的引用，这可能会导致问题。

### 更好的实现方式

以下是确保`DynamicDataSource`内部正确管理引用的实现方式：

```java
@Configuration
public class DataSourceConfig {

    @Bean
    public DataSource dataSource1() {
        return createDataSource("jdbc:mysql://localhost:3306/db1", "user1", "password1");
    }

    @Bean
    public DataSource dataSource2() {
        return createDataSource("jdbc:mysql://localhost:3306/db2", "user2", "password2");
    }

    @Bean
    public DataSource dynamicDataSource(@Qualifier("dataSource1") DataSource dataSource1,
                                        @Qualifier("dataSource2") DataSource dataSource2) {
        Map<String, DataSource> dataSourceMap = new HashMap<>();
        dataSourceMap.put("db1", dataSource1);
        dataSourceMap.put("db2", dataSource2);
        
        DynamicDataSource dynamicDataSource = new DynamicDataSource();
        dynamicDataSource.setTargetDataSources(dataSourceMap);
        dynamicDataSource.afterPropertiesSet();  // 确保初始化完成
        return dynamicDataSource;
    }

    private DataSource createDataSource(String url, String username, String password) {
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setJdbcUrl(url);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        return dataSource;
    }
}
```

### `DynamicDataSource` 实现

确保`DynamicDataSource`类正确处理引用：

```java
public class DynamicDataSource extends AbstractRoutingDataSource {

    @Override
    protected Object determineCurrentLookupKey() {
        return DynamicDataSourceContextHolder.getDataSourceKey();
    }

    @Override
    public void setTargetDataSources(Map<Object, Object> targetDataSources) {
        super.setTargetDataSources(targetDataSources);
        super.afterPropertiesSet();  // 确保设置完成后初始化
    }
}
```

### 关键点总结

1. **局部变量的生命周期**：
   - 局部变量的生命周期仅限于方法的执行周期，但它们可以将内部对象引用传递给持久对象，从而延长这些内部对象的生命周期。

2. **Spring Bean管理**：
   - Spring管理的Bean（如`DynamicDataSource`）在Spring容器的生命周期内不会被GC回收。
   - 通过`@Bean`方法返回的`DataSource`对象被Spring容器管理，不会被回收。

3. **引用管理**：
   - `DynamicDataSource`内部的`Map`应该通过Spring注入的方式持久化存储数据源对象。
   - 确保`DynamicDataSource`对象内部正确初始化和持久化其引用对象，避免GC问题。

通过这种方式，我们确保数据源对象在Spring容器的管理下不会被GC回收，即使在`dynamicDataSource`方法中创建的是局部变量`Map`，因为这些对象的引用最终保存在由Spring管理的`DynamicDataSource`对象中。

