---
layout:     post
title:      rabbitMQ 架构简介
subtitle:   对rabbitMQ的理论知识做简单介绍
categories: [rabbitMQ]
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---

# 1. 消息队列？
消息队列（MQ，Message Queue），全称是Message Queue，很直白。   
是一种应用程序和应用程序进行消息通信的中间件。   
说白了就是在引用之间放置一个消息中间件，然后应用双方通过这个中间件进行消息通信。   

为啥平白无故的要放一个消息中间件呢？   
一般来说，小系统是不需要使用消息中间件的，只有分布式系统才会引入消息中间件，因为分布式系统需要应对高并发。   
在分布式系统中，一般会面临三个问题：解耦、异步、削峰。   
分布式系统需要多个系统之间解耦，也需要对用户比较友好的响应速度，更需要系统之间异步响应。   
而消息中间件天然对各个应用系统之间进行解耦、异步发送消息和消费消息、并且通过队列缓存消息可以起到削峰填谷的作用。   
因此，消息中间件可以完美的解决上面的三个问题。   

然万物抱阳负阴，系统之间突然加了个中间件，提高系统复杂度的同时也增加了很多问题：   
消息丢失怎么办？   
消息重复消费怎么办？   
某些任务需要消息的顺序消息，顺序消费怎么保证？   
消息队列组件的可用性如何保证？   
这些都是使用消息队列过程中需要思考需要考虑的地方，消息队列能给你带来很大的便利，也能给你带来一些对应的麻烦。   

上面都是引入消息中间件后需要考虑的问题，后续文章会逐步分析。   

# 2. RabbitMQ概览
RabbitMQ是一个消息组件，是一个通过erLang语言开发的AMQP(Advanced Message Queue)的开源实现。   
RabbitMQ服务端使用ErLang语言实现，支持多种客户端。用于在分布式系统中存储转发信息，在易用性，扩展性，高可用性等方面表现不俗，消息队列是一种在应用系统之间进行通信的方法，是通过读写如队列的信息来通信，而RPC是直接调用彼此应用系统来通信。   
消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。   
```youtrack
AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。
```
AMQP的主要特征是面向消息，队列，路由（包括点对点，发布/订阅）、可靠性、安全等的一个协议标准。   
RabbitMQ采用了AMQP协议，这个协议到底是怎么一回事，我们不用关系，我们主要关心RabbitMQ在实战中到底如何使用。   
我们先来看看RabbitMQ的一些概念，因为RabbitMQ实现了AMQP协议，所以这些概念也是AMQP中共有的。   
盗用其他博主的一个架构图：
![](/images/myBlog/2023-10-02-rabbitMQ-summary.png)
Broker: 中间件本身。接收和分发消息的应用，这里指的就是RabbitMQ Server。   
Virtual host: 虚拟主机。出于多租户和安全因素设计的，把AMQP的基本组件划分到一个虚拟的分组中，类似于网络中的namespace概念。当多个不同的用户使用同一个RabbitMQ server提供的服务时，可以划分出多个vhost，每个用户在自己的vhost创建exchange／queue等。host 是权限控制的基本单位，用户只能访问与之绑定的 vhost，默认 vhost：”/” ,默认用户”guest” 密码“guest”，来访问默认的vhost。      
ConnectionFactory：连接工厂，生产Connection的工厂。   
Connection: 连接。publisher／consumer和broker之间的TCP连接。断开连接的操作只会在client端进行，Broker不会断开连接，除非出现网络故障或broker服务出现问题。是RabbitMQ的socket长连接，它封装了socket协议相关部分逻辑。      
Channel: 渠道，也叫做频道、信道。如果每一次访问RabbitMQ都建立一个Connection，在消息量大的时候建立TCP Connection的开销会比较大且效率也较低。Channel是在connection内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的channel进行通讯，AMQP method包含了channel id帮助客户端和message broker识别channel，所以channel之间是完全隔离的。Channel作为轻量级的Connection极大减少了操作系统建立TCP connection的开销。它是建立在Collection连接之上的一种轻量级的连接，我们大部分的业务操作是在Channel这个接口中完成的，包括定义队列的声明queueDeclare、交换机的声明exchangeDeclare、队列的绑定queueBind、发布消息basicPublish、消费消息basicConsume等。如果把Connection比作一条光纤电缆的话，那么Chanel管道就比作光纤电缆中的其中一束光纤。一个Connection上可以创建任意数量的Channel。   
Exchange: 交换机，也叫做分发器。根据分发规则，匹配查询表中的routing key，分发消息到queue中去。   
Queue: 消息的队列。消息最终被送到这里等待消费，一个message可以被同时拷贝到多个queue中。   
Binding: 绑定。Binding并不是一个概念，而是一个操作。exchange和queue之间的虚拟连接，binding中可以包含routing key。Binding信息被保存到exchange中的查询表中，用于message的分发依据。RabbitMQ中通过绑定，以Routing key作为桥梁将Exchange与Queue关联起来（Exchange->Routing key->Queue），这样RabbitMQ就知道如何正确地将消息路由到指定的队列了，通过queueBind方法将Exchange、Routing key、Queue绑定起来。      

上面就是RabbitMQ消息中间件中的一些概念，其大致流程如下：   
当我们的生产者端（Producer生产者应用）往Broker(RabbitMQ)中发送了一条消息，Broker会根据其消息的标识送往不同的Virtual host，然后Exchange（交换机）会根据消息携带的路由key（Routing key）和交换器类型（Exchange type）将消息（Message）分发到自己所属的Queue（消息队列）中去。   
然后消费者端（Consumer消费者应用）会通过Connection（Rabbit连接）中的Channel（Rabbit通道）获取生产者刚刚推送到Queue中的消息，这个消息有可能是Queue主动推动给消费者（Push模式，异步消费），也可能是消费者主动从Queue中拉取（Pull模式，同步消费）。    
注意：某个Exchange交换机有哪些属于自己的Queue，使用Binding绑定关系决定的。   

# 3. RabbitMQ和MQ的关系
RabbitMQ其实质是对MQ(Message Queue)规范的一种具体实现。   
MQ规范实际上就是JMS(JAVA Message Service Java消息服务)API规范的扩展。   
因此可以这么说，RabbitMQ实际上就是对JMS规范的具体实现。   
当然，有很多厂商都对JMS规范做了实现，比如ActiveMQ、RocketMQ、Kafka等，都必须符合JMS规范，RabbitMQ也一样。   

RabbitMQ在实现JMS规范的基础上扩展了自己的一些组件概念，其所有组价大致如下：   
1.消息生产者Producer：负责生产消息，将消息发送到MQ中。   
2.消息队列Queue：MQ中负责缓存消息的容器，可以看成是一个有序的数组，生产者生产的消息会发送到交换机中，最终交换机将消息存储到某个队列或者某些队列中（这取决于交换机根据Routing key匹配到了绑定的哪些队列），队列可被消费者订阅，也可被消费者主动拉取消息，不论是订阅还是主动pull，消费者都将从这些队列中拿到消息进行消费。    
3.消息消费者Consumer：负责消费消息，从MQ的Queue中获取消息进行后续处理。消费者只需要关注队列即可，不需要关注交换机和路由键，消费者可以通过 basicConsume (订阅模式可以从队列中一直持续的自动的接收消息)或者 basicGet (先订阅消息，然后获取单条消息，再然后取消订阅，也就是说 basicGet 一次只能获取一条消息，如果还想再获取下一条还要再次调用basicGet)来从队列中获取消息。      
4.交换机Exchange：这个是RabbitMQ自己扩展出来的一个组件，用来隔离生产者和消息队列，充当二者之间的桥梁；它负责从生产者接受消息，然后将消息通过Routing key分发到它绑定的消息Queue中去。Routing key就是交换机和Queue绑定时指定的一个路由策略键。      

整体上来讲，在RabbitMQ中：   
生产者生产消息，将消息发送到Exchange，就结束了。生产者只关系它要往哪个Exchange发送消息。   
Exchange会通过Routing key和某个Queue或者和某一些Queue进行绑定，Routing key就是路由键，Exchange和每个队列之间都通过Routing key进行映射，只要能拿到Routing key，就能知道将消息分发到绑定的哪个Queue中去。   
消费者从Queue中消费消息，消费者不关心Exchange，也不关心Routing key，它只关心Queue，只需要知道从哪个Queue中消费消息就行。   

# 4. Exchange交换机类型
RabbitMQ架构中的核心组件就是交换机，通过交换机来实现消息的各种分发策略。   
它提供了如下几种交换机类型：   
Direct类型（直连交换机）：一对一，必须有一个明确唯一的Routing key和一个唯一的Queue进行绑定，一条消息只能通过该交换机发送到其绑定的那个唯一的Queue中。   
Fanout类型（扇形交换机）：一对所有，广播交换机，这种交换机没有Routing key的概念，即便指定了Routing key也不生效，它默认会绑定所有的Queue，一条消息发送到该交换机，会被转发到它绑定的所有Queue中。   
Topic类型（主题交换器）：一对多，这种交换机最灵活，它有Routing key，但是这个key支持模糊匹配。当这个key是唯一的时候，就和Direct交换机的功能一样；当这个key是全量匹配的时候，就和Fanout交换机的功能一样；当这个key是模糊匹配的时候，它就能够将消息分发到它所匹配到的对应的Queue中去。   

# 5. Routing key 路由键
交换机负责连接生产者和消息队列：   
生产者->交换机->消息队列   

（1）创建一个交换机
（2）创建一个队列
（3）绑定交换机和队列，这时候如果交换机是Direct、Topic类型，在绑定时，就需要指定一个Routing key，这个key维护了这个交换机和这个队列之间的绑定关系。   
（4）生产者向交换机发送消息时，需要指定Routing key，交换机根据消息中携带的这个Routing key将消息分发到绑定的Queue中去。   

Routing key：一个String值，用于定义Exchange到Queue之间的路由规则。在队列和交换机进行绑定的时候需要指定Routing Key；在生产者发布消息到交换机的时候需要指定Routing key，当消息的Routing key和队列绑定时指定的Routing key匹配时，消息就会发送到该队列。   
其通常由零个或者多个有意义的单词通过点号（.）分隔拼接而成，比如：topic.route.one，topic.route.two，topic等，路由键最多只能有255个字节。   
Direct交换机和Topic交换机中的Routing key的转发规则大致相同，都是直接比较消息中携带的Routing key是否和交换机中维护的Routing key相等，如果先等，就将消息投送到绑定的队列中，否则不进行投送。   
但Topic交换机中，我们说了它的路由键支持模糊匹配，因此Topic交换机的路由键增加了一些特殊的匹配规则。   
Topic交换机中有两个特殊的匹配符号：   
```youtrack
*：匹配任意一个字母
#：匹配零个或者多个字母

```
Topic交换机中的Routing key如果不带上面的特殊模糊匹配字符，它就和Direct交换机一样，直接进行全脸匹配。   
如果只带一个“#”的话，那意味着消息中的Routing key中没有任何字符或者有任何字符都进行投送，这表示Topic交换机会将消息无条件的投送到它绑定的Queue中去，这时就和Fanout扇形交换机一样，类似于广播。   
带特殊符号的Routing key比如：topic.#.#*，topic.route.#.#，topic.route.*#，topic.route.one.#，*，#等。   
使用场景如下：   
![](/images/myBlog/2023-10-02-rabbitMQ-topic.png)
Producer生产一个消息X，这个消息携带Routing key info.test，根据Topic交换机和Queue的Routing key模糊匹配关系，这个消息将会被同时推送到topic.queue.a和topic.queue.b队列。   
然后消费者可以同时从这两个队列消费消息。   

举个例子：   
生产者发送消息道topic交换机上面，队列A和队列B绑定一个topoc交换机，对于队列a来说，它绑定的key为info.#，对于队列b来说，它绑定的key为info.*。   
如果发送两条消息，其中第一条消息对应的路由key为info.xxxooo，第二条消息对于的路由key为info.xxxoo.kkk。根据匹配规则第一条跟第二条都会转到队列A中，而第一条则会转发队列B中去。   

   
 