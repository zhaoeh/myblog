---
layout:     post
title:      手机号加密方式分析
subtitle:   手机号加密方式分析
categories: [gpt]
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---

# 1. 手机号通常使用md5进行加密的好处和不好的地方？我发现我一笔请求中同一个手机号，同时使用md5加密产生一个md5字段存储，还使用了一种业务中自定义的密钥加密的方式生成一个字段存储，请问为何这样设计？
在业务中对手机号等敏感信息进行加密时，使用 **MD5** 和自定义密钥加密的组合设计是出于不同的需求和安全层次考虑。以下是这种设计的好处与不足之处的解释：

### 使用 MD5 加密的好处和不足

#### 好处：
1. **一致性**：MD5 作为哈希算法，对于同样的输入会产生固定的输出。这在一些业务场景中很有用，比如用于数据查重、快速查询（使用哈希值进行索引）、防止明文暴露等。可以将用户手机号 MD5 之后的值用于查询数据库中的记录，而不存储原始手机号。
   
2. **数据保护**：手机号等敏感数据不会以明文形式存储，MD5 加密能够减少因数据泄露带来的风险，即使数据库被入侵，攻击者也无法直接获得手机号。

3. **不可逆**：MD5 是一种哈希函数，理论上是不可逆的，即无法通过 MD5 哈希值轻易推导出原始数据。即使数据泄露，恢复明文的难度较大（但见到下面的不足部分）。

#### 不足：
1. **安全性不足**：MD5 本身已经不再推荐用于安全场景，它容易受到**彩虹表攻击**（通过查找预先计算好的 MD5 值对应的明文）和**碰撞攻击**（找到不同的输入数据生成相同的 MD5 值）。因此，单纯使用 MD5 加密手机号已经不足以提供足够的安全性。

2. **不可逆性问题**：虽然 MD5 不可逆，但对于固定数据（如手机号这种格式固定的数据），攻击者可以通过构建字典或暴力破解进行反向推导。

### 自定义密钥加密的好处和不足

#### 好处：
1. **更高的安全性**：通过自定义密钥的加密算法（例如 AES 或 RSA 等对称或非对称加密），可以提高数据的安全性。与 MD5 不同，密钥加密是**可逆**的，只有持有密钥的人才能解密数据。这确保了即使加密数据被截获，也无法轻易解密。

2. **灵活性**：自定义密钥加密可以提供额外的灵活性，比如加密的强度、加密算法的选择、密钥的管理方式等都可以根据业务需求进行调整。

3. **增强的数据保护**：相比于 MD5，使用密钥加密使得即使面对彩虹表或碰撞攻击，解密难度依然很高，只有掌握密钥的人才能获取原始手机号。

#### 不足：
1. **性能问题**：密钥加密比 MD5 的计算复杂度更高，在高并发、大量数据的情况下可能带来性能开销。

2. **密钥管理的挑战**：如何安全地存储和管理加密密钥是个难点。如果密钥被泄露或被盗，所有被加密的数据都会面临风险。

### 为什么同时使用 MD5 和自定义密钥加密？

1. **不同场景的需求**：使用 MD5 加密手机号可以用于**快速查询**、**数据查重**等场景，不需要解密，直接匹配哈希值即可。而自定义密钥加密则用于**高度安全的数据保护**，需要保证数据可解密以便在业务中使用。
   
2. **安全性分层**：MD5 仅提供基本的不可逆数据保护，且可以被破解；自定义密钥加密则提供更高的安全性。这种组合可以实现不同安全层次的防护，降低单一加密方式被破解的风险。

3. **灵活性和兼容性**：MD5 的速度快且容易用于数据索引和查找，而密钥加密则在需要恢复原始数据时使用。通过这种设计，既满足了业务性能要求，也兼顾了数据安全。

### 总结：
这种设计是为了在安全性与性能之间取得平衡。MD5 主要用于不可逆的哈希，用来避免存储明文和提高查找效率；而自定义密钥加密用于需要更高安全性且可解密的场景。


# 2. MultipartFile可以进行跨服务传递吗？
`MultipartFile` 不能直接用于跨服务传递，因为它是 Spring 中的接口，依赖于 HTTP 请求中上传的文件流。跨服务调用时，通常是通过 HTTP、RPC 等通信协议传递数据，而 `MultipartFile` 只是在服务内部处理文件上传时使用。

要在跨服务中传递文件，可以考虑以下几种方式：

### 1. **将文件转化为字节数组**
   将 `MultipartFile` 的内容转换为字节数组或 Base64 编码，在跨服务请求时将其作为请求体传递。
   
   **发送方：**
   ```java
   byte[] fileBytes = multipartFile.getBytes();
   // 或者
   String encodedFile = Base64.getEncoder().encodeToString(fileBytes);
   // 然后通过 HTTP 请求传递字节数据
   ```

   **接收方：**
   在接收端，使用相应的解码方式将字节数据或 Base64 数据转换回文件格式。

   **恢复为 MultipartFile：**
   ```java
   MultipartFile multipartFile = new MockMultipartFile("file", originalFilename, contentType, fileBytes);
   ```

### 2. **将文件上传到公共存储**
   另一种常用的方式是将文件上传到一个公共的文件存储系统（例如 AWS S3、FTP、数据库等），然后在服务间通过传递文件的 URL 或存储位置的方式，来访问和共享该文件。

   **发送方：**
   - 把文件上传到文件存储服务，获取文件 URL。
   - 将文件的 URL 作为跨服务请求的一部分传递。

   **接收方：**
   - 接收到 URL 后，可以从文件存储服务中获取文件进行处理。

### 3. **使用流传递（适用于大型文件）**
   如果文件较大，直接传递字节数组会占用大量内存，可以使用流的方式在服务间传递文件。可以通过流传递文件数据而不一次性加载到内存中。比如在服务间使用 RESTful API 或者 WebSocket 传输文件流。

### 示例：通过 REST API 跨服务传递文件
**发送文件服务：**
```java
@PostMapping("/uploadFile")
public ResponseEntity<String> uploadFile(@RequestParam("file") MultipartFile file) {
    // 转换 MultipartFile 为字节数组并发送给另一个服务
    byte[] fileBytes = file.getBytes();
    // 通过 REST Template 发送字节数组到另一个服务
    // ...
}
```

**接收文件服务：**
```java
@PostMapping("/receiveFile")
public ResponseEntity<String> receiveFile(@RequestBody byte[] fileBytes) {
    // 使用 MockMultipartFile 或直接保存字节数组为文件
    MultipartFile multipartFile = new MockMultipartFile("file", "filename.txt", "text/plain", fileBytes);
    // 处理文件
    // ...
}
```

### 总结
`MultipartFile` 不适用于跨服务传递，但可以通过将其内容转换为字节数组、上传到文件存储、或者使用流等方式进行跨服务传递。具体选择哪种方式取决于文件大小和服务间的通信协议。

# 3. 也就是不能通过Feign传递MultipartFile 吗？
通过 Feign 传递 `MultipartFile` 是**可以**实现的，但需要一些额外的配置。Feign 本质上是一个 HTTP 客户端，用来简化服务间的通信，而 `MultipartFile` 属于文件上传的类型，可以作为表单的一部分传输。为了通过 Feign 传递 `MultipartFile`，你需要确保 Feign 客户端和服务端的配置支持 `multipart/form-data` 类型的请求。

### 实现步骤

#### 1. **Feign 配置**
首先，你需要在 Feign 客户端中配置支持文件上传的请求。可以通过 `@RequestPart` 来传递 `MultipartFile` 类型。

#### Feign 客户端定义
```java
@FeignClient(name = "file-service", url = "http://localhost:8080")
public interface FileClient {

    @PostMapping(value = "/upload", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    String uploadFile(@RequestPart("file") MultipartFile file);
}
```

#### 2. **服务端配置**
确保服务端能够接收 `multipart/form-data` 的请求，并正确处理文件。

#### 服务端文件上传接口
```java
@RestController
@RequestMapping("/file")
public class FileController {

    @PostMapping("/upload")
    public ResponseEntity<String> uploadFile(@RequestPart("file") MultipartFile file) {
        // 处理文件，例如保存到本地或存储系统
        String fileName = file.getOriginalFilename();
        return ResponseEntity.ok("File uploaded successfully: " + fileName);
    }
}
```

#### 3. **Feign 配置编码器**
为了支持 `MultipartFile` 的传递，Feign 需要一个支持文件上传的编码器（`SpringFormEncoder`）。Spring Cloud OpenFeign 默认不支持多部分文件上传，所以你需要引入 Feign 的 `SpringFormEncoder`。

```java
@Configuration
public class FeignConfig {

    @Bean
    public Encoder feignFormEncoder() {
        return new SpringFormEncoder();
    }
}
```

然后在 Feign 客户端中引入这个配置：
```java
@FeignClient(name = "file-service", configuration = FeignConfig.class)
public interface FileClient {
    @PostMapping(value = "/upload", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    String uploadFile(@RequestPart("file") MultipartFile file);
}
```

### 4. **发送文件请求**
你可以通过 Feign 客户端调用文件上传的接口。

```java
@Autowired
private FileClient fileClient;

public void sendFile(MultipartFile multipartFile) {
    String response = fileClient.uploadFile(multipartFile);
    System.out.println("Response from server: " + response);
}
```

### 关键点

1. **文件格式**：Feign 默认不支持 `multipart/form-data`，所以需要通过 `SpringFormEncoder` 来编码文件数据。
2. **Feign 配置**：确保 `FeignClient` 消费的是 `multipart/form-data`，并使用 `@RequestPart` 注解来处理文件传输。
3. **服务端配置**：服务端需要使用 `@RequestPart` 来接收 `MultipartFile`。

### 依赖项
为了确保 `SpringFormEncoder` 能正常工作，你可能需要在 `pom.xml` 中添加 `spring-cloud-starter-openfeign` 依赖。

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
<dependency>
    <groupId>io.github.openfeign.form</groupId>
    <artifactId>feign-form-spring</artifactId>
    <version>3.8.0</version>
</dependency>
```

### 总结
虽然 `MultipartFile` 不能直接作为普通参数传递，但通过配置 Feign 支持 `multipart/form-data`，你可以实现跨服务的文件传递。关键是正确配置编码器并使用 `@RequestPart` 处理文件参数。
