---
layout:     post
title:      HttpSecurity permitAll customFilter.
subtitle:   HttpSecurity permitAll customFilter.
categories: [gpt]
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---

# 1. httpSecurity对象，如果匹配某个url比如/a/b，设置了permitAll，但是最后通过addFilterBefore在某个过滤器之前增加了一个自定义的过滤器，请问，现在这个url怎么处理？会自动放行吗？还会被自定义的过滤器拦截吗？
当你使用`HttpSecurity`对象并设置某个URL（如`/a/b`）为`permitAll`时，这意味着Spring Security不会对该URL进行身份验证或授权，所有用户都可以访问。然而，当你通过`addFilterBefore`在某个过滤器之前增加了一个自定义的过滤器时，这个自定义过滤器仍然会被应用到该URL。

具体处理逻辑如下：

1. **permitAll**：Spring Security配置`permitAll`时，对应的URL会跳过身份验证和授权检查。这确保了访问该URL的请求不会被Spring Security的认证和授权机制拦截。

2. **addFilterBefore**：`addFilterBefore`方法会在指定的过滤器之前添加一个新的自定义过滤器。这个自定义过滤器会对所有请求进行处理，包括那些被配置为`permitAll`的URL。

因此，即使URL`/a/b`被配置为`permitAll`，你的自定义过滤器仍然会拦截并处理对该URL的请求。这意味着：

- 请求会自动放行，因为它跳过了身份验证和授权检查。
- 请求仍会被自定义过滤器拦截，并根据自定义过滤器的逻辑进行处理。

例如，如果你的自定义过滤器是`MyCustomFilter`，并且你将其添加到`UsernamePasswordAuthenticationFilter`之前，那么配置可能如下：

```java
http
    .authorizeRequests()
        .antMatchers("/a/b").permitAll()
        .anyRequest().authenticated()
    .and()
    .addFilterBefore(new MyCustomFilter(), UsernamePasswordAuthenticationFilter.class);
```

在这种情况下，`/a/b` URL将：

- 不进行身份验证和授权检查（因为`permitAll`）。
- 仍然会通过`MyCustomFilter`，并执行自定义过滤器中的逻辑。

总结：

- `permitAll`配置的URL会跳过Spring Security的身份验证和授权。
- 但是任何自定义过滤器（通过`addFilterBefore`添加）仍然会处理这些URL的请求。

如果你希望自定义过滤器也放行某些URL，可以在过滤器内部添加相应的逻辑。例如：

```java
public class MyCustomFilter extends GenericFilterBean {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        String path = httpRequest.getRequestURI();

        // Skip the custom filter for specific URLs
        if ("/a/b".equals(path)) {
            chain.doFilter(request, response);
            return;
        }

        // Custom filter logic
        // ...

        chain.doFilter(request, response);
    }
}
```

这样，`/a/b` URL将完全跳过自定义过滤器的逻辑。

# 2. springboot中哪些数据源会自动配置呢？
在Spring Boot中，自动配置数据源是通过Spring Boot的自动配置机制实现的。Spring Boot会根据应用的类路径和配置属性自动配置合适的数据源。常见的几种自动配置的数据源包括：

1. **H2**：内存数据库，通常用于开发和测试环境。
2. **HSQLDB**：另一种内存数据库。
3. **Derby**：嵌入式数据库，适合开发和测试环境。
4. **MySQL**：常用的关系型数据库。
5. **MariaDB**：MySQL的分支，兼容MySQL。
6. **PostgreSQL**：功能强大的关系型数据库。
7. **SQL Server**：微软的关系型数据库。
8. **Oracle**：甲骨文公司的关系型数据库。

Spring Boot通过查看类路径中的驱动程序并使用相应的配置来自动配置数据源。例如，如果类路径中有H2数据库的依赖，那么Spring Boot会自动配置一个H2数据库的数据源。

### 自动配置数据源的条件

Spring Boot只有在满足以下条件时才会自动配置数据源：

1. 类路径中存在合适的数据库驱动程序。例如，对于MySQL，类路径中需要有`mysql-connector-java`。
2. `application.properties`或`application.yml`文件中有合适的数据源配置属性。例如，对于MySQL：

```properties
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=root
```

### 数据源的配置属性

Spring Boot提供了一些通用的属性来配置数据源。这些属性包括但不限于：

- `spring.datasource.url`：数据库的JDBC URL。
- `spring.datasource.username`：数据库用户名。
- `spring.datasource.password`：数据库密码。
- `spring.datasource.driver-class-name`：数据库驱动类名。
- `spring.datasource.initialization-mode`：数据源初始化模式（`always`、`never`或`embedded`）。
- `spring.datasource.platform`：数据库平台（用于初始化脚本，值可以是`h2`、`mysql`等）。

### 示例配置

以下是一个配置MySQL数据源的示例：

```properties
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
```

对于PostgreSQL数据源：

```properties
spring.datasource.url=jdbc:postgresql://localhost:5432/mydb
spring.datasource.username=postgres
spring.datasource.password=secret
spring.datasource.driver-class-name=org.postgresql.Driver
```

### 结论

Spring Boot通过查看类路径中的数据库驱动程序并结合配置属性来自动配置数据源。常见的支持的数据源包括H2、HSQLDB、Derby、MySQL、MariaDB、PostgreSQL、SQL Server和Oracle。通过在`application.properties`或`application.yml`文件中设置相应的配置属性，可以轻松地配置和使用这些数据源。

# 3. failed to configure a datasource,spring boot启动报这个错误
在Spring Boot启动时报“failed to configure a datasource”的错误通常是由于数据源配置不正确或缺失引起的。为了排查和解决这个问题，可以按照以下步骤进行检查和修正：

### 1. 检查依赖
确保你的项目中包含了合适的数据库驱动依赖。例如，如果你使用的是MySQL数据库，确保在`pom.xml`（Maven）或`build.gradle`（Gradle）文件中添加了MySQL驱动依赖：

**Maven:**
```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.33</version>
</dependency>
```

**Gradle:**
```groovy
dependencies {
    implementation 'mysql:mysql-connector-java:8.0.33'
}
```

### 2. 检查数据源配置
确保在`application.properties`或`application.yml`文件中正确配置了数据源属性。例如，对于MySQL数据库，配置应如下：

**application.properties:**
```properties
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
```

**application.yml:**
```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mydb
    username: root
    password: root
    driver-class-name: com.mysql.cj.jdbc.Driver
```

### 3. 检查数据库连接信息
确保数据库URL、用户名和密码等连接信息正确无误，并且数据库服务器正在运行且可以被访问。

### 4. 检查数据库驱动类
确保配置了正确的数据库驱动类名。如果使用的是MySQL 8.x，驱动类名应为`com.mysql.cj.jdbc.Driver`。如果使用其他版本或数据库类型，请参考相应的驱动文档。

### 5. 检查Spring Boot版本
确保使用的Spring Boot版本与数据库驱动兼容。

### 6. 检查数据库初始化模式
如果你不希望Spring Boot在启动时初始化数据库，可以显式地禁用数据源初始化：

**application.properties:**
```properties
spring.datasource.initialization-mode=never
```

**application.yml:**
```yaml
spring:
  datasource:
    initialization-mode: never
```

### 7. 查看完整的错误日志
查看完整的错误堆栈信息，以便了解更多的错误细节。通常，堆栈信息中会有更多关于具体错误原因的提示。

### 示例项目配置
以下是一个完整的Spring Boot项目配置示例，假设使用的是MySQL数据库：

**pom.xml:**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.33</version>
</dependency>
```

**application.properties:**
```properties
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
```

### 8. 运行应用
确保所有配置正确后，重新启动Spring Boot应用，检查是否仍然出现错误。

通过以上步骤，你应该能够解决Spring Boot启动时“failed to configure a datasource”错误的问题。如果问题仍然存在，请提供完整的错误日志，以便进一步诊断。

# 4. 它为何会自动初始化数据源呢？
Spring Boot自动初始化数据源的原因在于其“自动配置”特性。Spring Boot的自动配置通过类路径中的依赖和配置文件中的属性，自动配置应用程序的许多方面，包括数据源。这一特性极大地简化了Spring应用程序的配置和开发。

### 自动配置的原理

Spring Boot的自动配置功能基于以下几个方面：

1. **类路径依赖**：
   Spring Boot会扫描类路径中的依赖项，根据检测到的库来决定如何进行自动配置。例如，如果类路径中包含`H2`数据库的依赖，Spring Boot会自动配置一个嵌入式H2数据库的数据源。

2. **配置属性**：
   Spring Boot会读取`application.properties`或`application.yml`文件中的配置属性，使用这些属性来配置数据源。例如，如果配置文件中有以下属性，Spring Boot会自动配置一个MySQL数据源：
   ```properties
   spring.datasource.url=jdbc:mysql://localhost:3306/mydb
   spring.datasource.username=root
   spring.datasource.password=root
   ```

3. **自动配置类**：
   Spring Boot包含大量的自动配置类，这些类在Spring Boot启动时根据特定的条件进行配置。对于数据源，Spring Boot的`DataSourceAutoConfiguration`类负责数据源的自动配置。

### 数据源自动配置的条件

Spring Boot自动配置数据源的前提条件是：
- 类路径中存在相应的数据库驱动。
- `application.properties`或`application.yml`文件中存在数据源相关的配置属性。

如果这两个条件满足，Spring Boot会自动执行数据源配置。

### 数据源自动配置的详细步骤

1. **扫描类路径**：
   Spring Boot在启动时会扫描类路径中的所有依赖项。它会检查是否存在数据库驱动程序（例如`mysql-connector-java`）。

2. **读取配置文件**：
   Spring Boot会读取`application.properties`或`application.yml`文件中的配置属性。例如，读取数据源相关的属性（如`spring.datasource.url`、`spring.datasource.username`等）。

3. **执行自动配置**：
   Spring Boot会根据类路径中的依赖和配置文件中的属性，执行相应的自动配置类。例如，`DataSourceAutoConfiguration`类会根据配置属性创建并配置一个`DataSource`对象。

### 禁用数据源自动配置

如果你不希望Spring Boot自动配置数据源，可以通过以下方式禁用数据源的自动配置：

1. **使用`@SpringBootApplication`注解的`exclude`属性**：
   ```java
   @SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})
   public class MyApplication {
       public static void main(String[] args) {
           SpringApplication.run(MyApplication.class, args);
       }
   }
   ```

2. **在配置文件中设置`spring.autoconfigure.exclude`属性**：
   **application.properties**:
   ```properties
   spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
   ```

   **application.yml**:
   ```yaml
   spring:
     autoconfigure:
       exclude: org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
   ```

### 总结

Spring Boot自动初始化数据源是通过其自动配置机制实现的，目的是简化配置和开发过程。通过自动扫描类路径和读取配置文件中的属性，Spring Boot能够自动创建和配置合适的数据源。如果不希望自动配置数据源，可以使用上述方法禁用自动配置。

# 5. 我的pom没有没有配置数据源，其实我不需要使用数据源，可能是引用了某些包，现在怎么处理，我不想使用数据源
如果你不需要使用数据源，但由于引用了某些包导致Spring Boot尝试自动配置数据源，可以通过以下几种方式来解决这个问题：

### 1. 禁用数据源自动配置

你可以显式地禁用数据源的自动配置。这可以通过在主类上使用`@SpringBootApplication`注解的`exclude`属性来完成，或者在配置文件中设置`spring.autoconfigure.exclude`属性。

#### 通过`@SpringBootApplication`注解的`exclude`属性

在你的主类上添加`exclude`属性，禁用数据源自动配置：

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;

@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

#### 通过配置文件

你也可以在`application.properties`或`application.yml`文件中配置，禁用数据源自动配置：

**application.properties:**
```properties
spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
```

**application.yml:**
```yaml
spring:
  autoconfigure:
    exclude: org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
```

### 2. 检查依赖

如果禁用自动配置解决了你的问题，你可能还想检查你的`pom.xml`或`build.gradle`文件，看看是否有不必要的依赖导致Spring Boot尝试配置数据源。例如，如果你不需要数据库相关的功能，可以移除相关依赖。

#### 例子：移除数据库相关依赖

**Maven:**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
    <version>2.7.5</version>
    <scope>runtime</scope>
</dependency>
```

**Gradle:**
```groovy
implementation 'org.springframework.boot:spring-boot-starter-data-jpa:2.7.5'
```

确保只包含你实际需要的依赖。

### 3. 排除特定的自动配置

有时候，你可能引用了某些包（如Spring Data JPA）而导致Spring Boot尝试自动配置数据源。在这种情况下，可以通过排除特定的自动配置来解决问题。

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration;

@SpringBootApplication(exclude = {JpaRepositoriesAutoConfiguration.class})
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

### 4. 验证配置

在执行上述操作后，重新启动应用程序，确保问题已解决。如果仍有问题，请检查完整的错误日志，了解是否有其他配置需要调整。

通过以上步骤，你应该能够解决Spring Boot启动时报“failed to configure a datasource”的问题，并确保在不需要数据源的情况下正常启动应用程序。

# 6. ConditionOnClass后面，是且还是或的关系？
在Spring Boot中，`@ConditionalOnClass`注解的条件是基于"AND"关系的。也就是说，所有列出的类都必须存在于类路径中，条件才会成立。

### 示例

```java
@ConditionalOnClass({ DataSource.class, JdbcTemplate.class })
public class MyJdbcConfig {
    // 配置类的内容
}
```

在上述示例中，只有当`DataSource`和`JdbcTemplate`这两个类都存在于类路径中时，`MyJdbcConfig`配置类才会被加载。

### 实现原理

Spring Boot 的自动配置机制会检查所有的 `@ConditionalOnClass` 注解，如果所有指定的类都存在于类路径中，则条件成立，相关的自动配置类会被加载。否则，自动配置类将被忽略。

### 更多条件注解

除了 `@ConditionalOnClass`，Spring Boot 还提供了许多其他条件注解，这些注解允许你基于不同的条件来配置应用程序：

- `@ConditionalOnMissingClass`：当指定的类不存在于类路径中时，条件成立。
- `@ConditionalOnBean`：当指定的Bean存在于Spring上下文中时，条件成立。
- `@ConditionalOnMissingBean`：当指定的Bean不存在于Spring上下文中时，条件成立。
- `@ConditionalOnProperty`：当指定的属性有特定值时，条件成立。
- `@ConditionalOnResource`：当指定的资源存在时，条件成立。

### 示例：组合使用条件注解

你可以组合使用多个条件注解来实现复杂的条件逻辑。例如，只有当类路径中存在特定类并且某个属性有特定值时，才加载配置：

```java
@Configuration
@ConditionalOnClass({ DataSource.class, JdbcTemplate.class })
@ConditionalOnProperty(name = "myapp.datasource.enabled", havingValue = "true")
public class MyJdbcConfig {
    // 配置类的内容
}
```

在这个示例中，只有当类路径中存在 `DataSource` 和 `JdbcTemplate` 类，并且 `myapp.datasource.enabled` 属性的值为 `true` 时，`MyJdbcConfig` 配置类才会被加载。

通过了解 `@ConditionalOnClass` 的工作方式以及其他条件注解的使用，你可以更灵活地控制Spring Boot应用程序的自动配置行为。

# 7. mybatis plus多租户是什么意思？
在MyBatis Plus中，多租户（Multi-Tenancy）是一种架构设计，用于在一个单一的应用程序实例中支持多个独立的租户（Tenant）。每个租户可以看作是一个独立的客户、组织或用户组，他们的数据彼此隔离但共享同一个应用程序实例。这种设计在SaaS（软件即服务）应用中非常常见。

### 多租户架构类型

多租户架构有几种常见的实现方式：

1. **独立数据库**：每个租户有一个独立的数据库。
2. **共享数据库，独立模式**：多个租户共享同一个数据库实例，但每个租户有自己的模式（Schema）。
3. **共享数据库，共享模式**：多个租户共享同一个数据库和同一个模式，通过某种方式（例如添加租户ID列）来隔离数据。

### MyBatis Plus 多租户实现

MyBatis Plus 提供了多租户支持，可以通过拦截SQL语句在执行时自动加入租户ID，从而实现数据隔离。以下是一个基本的配置步骤：

1. **添加依赖**

确保在`pom.xml`文件中添加MyBatis Plus的依赖：

```xml
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.5.3.1</version>
</dependency>
```

2. **配置多租户插件**

配置多租户插件，通过拦截器在每个SQL语句中添加租户ID：

```java
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.TenantLineInnerInterceptor;
import com.baomidou.mybatisplus.extension.plugins.handler.TenantLineHandler;
import net.sf.jsqlparser.expression.Expression;
import net.sf.jsqlparser.expression.LongValue;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MybatisPlusConfig {

    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new TenantLineInnerInterceptor(new TenantLineHandler() {
            @Override
            public Expression getTenantId() {
                // 返回租户ID的表达式，例如从ThreadLocal中获取当前租户ID
                return new LongValue(1); // 示例: 返回租户ID 1
            }

            @Override
            public boolean ignoreTable(String tableName) {
                // 忽略某些表，不进行租户ID过滤
                return "non_tenant_table".equals(tableName);
            }
        }));
        return interceptor;
    }
}
```

3. **动态获取租户ID**

在实际应用中，租户ID通常不是固定的，而是根据当前用户的上下文动态获取。例如，可以使用ThreadLocal来存储和获取当前请求的租户ID：

```java
public class TenantContext {

    private static final ThreadLocal<Long> TENANT_ID = new ThreadLocal<>();

    public static void setTenantId(Long tenantId) {
        TENANT_ID.set(tenantId);
    }

    public static Long getTenantId() {
        return TENANT_ID.get();
    }

    public static void clear() {
        TENANT_ID.remove();
    }
}
```

在 `TenantLineHandler` 中使用 `TenantContext.getTenantId()` 获取当前租户ID：

```java
@Override
public Expression getTenantId() {
    return new LongValue(TenantContext.getTenantId());
}
```

4. **在请求开始时设置租户ID**

确保在每个请求开始时设置正确的租户ID。例如，在Spring的过滤器或拦截器中：

```java
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import java.io.IOException;

public class TenantFilter implements Filter {

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        // 假设从请求头中获取租户ID
        String tenantId = request.getParameter("tenantId");
        if (tenantId != null) {
            TenantContext.setTenantId(Long.parseLong(tenantId));
        }

        try {
            chain.doFilter(request, response);
        } finally {
            TenantContext.clear();
        }
    }

    @Override
    public void destroy() {
    }
}
```

### 结论

通过以上配置，你可以在MyBatis Plus中实现多租户支持，确保每个租户的数据在逻辑上彼此隔离。这种实现方式通常用于共享数据库和共享模式的多租户架构，通过在SQL语句中自动添加租户ID来实现数据隔离。

# 8. spring security中处理权限校验的过滤器是哪个呢？
在Spring Security中，处理权限校验的主要过滤器是`FilterSecurityInterceptor`。这个过滤器负责检查当前请求的权限，决定请求是否被允许访问资源。

### `FilterSecurityInterceptor` 的工作原理

`FilterSecurityInterceptor` 是Spring Security的最后一个过滤器，负责执行基于URL的访问控制决策。它使用`SecurityMetadataSource`来获取访问当前请求所需的权限信息，并通过`AccessDecisionManager`来决定请求是否被允许。

以下是`FilterSecurityInterceptor`的工作流程：

1. **获取当前请求的权限信息**：从`SecurityMetadataSource`获取当前请求的权限信息。
2. **执行权限校验**：使用`AccessDecisionManager`来判断当前用户是否拥有访问该资源的权限。
3. **决策结果处理**：如果用户拥有访问权限，则允许请求继续，否则抛出`AccessDeniedException`。

### 配置 `FilterSecurityInterceptor`

通常，你不需要直接配置`FilterSecurityInterceptor`，而是通过配置Spring Security的`HttpSecurity`来间接配置它。

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/public/**").permitAll() // 公共资源不需要认证
                .antMatchers("/admin/**").hasRole("ADMIN") // 只有ADMIN角色才能访问/admin/**资源
                .anyRequest().authenticated() // 其他请求需要认证
            .and()
            .formLogin().loginPage("/login").permitAll() // 配置登录页面
            .and()
            .logout().permitAll(); // 配置注销
    }
}
```

### 相关组件

- **`SecurityMetadataSource`**：提供当前请求所需的权限信息。默认实现是`DefaultFilterInvocationSecurityMetadataSource`，通过`RequestMatcher`和权限列表进行映射。
- **`AccessDecisionManager`**：执行访问决策的逻辑。默认实现是`AffirmativeBased`，它使用一个或多个`AccessDecisionVoter`来进行投票决策。
- **`AccessDecisionVoter`**：用于投票的组件，可以自定义实现来扩展权限校验逻辑。

### 自定义权限校验

如果需要自定义权限校验逻辑，可以自定义`AccessDecisionVoter`：

```java
import org.springframework.security.access.AccessDecisionVoter;
import org.springframework.security.access.ConfigAttribute;
import org.springframework.security.core.Authentication;
import org.springframework.security.web.FilterInvocation;

import java.util.Collection;

public class CustomVoter implements AccessDecisionVoter<FilterInvocation> {

    @Override
    public boolean supports(ConfigAttribute attribute) {
        return true; // 支持所有ConfigAttribute
    }

    @Override
    public boolean supports(Class<?> clazz) {
        return FilterInvocation.class.isAssignableFrom(clazz);
    }

    @Override
    public int vote(Authentication authentication, FilterInvocation fi, Collection<ConfigAttribute> attributes) {
        // 自定义权限校验逻辑
        // 返回 ACCESS_GRANTED, ACCESS_DENIED 或 ACCESS_ABSTAIN
        return ACCESS_GRANTED;
    }
}
```

然后将自定义的`AccessDecisionVoter`添加到`AccessDecisionManager`中：

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.access.AccessDecisionManager;
import org.springframework.security.access.vote.AffirmativeBased;
import org.springframework.security.access.vote.RoleVoter;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

import java.util.Arrays;

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .accessDecisionManager(accessDecisionManager())
                .antMatchers("/public/**").permitAll()
                .antMatchers("/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            .and()
            .formLogin().loginPage("/login").permitAll()
            .and()
            .logout().permitAll();
    }

    @Bean
    public AccessDecisionManager accessDecisionManager() {
        return new AffirmativeBased(Arrays.asList(new RoleVoter(), new CustomVoter()));
    }
}
```

通过这种方式，你可以定制Spring Security的权限校验逻辑，满足特定的业务需求。

# 9. 好像最新版本的这个过滤器已经废弃了
在Spring Security 5.4及之后的版本中，引入了新的授权管理器（Authorization Manager）体系结构，并对一些旧的类进行了重构或废弃。虽然`FilterSecurityInterceptor`依然存在，但Spring Security已经鼓励使用新的授权方式。

### 新的授权管理器架构

新的授权管理器体系使用`AuthorizationManager`接口来处理授权决策。这种方式更灵活并且更具扩展性。下面是使用新架构的示例。

### 使用`AuthorizationManager`的配置示例

首先，确保你的Spring Security版本在5.4及以上。

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests((requests) -> requests
                .requestMatchers("/public/**").permitAll()
                .requestMatchers("/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .formLogin((form) -> form
                .loginPage("/login")
                .permitAll()
            )
            .logout((logout) -> logout.permitAll());

        return http.build();
    }
}
```

### 自定义`AuthorizationManager`

你可以自定义一个`AuthorizationManager`来替代传统的`AccessDecisionVoter`。

```java
import org.springframework.security.authorization.AuthorizationDecision;
import org.springframework.security.authorization.AuthorizationManager;
import org.springframework.security.core.Authentication;
import org.springframework.security.web.access.intercept.RequestAuthorizationContext;
import org.springframework.stereotype.Component;

@Component
public class CustomAuthorizationManager implements AuthorizationManager<RequestAuthorizationContext> {

    @Override
    public AuthorizationDecision check(Supplier<Authentication> authentication, RequestAuthorizationContext context) {
        // 自定义授权逻辑
        boolean granted = // your custom logic;
        return new AuthorizationDecision(granted);
    }
}
```

### 配置自定义`AuthorizationManager`

将自定义的`AuthorizationManager`配置到Spring Security中：

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.beans.factory.annotation.Autowired;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Autowired
    private CustomAuthorizationManager customAuthorizationManager;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests((requests) -> requests
                .requestMatchers("/public/**").permitAll()
                .requestMatchers("/admin/**").access(customAuthorizationManager)
                .anyRequest().authenticated()
            )
            .formLogin((form) -> form
                .loginPage("/login")
                .permitAll()
            )
            .logout((logout) -> logout.permitAll());

        return http.build();
    }
}
```

### 总结

在Spring Security 5.4及之后版本中，推荐使用`AuthorizationManager`接口来处理授权决策。这种方式更现代化，并且提供了更大的灵活性。如果你仍然使用较旧版本的Spring Security，你可以继续使用`FilterSecurityInterceptor`和`AccessDecisionManager`。但如果可能，建议迁移到新的授权管理器体系，以利用最新的功能和改进。

# 10. 那如果没有自定义，默认使用的是哪个实现呢？
在Spring Security 5.4及之后的版本中，如果你没有自定义`AuthorizationManager`，Spring Security默认会使用以下实现来处理请求的授权：

### 默认的`AuthorizationManager`

Spring Security默认使用`RequestMatcherDelegatingAuthorizationManager`来管理HTTP请求的授权决策。这是一个委托管理器，它基于不同的URL模式（RequestMatcher）来委托给不同的`AuthorizationManager`进行处理。

### 默认的行为

1. **基于角色的访问控制**：使用`hasRole`、`hasAnyRole`等方法来定义基于角色的访问控制。
2. **基于权限的访问控制**：使用`hasAuthority`、`hasAnyAuthority`等方法来定义基于权限的访问控制。
3. **通用的访问控制**：使用`authenticated`、`permitAll`等方法来定义通用的访问控制规则。

### 默认配置示例

以下是一个典型的默认配置示例：

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests((requests) -> requests
                .requestMatchers("/public/**").permitAll()
                .requestMatchers("/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .formLogin((form) -> form
                .loginPage("/login")
                .permitAll()
            )
            .logout((logout) -> logout.permitAll());

        return http.build();
    }
}
```

### 默认的`AuthorizationManager`行为

在默认配置中，Spring Security会创建一个`RequestMatcherDelegatingAuthorizationManager`，它包含以下几种常见的默认实现：

1. **PermitAllAuthorizationManager**：处理`permitAll()`，允许所有请求通过。
2. **DenyAllAuthorizationManager**：处理`denyAll()`，拒绝所有请求。
3. **AuthenticatedAuthorizationManager**：处理`authenticated()`，确保请求经过认证。
4. **AnonymousAuthorizationManager**：处理`anonymous()`，允许匿名请求。
5. **AuthorityAuthorizationManager**：处理`hasAuthority()`和`hasAnyAuthority()`，基于权限进行访问控制。
6. **RoleAuthorizationManager**：处理`hasRole()`和`hasAnyRole()`，基于角色进行访问控制。

### 默认的授权管理器实例

```java
import org.springframework.security.authorization.AuthorityAuthorizationManager;
import org.springframework.security.authorization.AuthorizationManager;
import org.springframework.security.authorization.RequestMatcherDelegatingAuthorizationManager;
import org.springframework.security.web.access.intercept.RequestAuthorizationContext;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;

import java.util.LinkedHashMap;
import java.util.Map;

public class DefaultAuthorizationManagerConfig {

    public AuthorizationManager<RequestAuthorizationContext> defaultAuthorizationManager() {
        Map<RequestMatcher, AuthorizationManager<RequestAuthorizationContext>> authorizationManagers = new LinkedHashMap<>();
        
        // Permit all access to /public/**
        authorizationManagers.put(new AntPathRequestMatcher("/public/**"), 
            (context) -> new AuthorizationDecision(true));
        
        // Only ADMIN role can access /admin/**
        authorizationManagers.put(new AntPathRequestMatcher("/admin/**"), 
            AuthorityAuthorizationManager.hasRole("ADMIN"));
        
        // Authenticated access for all other requests
        authorizationManagers.put(new AnyRequestMatcher(), 
            AuthenticatedAuthorizationManager.authenticated());
        
        return new RequestMatcherDelegatingAuthorizationManager(authorizationManagers);
    }
}
```

### 结论

在Spring Security 5.4及之后的版本中，如果没有自定义`AuthorizationManager`，Spring Security会使用默认的`RequestMatcherDelegatingAuthorizationManager`来处理请求的授权决策。这个默认实现能够处理各种常见的访问控制需求，包括基于角色、权限以及通用的访问控制规则。通过配置`HttpSecurity`中的`authorizeHttpRequests`方法，你可以很容易地定义这些访问控制规则。

# 11. httpSecurity对象，如果匹配某个url比如/a/b，设置了permitAll，但是最后通过addFilterBefore在某个过滤器之前增加了一个自定义的过滤器，请问，现在这个url怎么处理？会自动放行吗？还会被自定义的过滤器拦截吗？关于这个问题，为什么在httpSecurity对象中注册的filter总会拦截所有请求呢？它和spring security中内置的filter有什么不同呢？
在Spring Security中，`HttpSecurity`对象配置的过滤器和Spring Security内置的过滤器确实有一些不同之处。这里我们来详细解释你的问题。

### 问题描述

你在`HttpSecurity`中配置了某个URL，比如`/a/b`，使用`permitAll`来允许所有请求访问。然后你通过`addFilterBefore`在某个过滤器之前增加了一个自定义的过滤器。你想知道：

1. 这个URL是否会自动放行？
2. 这个URL是否还会被自定义的过滤器拦截？
3. 为什么在`HttpSecurity`对象中注册的过滤器会拦截所有请求？

### 解析

#### 1. `permitAll`的作用

`permitAll`表示对指定的URL路径开放访问权限，不需要认证或授权。然而，这并不意味着该路径会绕过所有的过滤器。`permitAll`的配置只影响Spring Security的授权决策部分（即`FilterSecurityInterceptor`）。

```java
http
    .authorizeRequests()
        .antMatchers("/a/b").permitAll()
        .anyRequest().authenticated();
```

#### 2. 自定义过滤器的作用

通过`addFilterBefore`或`addFilterAfter`增加的自定义过滤器，会在Spring Security过滤器链中按照指定的位置执行。它们可以对所有请求进行处理，无论这些请求是否已经通过了`permitAll`的授权决策。

```java
http
    .addFilterBefore(new MyCustomFilter(), UsernamePasswordAuthenticationFilter.class)
    .authorizeRequests()
        .antMatchers("/a/b").permitAll()
        .anyRequest().authenticated();
```

#### 3. 自定义过滤器和Spring Security内置过滤器的区别

在`HttpSecurity`对象中注册的自定义过滤器会拦截所有请求，这主要是因为这些过滤器被添加到整个Spring Security过滤器链中，而过滤器链会对所有传入的HTTP请求进行处理。Spring Security内置的过滤器也是如此，除非它们被显式配置为只处理特定的请求。

### 处理流程

1. **所有请求进入过滤器链**：无论请求的URL是什么，所有请求都会依次经过过滤器链中的每个过滤器。
2. **自定义过滤器执行**：如果你在过滤器链中添加了自定义过滤器，这些过滤器会在它们被配置的位置执行。
3. **授权决策**：当请求到达`FilterSecurityInterceptor`时，Spring Security会根据之前配置的规则（如`permitAll`、`hasRole`等）来做授权决策。

### 具体示例

假设有以下配置：

```java
http
    .addFilterBefore(new MyCustomFilter(), UsernamePasswordAuthenticationFilter.class)
    .authorizeRequests()
        .antMatchers("/a/b").permitAll()
        .anyRequest().authenticated();
```

- **请求URL `/a/b`**：
  - 请求首先经过`MyCustomFilter`，该过滤器会对请求进行处理。
  - 经过`MyCustomFilter`后，请求到达`FilterSecurityInterceptor`，此时由于`/a/b`配置了`permitAll`，请求被允许通过，不需要认证。

- **请求其他URL**：
  - 请求首先经过`MyCustomFilter`，该过滤器会对请求进行处理。
  - 经过`MyCustomFilter`后，若请求URL没有配置`permitAll`，`FilterSecurityInterceptor`会根据`authenticated()`或其他授权规则进行检查，决定请求是否被允许。

### 总结

- **自定义过滤器**：会拦截所有请求，因为它们被添加到整个Spring Security过滤器链中。
- **`permitAll`**：只影响授权决策部分，不会跳过自定义过滤器。
- **过滤器链处理流程**：所有请求都会依次经过过滤器链中的每个过滤器，包括自定义过滤器和Spring Security内置过滤器。

通过理解这些概念，可以更好地配置Spring Security，确保过滤器和授权规则按照预期工作。

# 12. mybatis plus动态数据源如何指定mapper扫描路径？
在使用MyBatis-Plus动态数据源时，可以通过配置`SqlSessionFactory`的`MapperScannerConfigurer`来指定Mapper接口的扫描路径。

### 使用MapperScannerConfigurer扫描Mapper接口

首先，在配置类或配置文件中定义`MapperScannerConfigurer`，并设置要扫描的Mapper接口的包路径。

#### Java配置示例：

```java
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@MapperScan(basePackages = "com.example.mapper")
public class MyBatisConfig {
    
    // 配置数据源和SqlSessionFactory等

    // 配置MapperScannerConfigurer扫描Mapper接口
    @Bean
    public MapperScannerConfigurer mapperScannerConfigurer() {
        MapperScannerConfigurer scannerConfigurer = new MapperScannerConfigurer();
        scannerConfigurer.setBasePackage("com.example.mapper");
        return scannerConfigurer;
    }
}
```

#### XML配置示例：

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:mybatis-spring="http://mybatis.org/schema/mybatis-spring"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://mybatis.org/schema/mybatis-spring
                           http://mybatis.org/schema/mybatis-spring-2.0.xsd">

    <!-- 配置数据源和SqlSessionFactory等 -->

    <!-- 配置MapperScannerConfigurer扫描Mapper接口 -->
    <mybatis-spring:scan base-package="com.example.mapper"/>

</beans>
```

### 配置动态数据源

在配置动态数据源时，需要确保`SqlSessionFactory`使用了正确的数据源。通常，可以通过`SqlSessionFactoryBean`来配置`SqlSessionFactory`，并在其中指定数据源。

#### Java配置示例：

```java
import org.apache.ibatis.session.SqlSessionFactory;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;

import javax.sql.DataSource;

@Configuration
public class MyBatisConfig {

    // 配置数据源和事务管理器等...

    // 配置SqlSessionFactory，并指定数据源
    @Bean
    public SqlSessionFactory sqlSessionFactory(@Qualifier("dynamicDataSource") DataSource dataSource) throws Exception {
        SqlSessionFactoryBean sessionFactoryBean = new SqlSessionFactoryBean();
        sessionFactoryBean.setDataSource(dataSource);
        sessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath*:mapper/*.xml"));
        return sessionFactoryBean.getObject();
    }

    // 配置事务管理器
    @Bean
    public DataSourceTransactionManager transactionManager(@Qualifier("dynamicDataSource") DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}
```

在上面的配置中，`SqlSessionFactoryBean`被配置为使用动态数据源`dynamicDataSource`，并且通过`setMapperLocations`指定了Mapper XML文件的位置。

请根据实际项目中的具体情况，调整以上配置，确保动态数据源和Mapper扫描路径正确配置，以便MyBatis-Plus正常工作。

# 13. 也就是说，mybatis plus默认的动态数据源作为bean的名称就是dynamicDataSource吗？
是的，MyBatis-Plus默认的动态数据源的Bean名称是`dynamicDataSource`。这是因为在MyBatis-Plus中，动态数据源的配置通常使用`DynamicDataSourceContextHolder`来动态切换数据源，而`DynamicDataSourceContextHolder`默认使用的数据源Bean名称就是`dynamicDataSource`。

当你在配置MyBatis-Plus时没有显式指定动态数据源的Bean名称时，MyBatis-Plus会使用默认的`dynamicDataSource`作为动态数据源的Bean名称。这也是为了与MyBatis-Plus内部的一些默认配置保持一致性，方便使用者在没有特殊需求时直接使用默认配置。

# 14. 使用mybatisplus的动态数据源自动配置了3个数据源，但是每个数据源的mapper location不一样，需要手动指定，包括需要自定义sqlsessionFactory绑定对应的数据源，这个应该如何实现？
在使用MyBatis-Plus的动态数据源时，如果需要自动配置多个数据源，并且每个数据源的Mapper XML文件位置不同，你可以通过以下步骤实现：

1. 配置多个数据源。
2. 分别指定每个数据源对应的Mapper XML文件位置。
3. 使用自定义的`SqlSessionFactory`将每个数据源绑定到对应的Mapper XML文件位置。

下面是一个示例代码：

```java
import org.apache.ibatis.session.SqlSessionFactory;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.Resource;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;

import javax.sql.DataSource;
import java.io.IOException;

@Configuration
public class MyBatisConfig {

    @Bean(name = "dataSource1")
    public DataSource dataSource1() {
        // 配置第一个数据源
        // return yourDataSource1;
    }

    @Bean(name = "dataSource2")
    public DataSource dataSource2() {
        // 配置第二个数据源
        // return yourDataSource2;
    }

    @Bean(name = "dataSource3")
    public DataSource dataSource3() {
        // 配置第三个数据源
        // return yourDataSource3;
    }

    // 配置事务管理器
    @Bean
    public DataSourceTransactionManager transactionManager(@Qualifier("dynamicDataSource") DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }

    // 配置动态数据源
    @Bean(name = "dynamicDataSource")
    public DynamicRoutingDataSource dynamicDataSource(@Qualifier("dataSource1") DataSource dataSource1,
                                                       @Qualifier("dataSource2") DataSource dataSource2,
                                                       @Qualifier("dataSource3") DataSource dataSource3) {
        DynamicRoutingDataSource dynamicDataSource = new DynamicRoutingDataSource();
        dynamicDataSource.setDefaultTargetDataSource(dataSource1);
        
        // 设置多个数据源
        dynamicDataSource.setTargetDataSources(DataSources.buildDataSourceMap(dataSource1, dataSource2, dataSource3));

        return dynamicDataSource;
    }

    // 配置SqlSessionFactory
    @Bean
    public SqlSessionFactory sqlSessionFactory(@Qualifier("dynamicDataSource") DataSource dynamicDataSource) throws Exception {
        SqlSessionFactoryBean sessionFactoryBean = new SqlSessionFactoryBean();
        sessionFactoryBean.setDataSource(dynamicDataSource);

        // 指定每个数据源对应的Mapper XML文件位置
        sessionFactoryBean.setMapperLocations(resolveMapperLocations("classpath*:mapper1/*.xml", "classpath*:mapper2/*.xml", "classpath*:mapper3/*.xml"));

        return sessionFactoryBean.getObject();
    }

    private Resource[] resolveMapperLocations(String... locations) throws IOException {
        PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
        Resource[][] resources = new Resource[locations.length][];

        for (int i = 0; i < locations.length; i++) {
            resources[i] = resolver.getResources(locations[i]);
        }

        Resource[] mergedResources = new Resource[0];
        for (Resource[] resourcesArray : resources) {
            mergedResources = mergeArray(mergedResources, resourcesArray);
        }

        return mergedResources;
    }

    private Resource[] mergeArray(Resource[] array1, Resource[] array2) {
        Resource[] mergedArray = new Resource[array1.length + array2.length];
        System.arraycopy(array1, 0, mergedArray, 0, array1.length);
        System.arraycopy(array2, 0, mergedArray, array1.length, array2.length);
        return mergedArray;
    }
}
```

在上面的代码中：

- 使用`DataSourceTransactionManager`配置事务管理器。
- 使用`DynamicRoutingDataSource`配置动态数据源，并将多个数据源通过`DataSources.buildDataSourceMap`方法添加到动态数据源中。
- 使用`SqlSessionFactoryBean`配置`SqlSessionFactory`，并通过`setMapperLocations`指定每个数据源对应的Mapper XML文件位置。

需要根据实际情况替换代码中的注释部分，配置具体的数据源和Mapper XML文件位置。这样就可以实现MyBatis-Plus的动态数据源，每个数据源可以对应不同的Mapper XML文件位置。

# 15. 这种情况下，mybatis plus的动态数据源自动配置还会生效吗？
在这种情况下，MyBatis-Plus的动态数据源自动配置不会生效，因为你手动配置了多个数据源并且需要自定义`SqlSessionFactory`来绑定对应的数据源和Mapper XML文件位置。动态数据源的自动配置通常是针对单个数据源的情况，而在手动配置多个数据源并且需要自定义`SqlSessionFactory`时，你需要自己负责数据源的切换和配置。

动态数据源的自动配置通常是通过`MybatisPlusAutoConfiguration`来实现的，它会自动读取配置文件中的数据源配置，并根据配置创建对应的数据源。但是，在手动配置多个数据源时，你需要自己负责创建和管理这些数据源，并且将它们正确地绑定到`SqlSessionFactory`中。

因此，在手动配置多个数据源并自定义`SqlSessionFactory`的情况下，MyBatis-Plus的动态数据源自动配置不会生效，需要你手动管理数据源和`SqlSessionFactory`的配置。

# 16. 也就是说使用mybatis plus的动态数据源功能，实际上就已经不支持自定通过编码的方式来更改某些数据源的属性了是不？
是的，使用MyBatis-Plus的动态数据源功能时，通常会使用配置文件的方式来定义数据源，比如在`application.properties`或`application.yml`中配置多个数据源，并通过`@ConfigurationProperties`或`@Value`来读取这些配置。这种方式下，数据源的属性（比如URL、用户名、密码等）是在启动时从配置文件中读取的，因此在运行时通过编码的方式更改数据源的属性可能会比较困难。

如果需要在运行时动态更改数据源的属性，可能需要使用额外的工具或技术来实现。例如，可以考虑使用数据库连接池的动态数据源切换功能（比如HikariCP的`HikariDataSource`支持动态更改配置）或者使用第三方的动态数据源管理库。

总的来说，MyBatis-Plus的动态数据源功能主要用于在启动时根据配置文件自动创建和管理多个数据源，并且在不同的环境下切换数据源。如果需要在运行时动态更改数据源的属性，可能需要借助其他工具或库来实现。

# 17. 那mybatis plus中动态数据源如何指定mapper location呢？
在MyBatis-Plus中，动态数据源并没有直接提供指定Mapper XML文件位置的功能。通常情况下，MyBatis-Plus会使用默认的Mapper XML文件位置，即在classpath下的`mapper`目录或其子目录中。但是，如果需要指定不同数据源对应的Mapper XML文件位置，可以通过以下方式实现：

1. **手动配置SqlSessionFactory**：自定义一个`SqlSessionFactory`的配置类，在其中指定每个数据源对应的Mapper XML文件位置。

2. **使用多个SqlSessionFactory**：对于每个数据源，可以创建一个单独的`SqlSessionFactory`，并在配置中指定对应的Mapper XML文件位置。

下面是一个示例代码，演示如何通过手动配置`SqlSessionFactory`来指定不同数据源对应的Mapper XML文件位置：

```java
import org.apache.ibatis.session.SqlSessionFactory;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.Resource;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;

import javax.sql.DataSource;
import java.io.IOException;

@Configuration
public class MyBatisConfig {

    @Bean(name = "dataSource1")
    public DataSource dataSource1() {
        // 配置第一个数据源
        // return yourDataSource1;
    }

    @Bean(name = "dataSource2")
    public DataSource dataSource2() {
        // 配置第二个数据源
        // return yourDataSource2;
    }

    // 配置事务管理器
    @Bean
    public DataSourceTransactionManager transactionManager(@Qualifier("dynamicDataSource") DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }

    // 配置动态数据源
    @Bean(name = "dynamicDataSource")
    public DynamicRoutingDataSource dynamicDataSource(@Qualifier("dataSource1") DataSource dataSource1,
                                                       @Qualifier("dataSource2") DataSource dataSource2) {
        DynamicRoutingDataSource dynamicDataSource = new DynamicRoutingDataSource();
        dynamicDataSource.setDefaultTargetDataSource(dataSource1);
        dynamicDataSource.setTargetDataSources(DataSources.buildDataSourceMap(dataSource1, dataSource2));

        return dynamicDataSource;
    }

    // 配置SqlSessionFactory1
    @Bean
    public SqlSessionFactory sqlSessionFactory1(@Qualifier("dataSource1") DataSource dataSource1) throws Exception {
        SqlSessionFactoryBean sessionFactoryBean = new SqlSessionFactoryBean();
        sessionFactoryBean.setDataSource(dataSource1);
        sessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath*:mapper1/*.xml"));

        return sessionFactoryBean.getObject();
    }

    // 配置SqlSessionFactory2
    @Bean
    public SqlSessionFactory sqlSessionFactory2(@Qualifier("dataSource2") DataSource dataSource2) throws Exception {
        SqlSessionFactoryBean sessionFactoryBean = new SqlSessionFactoryBean();
        sessionFactoryBean.setDataSource(dataSource2);
        sessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath*:mapper2/*.xml"));

        return sessionFactoryBean.getObject();
    }
}
```

在上面的示例中，我们手动配置了两个数据源（`dataSource1`和`dataSource2`），并为每个数据源创建了对应的`SqlSessionFactory`（`sqlSessionFactory1`和`sqlSessionFactory2`），同时指定了不同数据源对应的Mapper XML文件位置（`classpath*:mapper1/*.xml`和`classpath*:mapper2/*.xml`）。

需要注意的是，上述示例代码中的`DataSource`、`DynamicRoutingDataSource`、`DataSources`等类是虚拟的，你需要根据实际情况替换为对应的类和配置。

# 18. 如果在mybatisPlus中配置了TenantLineHandler 后，在对目标表进行insert操作时，也会自动加上tenant字段吗？
在MyBatis-Plus中，配置了`TenantLineHandler`之后，它主要负责在**查询（select）**和**更新（update）**操作时自动添加租户字段的过滤条件。但是对于`insert`操作，默认情况下，**MyBatis-Plus不会自动添加租户字段**。

如果你希望在`insert`操作时也自动填充租户字段，你需要手动处理该字段，可以通过以下两种方式来实现：

### 1. 使用 MyBatis-Plus 的 `MetaObjectHandler` 自动填充租户字段

`MetaObjectHandler` 是 MyBatis-Plus 提供的一个功能，允许在插入或更新操作时自动填充一些字段。你可以通过实现`MetaObjectHandler`接口，在`insert`时自动为租户字段赋值。

示例代码：

```java
import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
import org.apache.ibatis.reflection.MetaObject;
import org.springframework.stereotype.Component;

@Component
public class MyMetaObjectHandler implements MetaObjectHandler {

    @Override
    public void insertFill(MetaObject metaObject) {
        // 自动填充租户ID字段
        this.strictInsertFill(metaObject, "tenantId", String.class, getTenantId());
    }

    @Override
    public void updateFill(MetaObject metaObject) {
        // 如果需要，更新时也可以填充其他字段
    }

    private String getTenantId() {
        // 这里实现你的获取当前租户ID的逻辑
        return TenantContextHolder.getTenantId();
    }
}
```

在上面的代码中，`insertFill`方法会在执行`insert`操作时自动为`tenantId`字段赋值。`getTenantId`方法可以从你的上下文中获取当前租户ID。

### 2. 手动在插入时设置租户字段

另一种方法是在插入数据时手动设置租户字段。你可以在业务逻辑中直接设置实体对象的租户字段，然后进行`insert`操作。

```java
public class YourService {
    public void saveEntity(Entity entity) {
        // 手动设置租户ID
        entity.setTenantId(TenantContextHolder.getTenantId());
        // 执行插入操作
        yourMapper.insert(entity);
    }
}
```

### 结论

- **查询、更新操作**：`TenantLineHandler`会自动为SQL语句添加租户条件。
- **插入操作**：需要手动处理租户字段，通常通过`MetaObjectHandler`实现自动填充，或者在业务逻辑中手动赋值。

`TenantLineHandler`在`insert`时不会自动加入租户字段，因此需要通过上述方式确保插入数据时包含正确的租户ID。

# 19. 不对啊，我发现在debug时，它自动在insert前给加上tenantId了。
你是对的，MyBatis-Plus 在启用多租户功能（通过 `TenantLineHandler`）时，会自动在 **所有 SQL 操作（包括 `select`、`update`、`delete` 以及 `insert`）** 中处理租户字段。这意味着在 `insert` 操作时，MyBatis-Plus 也会自动为租户字段赋值。

当你配置了 `TenantLineHandler`，它不仅会在查询和更新操作中自动加上租户条件，还会在插入数据时自动处理租户字段。也就是说，如果你的表中有租户字段（如 `tenant_id`），MyBatis-Plus 会在执行 `insert` 之前根据 `TenantLineHandler` 的逻辑自动将当前的租户 ID 添加到插入的数据中。

### 为什么会自动填充 `tenantId`？

当你使用 MyBatis-Plus 的多租户功能时，`TenantLineHandler` 的实现会在处理 SQL 语句之前，自动对 SQL 进行改写。对于 `insert` 操作，MyBatis-Plus 会在你插入的数据中加入租户字段（例如 `tenantId`），所以你在调试时发现了这个行为。

### 具体原理

`TenantLineHandler` 实现的作用是在 SQL 被执行之前，对 SQL 进行修改，确保多租户字段（例如 `tenant_id`）正确地加入到查询条件或插入数据中。具体原理如下：

1. **查询、更新、删除操作**：MyBatis-Plus 会在 SQL 语句的 `where` 部分加入租户条件，以确保只对当前租户的数据进行操作。
   
2. **插入操作**：当执行 `insert` 时，MyBatis-Plus 会在生成的 SQL 中自动将租户字段添加到插入的数据中。

这意味着你不需要显式地在业务代码中手动设置租户字段，`TenantLineHandler` 会自动完成这项工作。

### 示例：

假设你有以下租户表结构：

```sql
CREATE TABLE user (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255),
    tenant_id BIGINT
);
```

当配置了 `TenantLineHandler` 后，执行插入操作时，即使你在实体类中没有显式设置 `tenant_id`，MyBatis-Plus 也会自动为该字段赋值。

```java
User user = new User();
user.setName("John");
// 没有显式设置 tenant_id

userMapper.insert(user);
```

在执行时，MyBatis-Plus 会自动在 `insert` 语句中填充 `tenant_id` 字段。

生成的 SQL 类似于：

```sql
INSERT INTO user (name, tenant_id) VALUES ('John', 123); -- 123 是当前的租户ID
```

### 结论

你观察到的现象是正确的：配置了 `TenantLineHandler` 后，MyBatis-Plus 会在 `insert` 时自动添加租户字段 `tenantId`，无需手动设置。这是 MyBatis-Plus 为了支持多租户自动处理的行为。

如果你有其他自定义的逻辑或者特殊需求，可以结合 `MetaObjectHandler` 或手动处理租户字段。
