---
layout:     post
title:      分布式锁
subtitle:   熟悉分布式锁的各种场景
categories: [零散知识点]
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---

# 1. 什么是分布式锁？
从单服务器架构开发过来的朋友们应该都知道，使用java开发的服务部署在单个的tomcat服务器上，则整个应用程序都运行在同一个物理机器上，并且整个应用程序启动后，其JVM也始终在一个服务器上运行。因此，这种单体架构，我们是不需要使用分布式锁的。    
对于这种单体架构，直接使用JVM内部的java线程锁即可，即Synchronized或者Lock等一些基于JVM内存设计的单应用锁即可。    
应用程序为什么需要使用锁？其原因还是为了防止在并发场景下，临界资源的多线程并发访问安全性问题。在单体应用中，直接使用多线程并发策略比如Synchronized、ThreadLocal等操作即可对临界资源做线程安全保证。   
但是，目前的服务部署架构都是多节点多pod部署，即同一个应用服务会同时部署在多个物理机器节点上，这个一来，整个微服务体系本质上就是一个集群部署模式了。     
在集群部署模式下，多个pod都部署相同的代码，那么意味着多个pod都会运行各自的JVM，此时，当客户端并发访问同一个业务资源时，单个JVM的单体锁就只能保证当前节点的临界资源安全性了。对于多个pod都需要同时操作三方共享的临界资源比如redis、数据库等时，此时单个JVM的单体锁就没法实现并发环境下的线程安全问题。   
因此，要保证**在分布式并发场景下，多个pod节点的共享临界资源的线程安全性问题，就需要使用分布式锁机制**。    
要实现分布式锁，肯定需要借助公共的三方组件去实现，而不能依赖JVM。即需要一个三方组件，来管理分布式部署的多个应用节点之前的共享锁问题。   

# 2.业界实现分布式锁的方式
目前来看，在java 微服务生态中，实现分布式锁的常见方式是：    
1.使用redis来实现。   
2.使用zookeeper来实现。   

其中，使用redis来实现的话，具体又划分为基本的redis的setNx命令来实现；和目前更先进的redisson来实现。   
我们只分析使用redis来实现分不锁的各种方式。   

# 3.redisson实现多锁

