---
layout:     post
title:      分布式锁
subtitle:   熟悉分布式锁的各种场景
categories: [零散知识点]
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---

# 1. 什么是分布式锁？
从单服务器架构开发过来的朋友们应该都知道，使用java开发的服务部署在单个的tomcat服务器上，则整个应用程序都运行在同一个物理机器上，并且整个应用程序启动后，其JVM也始终在一个服务器上运行。因此，这种单体架构，我们是不需要使用分布式锁的。    
对于这种单体架构，直接使用JVM内部的java线程锁即可，即Synchronized或者Lock等一些基于JVM内存设计的单应用锁即可。    
应用程序为什么需要使用锁？其原因还是为了防止在并发场景下，临界资源的多线程并发访问安全性问题。在单体应用中，直接使用多线程并发策略比如Synchronized、ThreadLocal等操作即可对临界资源做线程安全保证。   
但是，目前的服务部署架构都是多节点多pod部署，即同一个应用服务会同时部署在多个物理机器节点上，这个一来，整个微服务体系本质上就是一个集群部署模式了。     
在集群部署模式下，多个pod都部署相同的代码，那么意味着多个pod都会运行各自的JVM，此时，当客户端并发访问同一个业务资源时，单个JVM的单体锁就只能保证当前节点的临界资源安全性了。对于多个pod都需要同时操作三方共享的临界资源比如redis、数据库等时，此时单个JVM的单体锁就没法实现并发环境下的线程安全问题。   
因此，要保证**在分布式并发场景下，多个pod节点的共享临界资源的线程安全性问题，就需要使用分布式锁机制**。    
要实现分布式锁，肯定需要借助公共的三方组件去实现，而不能依赖JVM。即需要一个三方组件，来管理分布式部署的多个应用节点之前的共享锁问题。   

# 2.业界实现分布式锁的方式
目前来看，在java 微服务生态中，实现分布式锁的常见方式是：    
1.使用redis来实现。   
2.使用zookeeper来实现。   

其中，使用redis来实现的话，具体又划分为基本的redis的setNx命令来实现；和目前更先进的redisson来实现。   
我们只分析使用redis来实现分不锁的各种方式。   

# 3.redis实现分布式锁的方式

# 4.redisson实现分布式锁的方式

# 5.redisson实现多锁
我们直接以“双锁”作为一种特殊多锁来进行分析。   
双锁的典型使用场景：   
“**Redisson双锁**”设计，是分布式系统中一个非常常见但容易出错的高级场景。下面我会从设计原则 → 典型示例 → 死锁成因 → 完全规避方案，逐步讲清楚。

---

## 🧩 5.1、双锁的典型使用场景

我们先明确“为什么要双锁”：

例如，你有两个层级的资源：

* 一级锁：控制全局访问（如整个业务模块）
* 二级锁：控制具体业务实例（如某个订单、某个商户）

例如：

```text
primaryKey = "biz:lock:merchant:123"
secondaryKey = "biz:lock:order:456"
```

希望做到：
1️⃣ 同一商户下的操作串行化；
2️⃣ 同一订单内的操作也串行化；
3️⃣ 不同商户间互不影响。

---

## 🧠 5.2、双锁的基本实现方式

Redisson 的锁使用 `RLock` 实现，典型写法如下：

```java
RLock lock1 = redissonClient.getLock(primaryKey);
RLock lock2 = redissonClient.getLock(secondaryKey);

// 定义一个联合锁（RedissonMultiLock 会同时持有多个锁）
RLock multiLock = redissonClient.getMultiLock(lock1, lock2);

boolean locked = multiLock.tryLock(5, 10, TimeUnit.SECONDS);
try {
    if (locked) {
        // 业务逻辑
    }
} finally {
    if (locked) {
        multiLock.unlock();
    }
}
```

🟢 **解释：**

* `tryLock(waitTime, leaseTime)`：等待时间 + 持有时间。
* `RMultiLock` 会在底层顺序获取所有锁（默认是顺序加锁）。
* 所有锁都加成功才算成功，否则会释放已加的锁。

---

## ⚠️ 5.3、双锁设计中最常见的死锁原因

### ❌ 1. 获取顺序不一致

假设线程A和线程B都需要锁1和锁2：

* A：先拿锁1 → 再拿锁2；
* B：先拿锁2 → 再拿锁1；
  → 死锁！

### ❌ 2. 部分锁加成功但异常退出

Redisson 的 `multiLock` 会尝试加完所有锁，但如果中途出异常（例如 Redis 网络闪断），可能会留下部分锁被加上但未释放。

### ❌ 3. 锁续期时间不足

如果任务执行时间超出 `leaseTime`，而没有 watchDog 自动续期，则锁可能过早释放，引起并发修改。

---

## ✅ 5.4、完全规避死锁的设计方案

下面是一个**可以完全避免死锁**的推荐设计，分为三种方式：

---

### ✅ 方案1：始终使用 `RMultiLock`（推荐）

**思路：**
统一通过 `RMultiLock` 同时持有多个锁，而不是自己先后 tryLock。

```java
RLock lock1 = redissonClient.getLock(primaryKey);
RLock lock2 = redissonClient.getLock(secondaryKey);

// 注意：RMultiLock 内部严格保证获取顺序相同，避免交叉死锁
RLock multiLock = redissonClient.getMultiLock(lock1, lock2);

boolean locked = multiLock.tryLock(5, 30, TimeUnit.SECONDS);
try {
    if (locked) {
        // 执行业务逻辑
    } else {
        // 未获取到锁，可直接丢弃任务或重试
    }
} finally {
    if (locked) {
        multiLock.unlock();
    }
}
```

**优点：**

* 加锁、释放锁都原子性处理；
* 顺序一致；
* 不会出现部分加锁的情况；
* Redisson内部自动处理续期（watchDog机制）。

**注意：**
`RMultiLock` 的加锁逻辑是串行的，如果锁数多（>3），加锁耗时会稍大。

---

### ✅ 方案2：强制锁顺序 + 超时释放（适用于不使用MultiLock的情况）

如果你坚持要分两次tryLock（因为业务上不一定两个锁都总是需要）：

```java
RLock lock1 = redissonClient.getLock(primaryKey);
RLock lock2 = redissonClient.getLock(secondaryKey);

boolean locked1 = false;
boolean locked2 = false;

try {
    // 固定顺序：先锁1再锁2
    locked1 = lock1.tryLock(5, 30, TimeUnit.SECONDS);
    if (!locked1) return false;

    locked2 = lock2.tryLock(5, 30, TimeUnit.SECONDS);
    if (!locked2) return false;

    // 业务逻辑
} finally {
    if (locked2) lock2.unlock();
    if (locked1) lock1.unlock();
}
```

**防死锁关键点：**

* 永远保证锁获取顺序一致（所有线程一致！）；
* tryLock 都有超时；
* finally 中严格按逆序释放；
* 出现任一失败立即释放前面锁。

---

### ✅ 方案3：逻辑合并 → 单一复合锁Key

有时双锁完全没必要。
可以通过 **业务Key拼接**，形成一个唯一性强的单锁：

```java
String combinedKey = "biz:lock:" + merchantId + ":" + orderId;
RLock lock = redissonClient.getLock(combinedKey);
```

优点：

* 逻辑简单；
* 无死锁风险；
* 性能最高。

缺点：

* 粒度较粗；
* 不能单独控制部分锁。

---

## 🧯 5.5、死锁防御 checklist

| 问题    | 防御策略                            |
| ----- | ------------------------------- |
| 锁顺序不同 | 所有地方加锁顺序必须一致                    |
| 某锁未释放 | try/finally 严格释放                |
| 网络闪断  | 使用 RedissonMultiLock            |
| 加锁太久  | 使用合理 leaseTime 或启用 watchDog     |
| 加锁失败  | tryLock + 超时参数，不要用 lock() 阻塞式方法 |

---

## ✅ 5.6、推荐模板代码（生产可用）

```java
public boolean executeWithDoubleLock(String key1, String key2, Runnable task) {
    RLock lock1 = redissonClient.getLock(key1);
    RLock lock2 = redissonClient.getLock(key2);
    RLock multiLock = redissonClient.getMultiLock(lock1, lock2);

    boolean locked = false;
    try {
        locked = multiLock.tryLock(5, 30, TimeUnit.SECONDS);
        if (!locked) {
            log.warn("Double lock acquisition failed: {}, {}", key1, key2);
            return false;
        }
        task.run();
        return true;
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return false;
    } catch (Exception e) {
        log.error("Error during double lock execution", e);
        return false;
    } finally {
        if (locked) {
            try {
                multiLock.unlock();
            } catch (Exception e) {
                log.warn("Failed to unlock multiLock", e);
            }
        }
    }
}
```

## 🔒5.7 结论总结

| 场景        | 推荐方案            | 死锁风险   |
| --------- | --------------- | ------ |
| 两个锁始终成对出现 | ✅ `RMultiLock`  | 🚫 无死锁 |
| 两个锁可单独存在  | ✅ 固定加锁顺序 + 超时释放 | ⚠️ 需谨慎 |
| 双锁逻辑可以简化  | ✅ 单锁Key拼接       | 🚫 无死锁 |

# 6.redisson实现同一把锁来控制两套逻辑之前的线程调度避让问题
背景：   
我现在有两个定时任务，抢占同一个分布式锁，现在任务A需要给任务B让行，即当xxlJob的B任务在执行时，xxlJob发起的A任务就需要直接空消费，直接结束。我想的是B任务通过redisson的lock一直等待，而A任务通过redisson的tryLock直接获取，非阻塞的，只要获取不到就结束。现在我在考虑，有没有可能redisson在操作A任务时候，因为A任务会远远不断的进来，而B任务也会源源不断的进来，有没有一个临界点，导致A任务一直都会获取到锁，而B任务一直获取不到锁，这样就失去了A给B让行的目标了。   

非常好的问题。
你提出的这个问题，其实是分布式锁调度策略里最**微妙、容易忽略**的竞争条件之一：

> A 用非阻塞 tryLock()，B 用阻塞 lock()，理论上 B “优先”，但实际上可能出现 A 抢占饥饿（starvation）的问题。

我们一步步分析：

---

## 🧩 6.1、你的当前设计（总结）

* A任务（低优先级）：`tryLock()` → 获取不到立即返回；
* B任务（高优先级）：`lock()` → 阻塞等待；
* 目标：

  * 当 B 在执行时，A 立即退出（达成 ✅）；
  * 当 A 执行时，B 应该尽快获得锁（避免饥饿 🚫）。

**问题：**
当 A 的执行频率高、Redisson 的解锁和加锁之间存在微秒级的间隙时，就可能发生 **锁“被A连续抢占”** 的现象。
也就是说：

> B 一直在等待，但因为 A 一直频繁地在释放后马上又抢到锁，B 永远进不来。

---

## ⚠️ 6.2、为什么会出现“B一直抢不到锁”

这是典型的 **无公平锁（non-fair lock）** 行为。

Redisson 的分布式锁（`RLock`）默认是 **非公平锁**：

* 谁抢得快谁拿到锁；
* 没有排队顺序；
* Redis 不会记录哪个线程等得久。

---

## 🎯 6.3、想要“让行”生效的关键条件

为了让 B 优先，A 必须满足两点：

1. **A 必须短时间占用锁**（保持轻量，快速释放）；
2. **A 必须在发现有 B 等待时主动放弃抢占**。

但问题在于第二点 —— Redis 的锁没有“等待队列”这个概念，
所以 Redisson 无法让 A 知道“B 正在等待”。

---

## 🧠 6.4、可行的解决方案（从简单到完善）

---

### ✅ 方案 1：A 任务设置短锁 + 随机退避（推荐）

让 A 在 tryLock 失败后立即退出，并在下次调度前引入 **随机退避延迟**。

```java
boolean locked = lock.tryLock(0, 5, TimeUnit.SECONDS);
if (!locked) {
    // 获取失败，直接退出
    return;
}
try {
    // 执行轻量逻辑
} finally {
    lock.unlock();
}
```

> 额外优化：A 任务调度间隔 = 固定间隔 + 随机偏移（例如 +0~3 秒），避免与 B 同步竞争。

📈 优点：

* 简单；
* A 任务自动“让行”；
* B 任务在等待过程中，只要 A 稍微错过一轮就能成功获得锁。

📉 缺点：

* 无严格优先级保证（仅概率上 B 先拿到）。

---

### ✅ 方案 2：B 启动时标记“优先模式”，A 检测到后直接放弃

使用一个 **Redis 标志位** 来让 A 主动退让。

```java
String keyLock = "biz:lock:main";
String keyPriority = "biz:lock:main:priority";

RBucket<String> priorityFlag = redissonClient.getBucket(keyPriority);

// B任务启动时，设置优先标志
priorityFlag.set("B_RUNNING", 10, TimeUnit.MINUTES);

RLock lock = redissonClient.getLock(keyLock);
lock.lock();  // 阻塞等待
try {
    // 执行B的逻辑
} finally {
    lock.unlock();
    priorityFlag.delete();
}
```

A任务执行前检测：

```java
if (priorityFlag.isExists()) {
    // B正在执行，A直接退出
    return;
}

RLock lock = redissonClient.getLock(keyLock);
boolean locked = lock.tryLock(0, 5, TimeUnit.SECONDS);
if (!locked) return;

try {
    // 执行A逻辑
} finally {
    lock.unlock();
}
```

✅ 优点：

* 100% 逻辑优先保证；
* 无需公平锁；
* 可灵活控制标志TTL。

---

### ✅ 方案 3：使用 Redisson 的 **公平锁 RFairLock**

Redisson 提供了 `getFairLock()`，可以保证获取顺序（FIFO队列），避免“饥饿”。

```java
RLock lock = redissonClient.getFairLock("biz:lock:main");
```

特点：

* 所有请求按进入时间排队；
* B 不会一直等；
* A 也不会插队。

⚠️ 缺点：

* 性能较 `RLock` 稍低；
* Redis 内部维护等待队列；
* 不适合高频短锁（会放大延迟）。

适合：

* A、B 频率都较低；
* 你确实需要顺序公平性。

---

### ✅ 方案 4：A / B 使用不同锁等级

如果你能改造锁粒度，可以让 B 使用“更大范围”的锁：

```text
A -> lock:biz:task:A
B -> lock:biz:task:*
```

在 Redis 层约定：

* B 的锁 key 更“粗粒度”；
* A 拿的是它的子锁；
* B 在执行前会先检测是否有任何子锁存在。

这种方案类似“双锁升级”，但实现复杂，一般不推荐 unless 你确实要细粒度控制。

---

## 💡 6.5、综合建议（你这种XXLJob场景）

| 目标   | 推荐方案                        | 说明            |
| ---- | --------------------------- | ------------- |
| 简单稳定 | ✅ 方案 2（Redis优先标志 + tryLock） | A轻量，B占主导，确定性高 |
| 公平性强 | ✅ 方案 3（RFairLock）           | 顺序公平，避免饥饿     |
| 高频短锁 | ✅ 方案 1（随机退避）                | 实现简单，性能最好     |

---

## 📘 6.6、实战模板（方案 2 推荐）

```java
String lockKey = "biz:lock:core";
String priorityKey = lockKey + ":priority";

RBucket<String> priorityFlag = redissonClient.getBucket(priorityKey);
RLock lock = redissonClient.getLock(lockKey);

// === B任务（高优先级）===
try {
    priorityFlag.set("B_RUNNING", 10, TimeUnit.MINUTES);
    lock.lock();
    // 业务逻辑...
} finally {
    lock.unlock();
    priorityFlag.delete();
}

// === A任务（低优先级）===
if (priorityFlag.isExists()) {
    // B在执行，直接让行
    return;
}

boolean locked = lock.tryLock(0, 5, TimeUnit.SECONDS);
if (!locked) return;

try {
    // A任务逻辑...
} finally {
    lock.unlock();
}
```

✅ 这样，A **永远不会阻塞 B**，
也不会出现 A 抢占饥饿的情况。

---
# 67.redisson内部如何保证获取锁的lock对象和释放锁的lock对象是同一个对象呢？
比如下面的伪代码逻辑👇

```java
RLock lock1 = redissonClient.getLock("myLockKey");
lock1.lock();

try {
    // 业务逻辑
} finally {
    RLock lock2 = redissonClient.getLock("myLockKey");
    lock2.unlock();
}
```

关键问题是：

> `lock1` 和 `lock2` 是通过同一个 key 创建的两个不同对象实例，这样释放锁有效吗？

---

✅ **答案：有效。**

只要你使用的是 **同一个 RedissonClient 实例**，并且传入的是 **同一个锁 key**（例如 `"myLockKey"`），
Redisson 在内部会确保这些锁对象引用的是同一个 Redis 层面的分布式锁。

---

### 🔍 原理解释

Redisson 的 `getLock(String key)` 方法并不是每次都去 Redis 新建一个锁对象，而是：

* 它在 **客户端本地（Redisson 内部的 Lock 实现）** 创建一个代理对象；
* 这个对象内部只是记录 key，并通过 Lua 脚本等机制去 Redis 执行锁操作；
* Redis 层面实际上是操作同一个 `key`（比如 `redisson_lock:{myLockKey}`）。

所以无论你通过 `getLock("myLockKey")` 获取多少次 lock 对象，它们最终都会对应 Redis 上的同一个锁资源。

换句话说：

> “是否是同一个 Java 对象”无关紧要，重要的是“是否是同一个 Redis key”。

---

### ⚠️ 但要注意的几个细节：

#### 1. 必须是同一个 `RedissonClient` 实例

如果你在 **不同的 RedissonClient 实例** 上调用：

```java
redissonClientA.getLock("myLockKey");
redissonClientB.getLock("myLockKey");
```

那就不一定安全了，因为不同 client 可能配置不同（包括不同 Redis 连接或序列化策略），
即使 key 相同，也可能出现 **无法识别锁持有者** 的问题。

#### 2. 解锁时必须是同一个线程或同一个租约（lease）

Redisson 的分布式锁是 **可重入锁**，会在 Redis 中记录锁的持有者（UUID + threadId）。
也就是说：

* 同一个线程可以重复加锁、解锁；
* 但如果你在另一个线程上执行 `unlock()`，会报错（`IllegalMonitorStateException`），
  因为 Redis 发现当前线程并不是持有锁的线程。

举个例子：

```java
RLock lock = redissonClient.getLock("lock");
lock.lock();

// ❌ 另一个线程中：
RLock lock2 = redissonClient.getLock("lock");
lock2.unlock(); // 会抛异常
```

---

### ✅ 推荐写法

虽然你现在的写法是“能工作”的（在同一个线程里），
但**更好的风格**是保持用同一个 lock 实例，代码可读性会更强：

```java
RLock lock = redissonClient.getLock("myLockKey");
lock.lock();
try {
    // do business
} finally {
    lock.unlock();
}
```

---

### ✅ 小结

| 问题                           | 结论                         |
| ---------------------------- | -------------------------- |
| 同一个 key 获取两次 lock 对象，释放是否有效？ | ✅ 有效（同一个 RedissonClient 下） |
| 不同 RedissonClient 获取 lock？   | ⚠️ 可能无效，取决于配置是否一致          |
| 不同线程解锁？                      | ❌ 不允许，会抛异常                 |
| 推荐实践                         | 同线程内获取和释放同一个 lock 实例       |

---


