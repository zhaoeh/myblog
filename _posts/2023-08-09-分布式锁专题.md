---
layout:     post
title:      分布式锁
subtitle:   熟悉分布式锁的各种场景
categories: [零散知识点]
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---

# 1. 什么是分布式锁？
从单服务器架构开发过来的朋友们应该都知道，使用java开发的服务部署在单个的tomcat服务器上，则整个应用程序都运行在同一个物理机器上，并且整个应用程序启动后，其JVM也始终在一个服务器上运行。因此，这种单体架构，我们是不需要使用分布式锁的。    
对于这种单体架构，直接使用JVM内部的java线程锁即可，即Synchronized或者Lock等一些基于JVM内存设计的单应用锁即可。    
应用程序为什么需要使用锁？其原因还是为了防止在并发场景下，临界资源的多线程并发访问安全性问题。在单体应用中，直接使用多线程并发策略比如Synchronized、ThreadLocal等操作即可对临界资源做线程安全保证。   
但是，目前的服务部署架构都是多节点多pod部署，即同一个应用服务会同时部署在多个物理机器节点上，这个一来，整个微服务体系本质上就是一个集群部署模式了。     
在集群部署模式下，多个pod都部署相同的代码，那么意味着多个pod都会运行各自的JVM，此时，当客户端并发访问同一个业务资源时，单个JVM的单体锁就只能保证当前节点的临界资源安全性了。对于多个pod都需要同时操作三方共享的临界资源比如redis、数据库等时，此时单个JVM的单体锁就没法实现并发环境下的线程安全问题。   
因此，要保证**在分布式并发场景下，多个pod节点的共享临界资源的线程安全性问题，就需要使用分布式锁机制**。    
要实现分布式锁，肯定需要借助公共的三方组件去实现，而不能依赖JVM。即需要一个三方组件，来管理分布式部署的多个应用节点之前的共享锁问题。   

# 2.业界实现分布式锁的方式
目前来看，在java 微服务生态中，实现分布式锁的常见方式是：    
1.使用redis来实现。   
2.使用zookeeper来实现。   

其中，使用redis来实现的话，具体又划分为基本的redis的setNx命令来实现；和目前更先进的redisson来实现。   
我们只分析使用redis来实现分不锁的各种方式。   

# 3.redis实现分布式锁的方式

# 4.redisson实现分布式锁的方式

# 5.redisson实现多锁
我们直接以“双锁”作为一种特殊多锁来进行分析。   
双锁的典型使用场景：   
“**Redisson双锁**”设计，是分布式系统中一个非常常见但容易出错的高级场景。下面我会从设计原则 → 典型示例 → 死锁成因 → 完全规避方案，逐步讲清楚。

---

## 🧩 5.1、双锁的典型使用场景

我们先明确“为什么要双锁”：

例如，你有两个层级的资源：

* 一级锁：控制全局访问（如整个业务模块）
* 二级锁：控制具体业务实例（如某个订单、某个商户）

例如：

```text
primaryKey = "biz:lock:merchant:123"
secondaryKey = "biz:lock:order:456"
```

希望做到：
1️⃣ 同一商户下的操作串行化；
2️⃣ 同一订单内的操作也串行化；
3️⃣ 不同商户间互不影响。

---

## 🧠 5.2、双锁的基本实现方式

Redisson 的锁使用 `RLock` 实现，典型写法如下：

```java
RLock lock1 = redissonClient.getLock(primaryKey);
RLock lock2 = redissonClient.getLock(secondaryKey);

// 定义一个联合锁（RedissonMultiLock 会同时持有多个锁）
RLock multiLock = redissonClient.getMultiLock(lock1, lock2);

boolean locked = multiLock.tryLock(5, 10, TimeUnit.SECONDS);
try {
    if (locked) {
        // 业务逻辑
    }
} finally {
    if (locked) {
        multiLock.unlock();
    }
}
```

🟢 **解释：**

* `tryLock(waitTime, leaseTime)`：等待时间 + 持有时间。
* `RMultiLock` 会在底层顺序获取所有锁（默认是顺序加锁）。
* 所有锁都加成功才算成功，否则会释放已加的锁。

---

## ⚠️ 5.3、双锁设计中最常见的死锁原因

### ❌ 1. 获取顺序不一致

假设线程A和线程B都需要锁1和锁2：

* A：先拿锁1 → 再拿锁2；
* B：先拿锁2 → 再拿锁1；
  → 死锁！

### ❌ 2. 部分锁加成功但异常退出

Redisson 的 `multiLock` 会尝试加完所有锁，但如果中途出异常（例如 Redis 网络闪断），可能会留下部分锁被加上但未释放。

### ❌ 3. 锁续期时间不足

如果任务执行时间超出 `leaseTime`，而没有 watchDog 自动续期，则锁可能过早释放，引起并发修改。

---

## ✅ 5.4、完全规避死锁的设计方案

下面是一个**可以完全避免死锁**的推荐设计，分为三种方式：

---

### ✅ 方案1：始终使用 `RMultiLock`（推荐）

**思路：**
统一通过 `RMultiLock` 同时持有多个锁，而不是自己先后 tryLock。

```java
RLock lock1 = redissonClient.getLock(primaryKey);
RLock lock2 = redissonClient.getLock(secondaryKey);

// 注意：RMultiLock 内部严格保证获取顺序相同，避免交叉死锁
RLock multiLock = redissonClient.getMultiLock(lock1, lock2);

boolean locked = multiLock.tryLock(5, 30, TimeUnit.SECONDS);
try {
    if (locked) {
        // 执行业务逻辑
    } else {
        // 未获取到锁，可直接丢弃任务或重试
    }
} finally {
    if (locked) {
        multiLock.unlock();
    }
}
```

**优点：**

* 加锁、释放锁都原子性处理；
* 顺序一致；
* 不会出现部分加锁的情况；
* Redisson内部自动处理续期（watchDog机制）。

**注意：**
`RMultiLock` 的加锁逻辑是串行的，如果锁数多（>3），加锁耗时会稍大。

---

### ✅ 方案2：强制锁顺序 + 超时释放（适用于不使用MultiLock的情况）

如果你坚持要分两次tryLock（因为业务上不一定两个锁都总是需要）：

```java
RLock lock1 = redissonClient.getLock(primaryKey);
RLock lock2 = redissonClient.getLock(secondaryKey);

boolean locked1 = false;
boolean locked2 = false;

try {
    // 固定顺序：先锁1再锁2
    locked1 = lock1.tryLock(5, 30, TimeUnit.SECONDS);
    if (!locked1) return false;

    locked2 = lock2.tryLock(5, 30, TimeUnit.SECONDS);
    if (!locked2) return false;

    // 业务逻辑
} finally {
    if (locked2) lock2.unlock();
    if (locked1) lock1.unlock();
}
```

**防死锁关键点：**

* 永远保证锁获取顺序一致（所有线程一致！）；
* tryLock 都有超时；
* finally 中严格按逆序释放；
* 出现任一失败立即释放前面锁。

---

### ✅ 方案3：逻辑合并 → 单一复合锁Key

有时双锁完全没必要。
可以通过 **业务Key拼接**，形成一个唯一性强的单锁：

```java
String combinedKey = "biz:lock:" + merchantId + ":" + orderId;
RLock lock = redissonClient.getLock(combinedKey);
```

优点：

* 逻辑简单；
* 无死锁风险；
* 性能最高。

缺点：

* 粒度较粗；
* 不能单独控制部分锁。

---

## 🧯 5.5、死锁防御 checklist

| 问题    | 防御策略                            |
| ----- | ------------------------------- |
| 锁顺序不同 | 所有地方加锁顺序必须一致                    |
| 某锁未释放 | try/finally 严格释放                |
| 网络闪断  | 使用 RedissonMultiLock            |
| 加锁太久  | 使用合理 leaseTime 或启用 watchDog     |
| 加锁失败  | tryLock + 超时参数，不要用 lock() 阻塞式方法 |

---

## ✅ 5.6、推荐模板代码（生产可用）

```java
public boolean executeWithDoubleLock(String key1, String key2, Runnable task) {
    RLock lock1 = redissonClient.getLock(key1);
    RLock lock2 = redissonClient.getLock(key2);
    RLock multiLock = redissonClient.getMultiLock(lock1, lock2);

    boolean locked = false;
    try {
        locked = multiLock.tryLock(5, 30, TimeUnit.SECONDS);
        if (!locked) {
            log.warn("Double lock acquisition failed: {}, {}", key1, key2);
            return false;
        }
        task.run();
        return true;
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return false;
    } catch (Exception e) {
        log.error("Error during double lock execution", e);
        return false;
    } finally {
        if (locked) {
            try {
                multiLock.unlock();
            } catch (Exception e) {
                log.warn("Failed to unlock multiLock", e);
            }
        }
    }
}
```

---

## 🔒5.7 结论总结

| 场景        | 推荐方案            | 死锁风险   |
| --------- | --------------- | ------ |
| 两个锁始终成对出现 | ✅ `RMultiLock`  | 🚫 无死锁 |
| 两个锁可单独存在  | ✅ 固定加锁顺序 + 超时释放 | ⚠️ 需谨慎 |
| 双锁逻辑可以简化  | ✅ 单锁Key拼接       | 🚫 无死锁 |

---

是否方便我帮你画一个图来展示这三种方案的加锁与释放流程？图形化后你能一眼看出为什么第一种（`RMultiLock`）是最稳妥的。


