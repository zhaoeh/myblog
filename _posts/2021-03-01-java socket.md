---
layout:     post
title:      Java网络编程
subtitle:   Socket是java网络编程的基础
date:       2021-03-01
author:     zhaoeh
header-img: img/post-bg-myself2.jpg
catalog: true
tags:
    - Java中级知识
---

# 1. Socket原理
1.  网络编程主要依赖于Jdk中的Socket类和ServerSocket类。Socket类充当客户端，ServerSocket类充当服务器端。  
2.  Socket将指定内容通过输出流OutputStream输出到服务器端，服务器端的Socket对象会通过输出流InputStream接收Socket发送的数据，并对该数据进行处理，处理完毕后可能会通过输出流输出到Socket客户端的输入流中进行响应。  
3.  Socket编程中注意客户端启动的Socket不要定义为成员变量，一旦定义为成员变量，将会面临单利模式的多线程安全风险，因为成员变量有可能是共享可变成员，极有可能被多个线程对象共享，如此一来，在Socket客户端和Socket服务端进行网络通信遇到较大的传输报文时，有可能造成IO阻塞，导致成员变量的Socket对象被回收，此时服务端误以为客户端的Socket已经失效就主动关闭Socket链接，这样导致客户端总是报错Connection reset。  

# 2. 网络通信协议 TCP 和 UDP
## 2.1 TCP/IP协议
1.  tcp/ip协议是实现任何远程通信的基础协议。只要牵扯远程通信，其底层都是tcp/ip协议。  
2.  java中的Socket就是对tcp/ip协议的包装，可以方便的实现远程通信。  
3.  任何作为服务方的ServerSocket或者类似的服务器比如Servlet容器，其本身就是多线程方式启动的，至于线程的启动方式可能是单例方式启动也可能是多例方式启动。采取多线程方式启动socket服务端，目的是为了同时处理多个socket客户端的并发请求。  
4.  tcp请求本身分为同步和异步，默认tcp请求都是同步请求：  
    同步：只要Socket和ServerSocket建立连接并存在数据交互，则客户端线程就必须等待服务器端将数据处理完毕后才能继续执行。  
    异步：客户端和服务端只建立Socket连接而不存在任何的数据交互，则客户端实际上并依赖服务端的响应，所以只要客户端和服务端建立完连接后，客户端线程即立即返回做自己的事情。  
5.  扩展：现实中，tcp本身的异步方式几乎每用武之地。因为很少存在客户端只和服务端建立连接而不存在任何数据交互的场景。  
    因此，对于既需要获取服务方的响应数据又想实现异步通信，只能依靠代码自己控制。  
    比如客户端通过多线程去实现异步、比如http请求依赖ajax的异步请求实现的局部刷新等。  

## 2.2 UDP协议


## 2.3 HTTP协议
1.  对于http而言，虽然底层依赖的是tcp协议，但是Http和客户端浏览器有关。  
2.  http建立连接和java中的同步是一样的。  
3.  http建立的链接默认是同步的，不管是否需要服务端的响应结果，其默认就是同步的。  
4.  http链接如果需要异步需要使用ajax技术或者使用多线程创建httpClient。  

# 3. 连接超时时间
Socket客户端和ServerSocket服务端通过Socket完成三次握手建立tcp连接，设置一个时间值，超过这个时间如果连接还没有成功建立，则返回连接超时。  

# 4. 读写超时时间
Socket客户端和ServerSocket服务端通过Socket完成三次握手建立tcp连接，开始传输数据，读写输入流和输出流也需要时间限制，如果超过指定时间则报读写超时。  
一般来说，连接超时时间设置的比较小，而读写超时时间设置值比较大一些。  
这两者没有任何关系，读写超时时间是在客户端和服务端之间已经开始传递数据后才计算的，此时tcp链接已经建立完成了。  

# 5. 从rpc的幂等性探讨读写超时、重试机制的底层
## 5.1 rpc遵守tcp/ip协议
不论是http还是rpc等远程通信协议，其底层都遵守tcp/ip协议。  

## 5.2 tcp/ip协议的同步和异步
任何通信协议几乎都离不开tcp/ip协议的支持，tcp/ip协议本身分为同步和异步：  
1.  Request-发出后，客户端不需要等待服务端的响应流，属于tcp/ip异步通信。  
2.  Request-Response，必须满足“客户端-服务端”的通信模式，即客户端发出request后，必须同步等待服务端的响应数据，属于tcp/ip同步通信。  
注意：上述同步和异步是tcp/ip协议本身支持的同步和异步方式，意味着在不使用多线程等方式人为干涉tcp/ip协议的方式下，其本身就支持的同步和异步方式。  

## 5.3 客户端和服务端的读写超时前提
Socket要想让读写超时，前提必须得有读有写，即：客户端需要得到服务端响应流数据的前提下，才会存在读写超时的可能性。  
意味着，读写超时的前提是tcp/ip本身的同步方式。如果客户端不需要得到服务端响应数据，则此时通信方式为异步，客户端线程建立完链接后便立即返回，而永不可能出现什么所谓读写超时。  

## 5.4 rpc远程调用中的超时重试机制
1.  rpc框架底层都是基于tcp/ip进行远程通信的。  
2.  当没有使用分布式架构前，所有应用共享同一个JVM，此时不管是同步调用还是异步调用，不管是同步回调还是异步回调，都不牵扯网络超时问题，因为同属一个JVM，不涉及远程网络通信。  
3.  一旦使用rpc，比如dubbo，那么consumer和provider之间的远程通信就和通信超时有关系了，此时超时机制和重试机制取决于：  
    consumer发起的请求是否需要服务方返回数据，即服务方接口是否是具有返回值的方法。  
    如果服务方的接口是没有返回值的方法，那么超时和重试机制将不会影响客户端的调用，因为客户端压根就不需要等待服务端的响应结果，服务端就慢慢执行就行了。  
4.  最终结论：tcp通信（包括一切基于tcp协议的通信）和rpc远程调用中，超时机制和重试机制是否有效，取决于客户端是够需要等待服务端的响应数据。  
    如果服务方不需要返回数据，则客户端不会超时，哪怕服务器执行100年；  
    如果客户端需要等待服务方响应数据，则客户端有可能超时，因为此时客户端会一直阻塞去等待服务端数据的响应。  

# 6. socket编程案例