---
layout:     post
title:      代码评审
subtitle:   常见的code review标准
categories: [零散知识点]
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---

# 1.编码规范
1.Integer参数禁止直接通过==和整数值比如1，2，3之类的值参与相等比较远算，建议使用Objects.equals()进行两个对象的相等比较，尤其注意拆箱空指针陷阱

2.对于不可控的数据集，禁止全量更新，必须重新考虑实现策略。

具体来讲，以彩票返水表举例：

针对当前代理数量和玩家数量的业务量级评估，得出的结论是：当前只有几百个玩家或者几十个代理，就认为可以全量的更新对应的表，不会出现问题。这种评估维度就是不可控的数据量膨胀维度，因为随着业务发展，表数据的膨胀是不可预期的，不可控的，不可枚举的。

同理，可控的数据集评估是指：比如一个代理只有十几个彩种，每个彩种有几十个玩法，这种维度针对某一个代理的量，总是可以全部枚举的，它的量级就是可控的。

因此，规则如下：

对于不可控的数据量级，严禁批量更新，主动思考应对之策，换方案，DBA也是禁止这种编码行为的。

3.java8 stream操作集合对象时，尤其注意内部元素为null的情况，避免空指针。

4.同理，java8转换集合为Map时，key和null不允许为null，要考虑null值的场景。

5.数据库事务问题：业务操作需要保证事务一致性的场景，必须添加事务注解。异步任务中的事务需要和主线程事务保持一致的，必须考虑事务一致性方案。

6.查询操作，禁止在一个线程调用链路中反复查询相同的数据，重复操作DB查询的场景，严格禁止！

7.禁止在for循环中遍历连接DB进行查询行为，一切重量级操作进入循环内部调度时，应慎重分析，所有的操作应该在循环外部一次性聚合。理论上循环体内部只负责处理应用逻辑策略，不涉及重量级操作。

8.比对两个List，求交集，差集，聚合操作等，请优化自己的java8代码，禁止for循环里面嵌套for循环去过滤出期望数据，编码时，优先将一方转为map缓存起来，然后在遍历时直接获取匹配期望值！

9.判空：对于一个集合、一个java对象，不确定上游传入的是否为null，请优先判空或者使用Optional去操作。

10.mybatis查询对象，查询出来的单个对象，必须进行判空操作

11.禁止使用默认线程池配置，只要是异步线程池操作，必须自定义线程池配置

12.禁止在循环中进行复杂bean复制操作，优先使用mapStruct进行属性复制

13.增量新接口，必须对入参进行校验，优先使用spring validation校验器或者扩展的自定义校验器

14.异常处理必须明确

15.事务一致性必须考虑

16.快速失败，编码时必须考虑，只允许合法的请求进入到代码流程中，一切不合法的快速失败

---------------

编码流程：
任何一个请求，不论是客户端发起的，还是job触发的，或者是监听器回调消费的，只要请求进到这一套流程，整条调度链路就需要全盘走读，主要考虑如下几点：      
1.要严格避免重复查库的操作。概括起来就是，一个下游逻辑需要的源数据，一旦在上游已经获取，那么这个源，理论上就应该是唯一的，下游对该源的需求，或者衍生需求，应该从上游这个源进行推导，即在JVM内存中进行推导，而不是缺啥就查啥。如果遇到一个需要的东西，就mapper一次，后续并发量上来这都是性能坑点      
2.所有校验类的动作，理论上都需要前置去做，所谓 fail-fast 原则，不符合流程正常进行下去的校验，就提前做，提前终止流程，而不是做了一系列重量级操作后，又来了一个校验直接抛了异常出去，如此一来JVM中堆积的东西全部是无用功      
3.return的操作，需要注意编码流程的先后顺序，避免在return操作之前做一些和return操作无关的操作      
4.流程中涉及到java编码这块的，尤其是集合类（List/Set）等，避免在循环中频繁操作DB，一定要习惯性做提前聚合，映射为hash等      


写逻辑的时候假设自己就是当前在干这套逻辑的线程，这个线程到底该不该频繁查DB，到底该怎么处理循环的场景，到底该怎么过滤，都需要仔细考量哈      

# 2.code review重点关注
（1）API接口，安全问题，用户认证、授权问题、跨服务调用的API鉴权、验签问题等。        
（2）入参问题，入参校验，必须趋向于严格校验，任何API都要站在完全脱离客户端的视角去考虑接口的健壮性问题。参数范围、参数有效值，是否必传，是否忽略，核心参数是否从后台获取，是否严格校验等。API级别的出参问题，任何响应给客户端的字段，没啥必要响应的直接就物理屏蔽掉；敏感字段必须要考虑脱敏，核心字段就不应该响应给客户端。            
（3）API流控问题，如何访问客户端使用工具恶意攻击，恶意高频访问任何接口。          
（4）业务侧，工具类调试问题，确保公共类、工具类等是完全可信任、完全高质量的。         
（5）异常问题，针对http restful等请求，必须使用spring mvc全局异常处理器统一进行视图层的异常响应转换。对于在springmvc之前，比如Filter链路中抛出的异常，必须考虑认为的全局捕获处理。比如合理的定义业务异常和技术性异常，比如转换所有可预测的技术性异常，严格来说，技术性异常禁止直接响应给客户端。            
（6）异常处理，对于非 http 请求的异常，必须自己实现一个类似拦截器或者AOP，或者一个公共钩子方法等，统一处理非http请求流程中抛出的异常，比如xxlJob,MQ监听器消费，Redis监听器消费、WS长连接等逻辑中抛出的异常，凡是不通过spring mvc的DispatcherServlet的客户端请求，都需要考虑如何处理整个流程中的异常。          
（7）空指针问题，严格考虑空指针问题，不要再告诉我那个值不可能为null之类的，正常情况下绝对不可能为null啥的，自己写代码时就直接要思考，确保你这个方法本身的健壮性，该判空就判空，一个原则，自己实现的方法的健壮性，坚决不能依赖该方法以外的任何因素，否则这个方法就不是健壮的。         
（8）并发问题，如何确保并发场景下的线程安全问题，该加锁就加锁。         
（9）数据库事务问题，本地事务的粒度，事务范围到底应该多大，事务隔离，涉及到跨JVM场景下的本地事务问题等，需要仔细评估考量。        
（10）缓存一致性问题，为什么使用缓存？如何使用好缓存？什么场景下使用分布式缓存？什么场景下使用本地缓存等？缓存TTL有效期时间？缓存失效策略？缓存回填策略？缓存和持久层数据一致性问题等，都需要慎重严格的确保整个缓存组件在业务使用过程中的闭环问题，不能漏掉任何一个持久层变动，而没有尽心缓存刷新的场景。         
（11）序列化和反序列化问题，API在通过http或者WS和客户端等通信过程中，如何处理请求参数的反序列化安全性问题？如何处理响应参数的序列化安全问题？如何考虑后端参数到底要不要使用泛型等类型进行接收处理？            
